
<!DOCTYPE html>
<html lang="en-US">
<head>
<meta charset="UTF-8" />
<meta name="generator" content="LaTeX Lwarp package" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<!--[if lt IE 9]>
<script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
<![endif]-->
<title>Ancient Science Publishers — Top 20 Coding Interview Problems Asked in Google with Solutions</title>
<link rel="stylesheet" type="text/css" href="lwarp_sagebrush.css" />

<script>
// Lwarp MathJax emulation code
//
// Based on code by Davide P. Cervone.
// Equation numbering: https://github.com/mathjax/MathJax/issues/2427
// Starred and ifnextchar macros: https://github.com/mathjax/MathJax/issues/2428
// \left, \right delimiters: https://github.com/mathjax/MathJax/issues/2535
//
// Modified by Brian Dunn to adjust equation numbering and add subequations.
//
// LaTeX can use \seteqnumber{subequations?}{section}{number} before each equation.
// subequations? is 0 usually, 1 if inside subequations.
// section is a string printed as-is, or empty.
// number is auto-incremented by MathJax between equations.
//
MathJax = {
   subequations: "0",
   section: "",
   loader: {
      load: ['[tex]/tagformat', '[tex]/textmacros'],
   },
   startup: {
      ready() {
        // These would be replaced by import commands if you wanted to make
        // a proper extension.
        const Configuration = MathJax._.input.tex.Configuration.Configuration;
        const CommandMap = MathJax._.input.tex.SymbolMap.CommandMap;
        const Macro = MathJax._.input.tex.Symbol.Macro;
        const TexError = MathJax._.input.tex.TexError.default;
        const ParseUtil = MathJax._.input.tex.ParseUtil.default;
        const expandable = MathJax._.util.Options.expandable;

           // Insert the replacement string into the TeX string, and check
           // that there haven't been too many maxro substitutions (prevents
           // infinite loops).
           const useArgument = (parser, text) => {
             parser.string = ParseUtil.addArgs(parser, text, parser.string.slice(parser.i));
             parser.i = 0;
             if (++parser.macroCount > parser.configuration.options.maxMacros) {
               throw new TexError('MaxMacroSub1',
               'MathJax maximum macro substitution count exceeded; ' +
               'is there a recursive macro call?');
             }
           }

           // Create the command map for:
           //      \ifstar, \ifnextchar, \ifblank, \ifstrequal, \seteqnumber
           new CommandMap('Lwarp-macros', {
              ifstar: 'IfstarFunction',
              ifnextchar: 'IfnextcharFunction',
              ifblank: 'IfblankFunction',
              ifstrequal: 'IfstrequalFunction',
              seteqnumber: 'SeteqnumberFunction'
           }, {
              // This function implements an ifstar macro.
              IfstarFunction(parser, name) {
                 const resultstar = parser.GetArgument(name);
                 const resultnostar = parser.GetArgument(name);
                 const star = parser.GetStar();                 // true if there is a *
                 useArgument(parser, star ? resultstar : resultnostar);
              },

             // This function implements an ifnextchar macro.
             IfnextcharFunction(parser, name) {
                let whichchar = parser.GetArgument(name);
                if (whichchar.match(/^(?:0x[0-9A-F]+|[0-9]+)$/i)) {
                  // $ syntax highlighting
                  whichchar = String.fromCodePoint(parseInt(whichchar));
                }
                const resultnextchar = parser.GetArgument(name);
                const resultnotnextchar = parser.GetArgument(name);
                const gotchar = (parser.GetNext() === whichchar);
                useArgument(parser, gotchar ? resultnextchar : resultnotnextchar);
             },

             // This function implements an ifblank macro.
             IfblankFunction(parser, name) {
                const blankarg = parser.GetArgument(name);
                const resultblank = parser.GetArgument(name);
                const resultnotblank = parser.GetArgument(name);
                const isblank = (blankarg.trim() == "");
                useArgument(parser, isblank ? resultblank : resultnotblank);
             },

             // This function implements an ifstrequal macro.
             IfstrequalFunction(parser, name) {
                const strequalfirst = parser.GetArgument(name);
                const strequalsecond = parser.GetArgument(name);
                const resultequal = parser.GetArgument(name);
                const resultnotequal = parser.GetArgument(name);
                const isequal = (strequalfirst == strequalsecond);
                useArgument(parser, isequal ? resultequal : resultnotequal);
             },

             // This function modifies the equation numbers.
             SeteqnumberFunction(parser, name) {
                 // Get the macro parameters
                 const star = parser.GetStar();                  // true if there is a *
                 const optBrackets = parser.GetBrackets(name);   // contents of optional brackets
                 const newsubequations = parser.GetArgument(name); // the subequations argument
                 const neweqsection = parser.GetArgument(name); // the eq section argument
                 const neweqnumber = parser.GetArgument(name);   // the eq number argument
                 MathJax.config.subequations=newsubequations ;   // a string with boolean meaning
                 MathJax.config.section=neweqsection ;           // a string with numeric meaning
                 parser.tags.counter = parser.tags.allCounter = neweqnumber ;
             }

           });

           // Create the Lwarp-macros package
           Configuration.create('Lwarp-macros', {
             handler: {macro: ['Lwarp-macros']}
           });

           MathJax.startup.defaultReady();

           // For forward references:
           MathJax.startup.input[0].preFilters.add(({math}) => {
             if (math.inputData.recompile){
                 MathJax.config.subequations = math.inputData.recompile.subequations;
                 MathJax.config.section = math.inputData.recompile.section;
             }
           });
           MathJax.startup.input[0].postFilters.add(({math}) => {
             if (math.inputData.recompile){
                 math.inputData.recompile.subequations = MathJax.config.subequations;
                 math.inputData.recompile.section = MathJax.config.section;
             }
           });

             // For \left, \right with unicode-math:
             const {DelimiterMap} = MathJax._.input.tex.SymbolMap;
             const {Symbol} = MathJax._.input.tex.Symbol;
             const {MapHandler} = MathJax._.input.tex.MapHandler;
             const delimiter = MapHandler.getMap('delimiter');
             delimiter.add('\\lBrack', new Symbol('\\lBrack', '\u27E6'));
             delimiter.add('\\rBrack', new Symbol('\\rBrack', '\u27E7'));
             delimiter.add('\\lAngle', new Symbol('\\lAngle', '\u27EA'));
             delimiter.add('\\rAngle', new Symbol('\\rAngle', '\u27EB'));
             delimiter.add('\\lbrbrak', new Symbol('\\lbrbrak', '\u2772'));
             delimiter.add('\\rbrbrak', new Symbol('\\rbrbrak', '\u2773'));
             delimiter.add('\\lbag', new Symbol('\\lbag', '\u27C5'));
             delimiter.add('\\rbag', new Symbol('\\rbag', '\u27C6'));
             delimiter.add('\\llparenthesis', new Symbol('\\llparenthesis', '\u2987'));
             delimiter.add('\\rrparenthesis', new Symbol('\\rrparenthesis', '\u2988'));
             delimiter.add('\\llangle', new Symbol('\\llangle', '\u2989'));
             delimiter.add('\\rrangle', new Symbol('\\rrangle', '\u298A'));
             delimiter.add('\\Lbrbrak', new Symbol('\\Lbrbrak', '\u27EC'));
             delimiter.add('\\Rbrbrak', new Symbol('\\Rbrbrak', '\u27ED'));
             delimiter.add('\\lBrace', new Symbol('\\lBrace', '\u2983'));
             delimiter.add('\\rBrace', new Symbol('\\rBrace', '\u2984'));
             delimiter.add('\\lParen', new Symbol('\\lParen', '\u2985'));
             delimiter.add('\\rParen', new Symbol('\\rParen', '\u2986'));
             delimiter.add('\\lbrackubar', new Symbol('\\lbrackubar', '\u298B'));
             delimiter.add('\\rbrackubar', new Symbol('\\rbrackubar', '\u298C'));
             delimiter.add('\\lbrackultick', new Symbol('\\lbrackultick', '\u298D'));
             delimiter.add('\\rbracklrtick', new Symbol('\\rbracklrtick', '\u298E'));
             delimiter.add('\\lbracklltick', new Symbol('\\lbracklltick', '\u298F'));
             delimiter.add('\\rbrackurtick', new Symbol('\\rbrackurtick', '\u2990'));
             delimiter.add('\\langledot', new Symbol('\\langledot', '\u2991'));
             delimiter.add('\\rangledot', new Symbol('\\rangledot', '\u2992'));
             delimiter.add('\\lparenless', new Symbol('\\lparenless', '\u2993'));
             delimiter.add('\\rparengtr', new Symbol('\\rparengtr', '\u2994'));
             delimiter.add('\\Lparengtr', new Symbol('\\Lparengtr', '\u2995'));
             delimiter.add('\\Rparenless', new Symbol('\\Rparenless', '\u2996'));
             delimiter.add('\\lblkbrbrak', new Symbol('\\lblkbrbrak', '\u2997'));
             delimiter.add('\\rblkbrbrak', new Symbol('\\rblkbrbrak', '\u2998'));
             delimiter.add('\\lvzigzag', new Symbol('\\lvzigzag', '\u29D8'));
             delimiter.add('\\rvzigzag', new Symbol('\\rvzigzag', '\u29D9'));
             delimiter.add('\\Lvzigzag', new Symbol('\\Lvzigzag', '\u29DA'));
             delimiter.add('\\Rvzigzag', new Symbol('\\Rvzigzag', '\u29DB'));
             delimiter.add('\\lcurvyangle', new Symbol('\\lcurvyangle', '\u29FC'));
             delimiter.add('\\rcurvyangle', new Symbol('\\rcurvyangle', '\u29FD'));
             delimiter.add('\\Vvert', new Symbol('\\Vvert', '\u2980'));
       }     // ready
  },         // startup

  tex: {
    packages: {'[+]': ['tagformat', 'Lwarp-macros', 'textmacros']},
    tags: "ams",
         tagformat: {
             number: function (n) {
                 if(MathJax.config.subequations==0)
                      return(MathJax.config.section + n);
                 else
                      return(MathJax.config.section + String.fromCharCode(96+n));
             },
         },
  }
}
</script>

<script
    id="MathJax-script"
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"
></script>


</head>
<body>



<a id="index-autopage-272"></a>
<nav class="topnavigation"><a href="index.html" class="linkhome" >
Home</a></nav>

<header>

<p>
<a href="Cracking-Programming-Interviews-500-Questions-with-Solutions.html" class="linkhome" >
Previous</a>
</p>

</header>



<div class="bodyandsidetoc">
<div class="sidetoccontainer">



<nav class="sidetoc">



<div class="sidetoctitle">

<p>
<span class="sidetocthetitle">Ancient Science Publishers</span>
</p>

<p>
Contents
</p>
</div>



<div class="sidetoccontents">

<p>
<a href="index.html" class="linkhome" >
Home</a>
</p>

<p>
<a href="textcolor-redComputer-Science.html#autosec-9" class="tocpart" >
<span class="sectionnumber">I</span>&#x2003;<span
      class="textcolor"
      style="color:#FF0000"
>Computer Science</span></a>
</p>



<p>
<a href="textcolor-redComputer-Science.html#autosec-10" class="tocchapter" >
<span class="sectionnumber">1</span>&#x2003;Discipline of Competitive Programming : A Hacker’s Perspective</a>
</p>



<p>
<a href="Elements-Coding-Science-Deriving-Correct-Programs.html#autosec-13" class="tocchapter" >
<span class="sectionnumber">2</span>&#x2003;Elements of Coding : Science of Deriving Correct Programs</a>
</p>



<p>
<a href="Elements-Coding-Linear-Algebra-The-Nucleus-Artificial-Intelligence.html#autosec-16" class="tocchapter" >
<span class="sectionnumber">3</span>&#x2003;Elements of Coding Linear Algebra : The Nucleus of Artificial Intelligence</a>
</p>



<p>
<a href="Elements-Software-Design-Patterns.html#autosec-24" class="tocchapter" >
<span class="sectionnumber">4</span>&#x2003;Elements of Software Design Patterns</a>
</p>



<p>
<a href="Elements-Coding-AI.html#autosec-90" class="tocchapter" >
<span class="sectionnumber">5</span>&#x2003;Elements of Coding AI</a>
</p>



<p>
<a href="Elements-Coding-DL-Deep-Learning.html#autosec-92" class="tocchapter" >
<span class="sectionnumber">6</span>&#x2003;Elements of Coding DL (Deep Learning)</a>
</p>



<p>
<a href="Elements-Coding-ML-Internals-Machine-Learning-Library-MLPack.html#autosec-94" class="tocchapter" >
<span class="sectionnumber">7</span>&#x2003;Elements of Coding ML : Internals of Machine Learning Library MLPack</a>
</p>



<p>
<a href="Conceptual-BitCoin-Blockchain-Coding.html#autosec-96" class="tocchapter" >
<span class="sectionnumber">8</span>&#x2003;Conceptual BitCoin : Blockchain Coding</a>
</p>



<p>
<a href="Conceptual-Data-Science-Interviews.html#autosec-98" class="tocchapter" >
<span class="sectionnumber">9</span>&#x2003;Conceptual Data Science Interviews</a>
</p>



<p>
<a href="Conceptual-Dependency-Injection-Unwiring-Simplified-in-C.html#autosec-100" class="tocchapter" >
<span class="sectionnumber">10</span>&#x2003;Conceptual Dependency Injection : Unwiring Simplified in C++</a>
</p>



<p>
<a href="Conceptual-Dynamic-Programming-Optimal-Coding-Simplified.html#autosec-102" class="tocchapter" >
<span class="sectionnumber">11</span>&#x2003;Conceptual Dynamic Programming : Optimal Coding Simplified</a>
</p>



<p>
<a href="Conceptual-Programming-Interviews.html#autosec-104" class="tocchapter" >
<span class="sectionnumber">12</span>&#x2003;Conceptual Programming Interviews</a>
</p>



<p>
<a href="Conceptual-Machine-Learning.html#autosec-106" class="tocchapter" >
<span class="sectionnumber">13</span>&#x2003;Conceptual Machine Learning</a>
</p>



<p>
<a href="Conceptual-Programming-STL-Algorithms.html#autosec-108" class="tocchapter" >
<span class="sectionnumber">14</span>&#x2003;Conceptual Programming of STL Algorithms</a>
</p>



<p>
<a href="Conceptual-Solutions-CLRS-Introduction-Algorithms.html#autosec-110" class="tocchapter" >
<span class="sectionnumber">15</span>&#x2003;Conceptual Solutions to (CLRS) Introduction to Algorithms</a>
</p>



<p>
<a href="Conceptual-Programming-Algorithms-Using-Dijkstra’s-Approach.html#autosec-112" class="tocchapter" >
<span class="sectionnumber">16</span>&#x2003;Conceptual Programming of Algorithms Using Dijkstra’s Approach</a>
</p>



<p>
<a href="Conceptual-Solutions-Pattern-Recognition-Machine-Learning.html#autosec-114" class="tocchapter" >
<span class="sectionnumber">17</span>&#x2003;Conceptual Solutions to Pattern Recognition and Machine Learning</a>
</p>



<p>
<a href="Science-Deriving-Beautiful-Programs.html#autosec-116" class="tocchapter" >
<span class="sectionnumber">18</span>&#x2003;Science of Deriving Beautiful Programs</a>
</p>



<p>
<a href="Modern-C-Ranges-Revolution-in-STL.html#autosec-118" class="tocchapter" >
<span class="sectionnumber">19</span>&#x2003;Modern C++ Ranges : A Revolution in STL</a>
</p>



<p>
<a href="Elements-C-20.html#autosec-120" class="tocchapter" >
<span class="sectionnumber">20</span>&#x2003;Elements of C++20</a>
</p>



<p>
<a href="Solving-Problems-using-Dynamic-Programming-Hacker’s-Perspective.html#autosec-126" class="tocchapter" >
<span class="sectionnumber">21</span>&#x2003;Solving Problems using Dynamic Programming : A Hacker’s Perspective</a>
</p>



<p>
<a href="Hacking-TensorFlow-Internals-An-Insider’s-Commentary-on-Learning-System.html#autosec-157" class="tocchapter" >
<span class="sectionnumber">22</span>&#x2003;Hacking TensorFlow Internals : An Insider’s Commentary on A Learning System</a>
</p>



<p>
<a href="Advanced-C-FAQs-Vol-1-2.html#autosec-159" class="tocchapter" >
<span class="sectionnumber">23</span>&#x2003;Advanced C++ FAQs Vol 1 &amp; 2</a>
</p>



<p>
<a href="C-14-FAQs.html#autosec-161" class="tocchapter" >
<span class="sectionnumber">24</span>&#x2003;C++14 FAQs</a>
</p>



<p>
<a href="The-Boost-C-Libraries-Generic-Programming.html#autosec-261" class="tocchapter" >
<span class="sectionnumber">25</span>&#x2003;The Boost C++ Libraries: Generic Programming</a>
</p>



<p>
<a href="Generic-Algorithms-Data-Structures-using-C-11.html#autosec-263" class="tocchapter" >
<span class="sectionnumber">26</span>&#x2003;Generic Algorithms and Data Structures using C++11</a>
</p>



<p>
<a href="C-11-Standard-Library-Usage-Implementation.html#autosec-265" class="tocchapter" >
<span class="sectionnumber">27</span>&#x2003;C++11 Standard Library: Usage and Implementation</a>
</p>



<p>
<a href="Foundation-Algorithms-in-C-11.html#autosec-267" class="tocchapter" >
<span class="sectionnumber">28</span>&#x2003;Foundation of Algorithms in C++11</a>
</p>



<p>
<a href="C-11-Algorithms-Using-Extending-C-11-Boost-Beyond.html#autosec-269" class="tocchapter" >
<span class="sectionnumber">29</span>&#x2003;C++11 Algorithms : Using and Extending C++11, Boost and Beyond</a>
</p>



<p>
<a href="Cracking-Programming-Interviews-500-Questions-with-Solutions.html#autosec-271" class="tocchapter" >
<span class="sectionnumber">30</span>&#x2003;Cracking Programming Interviews : 500 Questions with Solutions</a>
</p>



<p>
<a href="Top-20-Coding-Interview-Problems-Asked-in-Google-with-Solutions.html#autosec-273" class="tocchapter" >
<span class="sectionnumber">31</span>&#x2003;Top 20 Coding Interview Problems Asked in Google with Solutions</a>
</p>



<p>
<a href="Top-10-Coding-Interview-Problems-Asked-in-Google-with-Solutions.html#autosec-335" class="tocchapter" >
<span class="sectionnumber">32</span>&#x2003;Top 10 Coding Interview Problems Asked in Google with Solutions</a>
</p>



<p>
<a href="Physics.html#autosec-371" class="tocpart" >
<span class="sectionnumber">II</span>&#x2003;Physics</a>
</p>



<p>
<a href="Mathematics.html#autosec-373" class="tocpart" >
<span class="sectionnumber">III</span>&#x2003;Mathematics</a>
</p>



</div>

</nav>

</div>



<main class="bodycontainer">



<section class="textbody">

<h1>Ancient Science Publishers</h1>

<!--MathJax customizations:-->



<div class="hidden">

\(\newcommand{\footnotename}{footnote}\)

\(\def \LWRfootnote {1}\)

\(\newcommand {\footnote }[2][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\newcommand {\footnotemark }[1][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\let \LWRorighspace \hspace \)

\(\renewcommand {\hspace }{\ifstar \LWRorighspace \LWRorighspace }\)

\(\newcommand {\mathnormal }[1]{{#1}}\)

\(\newcommand \ensuremath [1]{#1}\)

\(\newcommand {\LWRframebox }[2][]{\fbox {#2}} \newcommand {\framebox }[1][]{\LWRframebox } \)

\(\newcommand {\setlength }[2]{}\)

\(\newcommand {\addtolength }[2]{}\)

\(\newcommand {\setcounter }[2]{}\)

\(\newcommand {\addtocounter }[2]{}\)

\(\newcommand {\arabic }[1]{}\)

\(\newcommand {\number }[1]{}\)

\(\newcommand {\noalign }[1]{\text {#1}\notag \\}\)

\(\newcommand {\cline }[1]{}\)

\(\newcommand {\directlua }[1]{\text {(directlua)}}\)

\(\newcommand {\luatexdirectlua }[1]{\text {(directlua)}}\)

\(\newcommand {\protect }{}\)

\(\def \LWRabsorbnumber #1 {}\)

\(\def \LWRabsorbquotenumber &quot;#1 {}\)

\(\newcommand {\LWRabsorboption }[1][]{}\)

\(\newcommand {\LWRabsorbtwooptions }[1][]{\LWRabsorboption }\)

\(\def \mathchar {\ifnextchar &quot;\LWRabsorbquotenumber \LWRabsorbnumber }\)

\(\def \mathcode #1={\mathchar }\)

\(\let \delcode \mathcode \)

\(\let \delimiter \mathchar \)

\(\def \oe {\unicode {x0153}}\)

\(\def \OE {\unicode {x0152}}\)

\(\def \ae {\unicode {x00E6}}\)

\(\def \AE {\unicode {x00C6}}\)

\(\def \aa {\unicode {x00E5}}\)

\(\def \AA {\unicode {x00C5}}\)

\(\def \o {\unicode {x00F8}}\)

\(\def \O {\unicode {x00D8}}\)

\(\def \l {\unicode {x0142}}\)

\(\def \L {\unicode {x0141}}\)

\(\def \ss {\unicode {x00DF}}\)

\(\def \SS {\unicode {x1E9E}}\)

\(\def \dag {\unicode {x2020}}\)

\(\def \ddag {\unicode {x2021}}\)

\(\def \P {\unicode {x00B6}}\)

\(\def \copyright {\unicode {x00A9}}\)

\(\def \pounds {\unicode {x00A3}}\)

\(\let \LWRref \ref \)

\(\renewcommand {\ref }{\ifstar \LWRref \LWRref }\)

\( \newcommand {\multicolumn }[3]{#3}\)

\(\require {textcomp}\)

\(\newcommand {\toprule }[1][]{\hline }\)

\(\let \midrule \toprule \)

\(\let \bottomrule \toprule \)

\(\def \LWRbooktabscmidruleparen (#1)#2{}\)

\(\newcommand {\LWRbooktabscmidrulenoparen }[1]{}\)

\(\newcommand {\cmidrule }[1][]{\ifnextchar (\LWRbooktabscmidruleparen \LWRbooktabscmidrulenoparen }\)

\(\newcommand {\morecmidrules }{}\)

\(\newcommand {\specialrule }[3]{\hline }\)

\(\newcommand {\addlinespace }[1][]{}\)

\(\def \LWRpagenote {1}\)

\(\newcommand {\pagenote }[2][\LWRpagenote ]{{}^{\mathrm {#1}}}\)

\(\newcommand {\intertext }[1]{\text {#1}\notag \\}\)

\(\let \Hat \hat \)

\(\let \Check \check \)

\(\let \Tilde \tilde \)

\(\let \Acute \acute \)

\(\let \Grave \grave \)

\(\let \Dot \dot \)

\(\let \Ddot \ddot \)

\(\let \Breve \breve \)

\(\let \Bar \bar \)

\(\let \Vec \vec \)

\(\newcommand {\conceptequiv }{\triangleq }\)

\(\newcommand {\CC }{\mathcal {C}}\)

\(\newcommand {\refines }{\looparrowright }\)

\(\newcommand {\weakens }{\looparrowleft }\)

\(\DeclareMathOperator *{\Max }{Max}\)

\(\DeclareMathOperator *{\Min }{Min}\)

\(\newcommand {\mleft }{\left }\)

\(\newcommand {\mright }{\right }\)

\(\newcommand {\mleftright }{}\)

\(\newcommand {\mleftrightrestore }{}\)

\(\require {physics}\)

\(\newcommand {\bigO }{\mathcal {O}}\)

</div>

<p>
<!--................................-->
<h3 id="autosec-273">Monograph&nbsp;<span class="sectionnumber">31&#x2003;</span>Top 20 Coding Interview Problems Asked in Google with Solutions</h3>
<a id="index-autopage-273"></a>
<a id="index-autofile-31"></a>
<div class="marginblock" role="note" style="width:217pt; float:right; ">
<div class="center">

<p>


<a href="top20/cover.svg" target="_blank" ><img
      src="top20/cover.svg"
      style="
      width:217pt;
      "
      class="inlineimage"
      alt="(image)"
></a>
</p>
</div>

</div>

<p>
This book is written for helping people prepare for Google Coding Interview. It contains top 20 programming problems frequently asked @Google with detailed worked-out solutions both in
pseudo-code and C++ (and C++11).
</p>

<p>
It came out as a result of numerous requests received from coders across the Globe, primarily from Google aspirants. Author has a vast collection of algorithmic problems since 20 years including
experience in preparing computer science students for participation in programming contests like TopCoder, ACM ICPC and others.
</p>
<div class="center">

<p>
<b>Must Have for Google Aspirants !!!</b>
</p>
</div>

<ul style="list-style-type:none">


<li>
<p>
1. <em><span
      class="textcolor"
      style="color:#4D0000"
>Matching Nuts and Bolts Optimally</span></em>
</p>


</li>
<li>


<p>
2. <em><span
      class="textcolor"
      style="color:#4D0000"
>Searching two-dimensional sorted array</span></em>
</p>


</li>
<li>


<p>
3. <em><span
      class="textcolor"
      style="color:#4D0000"
>Lowest Common Ancestor(LCA) Problem</span></em>
</p>


</li>
<li>


<p>
4. <em><span
      class="textcolor"
      style="color:#4D0000"
>Max Sub-Array Problem</span></em>
</p>


</li>
<li>


<p>
5. <em><span
      class="textcolor"
      style="color:#4D0000"
>Compute Next Higher Number</span></em>
</p>


</li>
<li>


<p>
6. <em><span
      class="textcolor"
      style="color:#4D0000"
>2D Binary Search</span></em>
</p>


</li>
<li>


<p>
7. <em><span
      class="textcolor"
      style="color:#4D0000"
>String Edit Distance</span></em>
</p>


</li>
<li>


<p>
8. <em><span
      class="textcolor"
      style="color:#4D0000"
>Searching in Two Dimensional Sequence</span></em>
</p>


</li>
<li>


<p>
9. <em><span
      class="textcolor"
      style="color:#4D0000"
>Select Kth Smallest Element</span></em>
</p>


</li>
<li>


<p>
10. <em><span
      class="textcolor"
      style="color:#4D0000"
>Searching in Possibly Empty Two Dimensional Sequence</span></em>
</p>


</li>
<li>


<p>
11. <em><span
      class="textcolor"
      style="color:#4D0000"
>The Celebrity Problem</span></em>
</p>


</li>
<li>


<p>
12. <em><span
      class="textcolor"
      style="color:#4D0000"
>Switch and Bulb Problem</span></em>
</p>


</li>
<li>


<p>
13. <em><span
      class="textcolor"
      style="color:#4D0000"
>Interpolation Search</span></em>
</p>


</li>
<li>


<p>
14. <em><span
      class="textcolor"
      style="color:#4D0000"
>The Majority Problem</span></em>
</p>


</li>
<li>


<p>
15. <em><span
      class="textcolor"
      style="color:#4D0000"
>The Plateau Problem</span></em>
</p>


</li>
<li>


<p>
16. <em><span
      class="textcolor"
      style="color:#4D0000"
>Segment Problems</span></em>
</p>


</li>
<li>


<p>
17. <em><span
      class="textcolor"
      style="color:#4D0000"
>Efficient Permutation</span></em>
</p>


</li>
<li>


<p>
18. <em><span
      class="textcolor"
      style="color:#4D0000"
>The Non-Crooks Problem</span></em>
</p>


</li>
<li>


<p>
19. <em><span
      class="textcolor"
      style="color:#4D0000"
>Median Search Problem</span></em>
</p>


</li>
<li>


<p>
20. <em><span
      class="textcolor"
      style="color:#4D0000"
>Missing Integer Problem</span></em>
</p>
</li>
</ul>

<p>
<span class="underline"><b><span
      class="textcolor"
      style="color:#FF7D00"
>Excerpt from the Chapter</span> <span
      class="textcolor"
      style="color:#4D0000"
>2:</span></b></span>
</p>
<!--................................-->
<h4 id="autosec-277">Searching two-dimensional sorted array</h4>
<a id="index-autopage-277"></a>
<div class="center">

<p>
<b><span
      class="textcolor"
      style="color:#808000"
>**<span class="textsc">Problem</span> 2 (David Gries)</span></b>
</p>
</div>

<p>
<span
      class="textcolor"
      style="color:#9E00FF"
><em>Design and implement an efficient algorithm to search for a given integer x in a 2-dimensional <b>sorted</b> array a[0..m][0..n]. Please note that it is sorted row-wise and column-wise in
ascending order.</em></span>
</p>
<div class="center">

<p>
<b><span
      class="textcolor"
      style="color:#808000"
><span class="textsc">Solution</span></span></b>
</p>
</div>
<!--................................-->
<h5 id="autosec-280">Basic Analysis</h5>
<a id="index-autopage-280"></a>



<p>
&#x2003;&#x2003;Let us start analyzing the problem by looking at implied properties related to search space. This array has the following properties:
</p>
<ul style="list-style-type:none">


<li>
<p>
1. no of rows \(m \geq 1\)
</p>


</li>
<li>


<p>
2. no of columns \(n \geq 1\)
</p>


</li>
<li>


<p>
3. Entries in each row are ordered by \(\leq \), i.e., for \(0 \leq i &lt; m\) &amp;&amp; \(0 \leq j &lt; n\)<br />
<span
      class="fbox"
      style="display:inline-block ; border:1pt solid #000000; padding:3pt ; color:#000000"
>\(\mathbf {a[i][j] \leq a[i][j+1]}\)</span>
</p>
<ul style="list-style-type:none">


<li>
<p>
• \(a_{11} \leq a_{12} \leq \ldots \leq a_{1n}\)
</p>


</li>
<li>


<p>
• \(a_{21} \leq a_{22} \leq \ldots \leq a_{2n}\)<br />
&#x22EE;
</p>


</li>
<li>


<p>
• \(a_{m1} \leq a_{m2} \leq \ldots \leq a_{mn}\)
</p>
</li>
</ul>
</li>
<li>


<p>
4. Entries in each column are ordered by \(\leq \), i.e., for \(0 \leq i &lt; m\) &amp;&amp; for \(0 \leq j &lt; n\)<br />
<span
      class="fbox"
      style="display:inline-block ; border:1pt solid #000000; padding:3pt ; color:#000000"
>\(\mathbf {a[i][j] \leq a[i+1][j]}\)</span>
</p>
<ul style="list-style-type:none">


<li>
<p>
• \(a_{11} \leq a_{21} \leq \ldots \leq a_{m1}\)
</p>


</li>
<li>


<p>
• \(a_{12} \leq a_{22} \leq \ldots \leq a_{m2}\)<br />
&#x22EE;
</p>


</li>
<li>


<p>
• \(a_{1n} \leq a_{2n} \leq \ldots \leq a_{mn}\)
</p>
</li>
</ul>
</li>
</ul>

<p>
Pictorial representation of two-dimensional sorted array is as follows:
</p>
<div class="center">

<p>
<span
      id="lateximage-index-33"
      class="lateximagesource"
><!--
a11   a12   ...   a1n

a21   a22   ...   a2n

 ..    ..   ...    ..
  .     .           .

am1   am2   ...   amn
--><img
      src="index-images/image-33.svg"
      alt="(-tikz-&nbsp;diagram)"
      style=""
      class="lateximage"
></span>
</p>
</div>

<p>
With the properties above, we have to develop an efficient algorithm to find the position of a given integer x in the array a, i.e., the algorithm should find i and j such that <span
      class="fbox"
      style="display:inline-block ; border:1pt solid #000000; padding:3pt ; color:#000000"
>\(\mathbf {x = a[i, j]}\)</span>. By efficient we mean to minimize the number of comparisons as much as possible.<br />
Let us treat the input array as some kind of a rectangular region.<br />
The problem demands that the integer \(x\) does exist somewhere in this region. Let us label this condition as <em>Input Assertion</em> or <em>Precondition</em>.
</p>
<!--................................-->
<h5 id="autosec-284">Precondition (aka <i>Input Assertion</i>)</h5>
<a id="index-autopage-284"></a>



<p>
<span
      class="fbox"
      style="display:inline-block ; border:1pt solid #000000; padding:3pt ; color:#000000"
>\(\mathbf {x \in a[0..m-1, 0..n-1]}\)</span><br />
i.e., x is present somewhere in this rectangular region \(a\).
</p>
<div class="center">

<p>
<span
      id="lateximage-index-34"
      class="lateximagesource"
><!--
 0        n−1


      x



m−1
--><img
      src="index-images/image-34.svg"
      alt="(-tikz-&nbsp;diagram)"
      style=""
      class="lateximage"
></span>
</p>
</div>

<p>
After the program terminates successfully, \(x\) has to be found in a rectangular region of \(a\) where the rectangular region consists of just one row and column. Let us label this condition as
<em>Output Assertion</em> or <em>Result Assertion</em> or <em>Postcondition</em>.
</p>
<!--................................-->
<h5 id="autosec-288">Postcondition (aka <i>Result Assertion)</i></h5>
<a id="index-autopage-288"></a>



<p>
<span
      class="fbox"
      style="display:inline-block ; border:1pt solid #000000; padding:3pt ; color:#000000"
>\(\mathbf {0 \leq i \leq m-1}\)</span> &amp;&amp; <span
      class="fbox"
      style="display:inline-block ; border:1pt solid #000000; padding:3pt ; color:#000000"
>\(\mathbf {0 \leq j \leq n-1}\)</span> &amp;&amp; <span
      class="fbox"
      style="display:inline-block ; border:1pt solid #000000; padding:3pt ; color:#000000"
> \(\mathbf {x = a[i, j]}\)</span><br />
i.e., x is in a rectangular region of \(a\) where the rectangular region consists of just one row and column, i.e., \(x\) is present at \(i^{th}\) row and \(j^{th}\) column of \(a\).
</p>
<div class="center">

<p>
<span
      id="lateximage-index-35"
      class="lateximagesource"
><!--
    0   j   n−1


i       x



m−1
--><img
   src="index-images/image-35.svg"
   alt="(-tikz-&nbsp;diagram)"
   style=""
   class="lateximage"
></span>
</p>
</div>
<!--................................-->
<h5 id="autosec-292">Invariant</h5>
<a id="index-autopage-292"></a>



<p>
Looking at the precondition and postcondition, it is not that difficult to figure out that during the execution of our algorithm, x is guaranteed to be confined within some rectangular region of \(a\), i.e.,
<br />
<span
      class="fbox"
      style="display:inline-block ; border:1pt solid #000000; padding:3pt ; color:#000000"
>\(\mathbf {0 \leq i \leq p \leq m-1}\)</span> &amp;&amp;<br />
<span
      class="fbox"
      style="display:inline-block ; border:1pt solid #000000; padding:3pt ; color:#000000"
>\(\mathbf {0 \leq q \leq j \leq n-1}\)</span> &amp;&amp;<br />
<span
      class="fbox"
      style="display:inline-block ; border:1pt solid #000000; padding:3pt ; color:#000000"
>\(\mathbf {x \in a[i..p, q..j]}\)</span>.<br />
In simple words, the invariant implies that
</p>
<ul style="list-style-type:none">


<li>
<p>
• We have exhausted the rows a[0..p-1] and x is not present in these already searched rows.
</p>


</li>
<li>


<p>
• We have exhausted the columns a[0..q-1] and x is not present in these already searched columns.
</p>
</li>
</ul>
<div class="center">

<p>
<span
      id="lateximage-index-36"
      class="lateximagesource"
><!--
 0       q j   n−1

ix not found
p



m−1
--><img
   src="index-images/image-36.svg"
   alt="(-tikz-&nbsp;diagram)"
   style=""
   class="lateximage"
></span>
</p>
</div>
<!--................................-->
<h5 id="autosec-296">Contract the rectangular region</h5>
<a id="index-autopage-296"></a>



<p>
We have to choose a rectangular region \(a[i..p, q..j]\) that contains x followed by making this region smaller till x is found.
</p>
<!--................................-->



<p>
<span class="paragraph" id="autosec-297">Initial bounded searcheable region</span>
<a id="index-autopage-297"></a>
is represented by :<br />
\(i = 0\)<span style="width:3.41432pt; display:inline-block"><!----></span> \(p = m - 1\)<span style="width:3.41432pt; display:inline-block"><!----></span> \(q =
0\)<span style="width:3.41432pt; display:inline-block"><!----></span> \(j=n - 1\)<br />
Looking at bounds of the rectangle, there are 4 ways to march towards contracting it:
</p>

<ul style="list-style-type:none">


<li>
<p>
• if \(a[i, j] &lt; x\) then since the row is ordered \(\implies \) \(i \leftarrow i + 1\), because if \(a[i, j] &gt; x\), then all the entries of that row is also greater than x. Please note that
its execution will maintain the stated invariant if \(x\) is not found in a[i, 0..n-1], i.e., in \(i^{th}\) row.
</p>


</li>
<li>


<p>
• if \(a[p, q] &gt; x\) \(\implies \) \(p \leftarrow p - 1\)
</p>


</li>
<li>


<p>
• if \(a[p, q] &lt; x\) \(\implies \) \(q \leftarrow q + 1\)
</p>


</li>
<li>


<p>
• if \(a[i, j] &gt; x\) \(\implies \) \(j \leftarrow j - 1\)
</p>
</li>
</ul>

<p>
These conditions are also known as <i>guards</i>[?].
</p>
<!--................................-->
<h5 id="autosec-298">Saddleback Search Algorithm</h5>
<a id="index-autopage-298"></a>



<p>
Let us put together the complete solution as shown below:
</p>

<figure id="autoid-27" class="figure ">
<div class="center">

<p>
<span
      class="fbox"
      style="display:inline-block ; border:1pt solid #000000; padding:3pt ; color:#000000"
><b><span
      class="textcolor"
      style="color:#808000"
>Saddleback Search Algorithm</span></b></span>
</p>
</div>
<ul style="list-style-type:none">


<li>
<p>
1: <span style="width:0pt; display:inline-block;"></span><b>PreCondition</b> : \(x \in a[0..m-1, 0..n-1]\)
</p>


</li>
<li>


<p>
2: <span style="width:0pt; display:inline-block;"></span><b>PostCondition</b> : \(0 \leq i \leq m-1\) &amp;&amp; \(0 \leq j \leq n-1\) &amp;&amp; \(x = a[i, j]\)
</p>


</li>
<li>


<p>
3: <span style="width:0pt; display:inline-block;"></span><b>function</b> <span class="textsc">Saddleback-search</span>(a[0..m-1, 0..n-1], x)
</p>


</li>
<li>


<p>
4:     <span style="width:15pt; display:inline-block;"></span>\(i \gets 0\)
</p>


</li>
<li>


<p>
5:     <span style="width:15pt; display:inline-block;"></span>\(p \gets m - 1\)
</p>


</li>
<li>


<p>
6:     <span style="width:15pt; display:inline-block;"></span>\(q \gets 0\)
</p>


</li>
<li>


<p>
7:     <span style="width:15pt; display:inline-block;"></span>\(j \gets n - 1\)
</p>


</li>
<li>


<p>
8:     <span style="width:15pt; display:inline-block;"></span><b>Invariant</b> : \(0 \leq i \leq p \leq m-1\) &amp;&amp; \(0 \leq q \leq j \leq n-1\) &amp;&amp; \(x \in
a[i..p, q..j]\)
</p>


</li>
<li>


<p>
9:     <span style="width:15pt; display:inline-block;"></span><b>while</b> \(x \neq a[i, j]\) <b>do</b>
</p>


</li>
<li>


<p>
10:       <span style="width:30pt; display:inline-block;"></span><b>if</b> a[i, j] < x <b>then</b>
</p>


</li>
<li>


<p>
11:          <span style="width:45pt; display:inline-block;"></span>\(i \longleftarrow i + 1\)
</p>


</li>
<li>


<p>
12:       <span style="width:30pt; display:inline-block;"></span><b>end</b> <b>if</b>
</p>


</li>
<li>


<p>
13:       <span style="width:30pt; display:inline-block;"></span><b>if</b> a[p, q] > x <b>then</b>
</p>


</li>
<li>


<p>
14:          <span style="width:45pt; display:inline-block;"></span>\(p \longleftarrow p - 1\)
</p>


</li>
<li>


<p>
15:       <span style="width:30pt; display:inline-block;"></span><b>end</b> <b>if</b>
</p>


</li>
<li>


<p>
16:       <span style="width:30pt; display:inline-block;"></span><b>if</b> a[p, q] < x <b>then</b>
</p>


</li>
<li>


<p>
17:          <span style="width:45pt; display:inline-block;"></span>\(q \longleftarrow q + 1\)
</p>


</li>
<li>


<p>
18:       <span style="width:30pt; display:inline-block;"></span><b>end</b> <b>if</b>
</p>


</li>
<li>


<p>
19:       <span style="width:30pt; display:inline-block;"></span><b>if</b> a[i, j] > x <b>then</b>
</p>


</li>
<li>


<p>
20:          <span style="width:45pt; display:inline-block;"></span>\(j \longleftarrow j - 1\)
</p>


</li>
<li>


<p>
21:       <span style="width:30pt; display:inline-block;"></span><b>end</b> <b>if</b>
</p>


</li>
<li>


<p>
22:     <span style="width:15pt; display:inline-block;"></span><b>end</b> <b>while</b>
</p>


</li>
<li>


<p>
23: <span style="width:0pt; display:inline-block;"></span><b>end</b> <b>function</b>
</p>
</li>
</ul>

</figure>

<p>
This layout was simple enough to embark on the journey of solving problems using formal programming methodology in somewhat pragmatic manner.<br />
With the above setting in place, now it is time to think towards proving correctness of the result upon termination. As an astute reader, it is not that difficult to surmise that intermediate conditions in
form of the points p,q of search space are not really needed to test veracity of the result upon termination. Only the first and last conditions are necessary and sufficient enough to prove it. So let us
drop the middle (two) conditions to complete the working program in practice as following:
</p>

<figure id="autoid-28" class="figure ">
<div class="center">

<p>
<span
      class="fbox"
      style="display:inline-block ; border:1pt solid #000000; padding:3pt ; color:#000000"
><b><span
      class="textcolor"
      style="color:#808000"
>Saddleback Search Algorithm in practice</span></b></span>
</p>
</div>
<ul style="list-style-type:none">


<li>
<p>
1: <span style="width:0pt; display:inline-block;"></span><b>PreCondition</b> : \(x \in a[0..m-1, 0..n-1]\)
</p>


</li>
<li>


<p>
2: <span style="width:0pt; display:inline-block;"></span><b>PostCondition</b> : \(0 \leq i \leq m-1\) &amp;&amp; \(0 \leq j \leq n-1\) &amp;&amp; \(x = a[i, j]\)
</p>


</li>
<li>


<p>
3: <span style="width:0pt; display:inline-block;"></span><b>Invariant</b> : x is in a[i..m-1, 0..j]
</p>


</li>
<li>


<p>
4: <span style="width:0pt; display:inline-block;"></span><b>function</b> <span class="textsc">Saddleback-search</span>(a[0..m-1, 0..n-1], x)
</p>


</li>
<li>


<p>
5:     <span style="width:15pt; display:inline-block;"></span><b>while</b> \(x \neq a[i, j]\) <b>do</b>
</p>


</li>
<li>


<p>
6:       <span style="width:30pt; display:inline-block;"></span><b>if</b> a[i, j] < x <b>then</b>
</p>


</li>
<li>


<p>
7:          <span style="width:45pt; display:inline-block;"></span>\(i \gets i + 1\)
</p>


</li>
<li>


<p>
8:       <span style="width:30pt; display:inline-block;"></span><b>else</b>\(j \gets j - 1\)
</p>


</li>
<li>


<p>
9:       <span style="width:30pt; display:inline-block;"></span><b>end</b> <b>if</b>
</p>


</li>
<li>


<p>
10:     <span style="width:15pt; display:inline-block;"></span><b>end</b> <b>while</b>
</p>


</li>
<li>


<p>
11: <span style="width:0pt; display:inline-block;"></span><b>end</b> <b>function</b>
</p>
</li>
</ul>

</figure>

<p>
Still, we need to address that why we chose to start from top rightmost corner. We can of course start from bottom leftmost corner as well. We leave this an exercise to the reader to work out and
think about the pros n cons of choosing the starting point.
</p>
<!--................................-->
<h6 id="autosec-301">C++11 Implementation</h6>
<a id="index-autopage-301"></a>



<p>
Let us try programming this algorithm in a real language, say C++11 to bring ourselves at workplace-setting environment:
</p>
<a id="autoid-29" ></a >



<div class="figurecaption">

<p>
Listing&nbsp;31.1:&nbsp;Saddleback search in C++11
</p>
</div>
<pre class="programlisting">
1 #include &lt;algorithm&gt;
2 #include &lt;array&gt;
3
4 using Point = std::pair&lt;int, int&gt;;
5
6 template &lt;int m, int n&gt;
7 using TwoDimArray
8    = std::array&lt;std::array&lt;int, n&gt;, m&gt;;
9
10 template &lt;int m, int n&gt;
11 Point saddleback_search(TwoDimArray&lt;m, n&gt; &amp; a,
12                              int x)
13 {
14     Point p(−1, −1);
15
16     int i = 0, j = n − 1;
17
18     while(x != a[i][ j ])
19     {
20          if (a[i ][ j ] &lt; x) i += 1;
21          else j −= 1;
22     }
23
24     p. first = i;
25     p.second = j;
26
27     return p;
28 }
</pre>
<a id="autoid-30" ></a >



<div class="figurecaption">

<p>
Listing&nbsp;31.2:&nbsp;Using Saddleback Search
</p>
</div>
<pre class="programlisting">
1 #include ”saddleback_search.hpp”
2 #include &lt;iostream&gt;
3
4 int main()
5{
6     TwoDimArray&lt;4, 4&gt; a = {
7                                2, 2, 3, 5,
8                                3, 4, 5, 6,
9                                3, 5, 6, 8,
10                                3, 6, 7, 9
11                            };
12
13     Point p = saddleback_search&lt;4, 4&gt;(a, 6);
14
15     std::cout &lt;&lt; ”6 is found at : a[”
16               &lt;&lt; p. first &lt;&lt; ” ][ ”
17               &lt;&lt; p.second &lt;&lt; ”]”
18               &lt;&lt; std::endl;
19
20 }
</pre>

<p>
Output of the program is:
</p>
<pre class="boxedverbatim">
6 is found at : a[1][3]
</pre>
<!--................................-->
<h6 id="autosec-305">Time Complexity</h6>
<a id="index-autopage-305"></a>



<p>
As could be seen that the number of comparisons required in Saddleback search algorithm is at most \(n + m\). Hence time complexity is \(O(n + m)\).<br />
How to improve it further, is it possible?<br />
Let us take a simple case as a tryst to understand it better. Let us assume that the array is a square one with n x n dimension, i.e., m = n. Please note that the elements lying off-diagonal in the
rectangular region form an unordered sequence of integers, i.e., a[0, n-1], a[1, n-2], a[2, n-3], \(\ldots \), a[n-2, 1] and a[n-1, 0] form an unordered list because this particular sequence is not
affected at all by the imposed ordering on row and column respectively. So even if we assume that \(x\) could be lying on this off-diagonal set, then at least \(n\) comparisons are required in the worst
case.<br />
Have we done our bit fully ? Not yet. We request our reader to think about it and be patient for now, thoughts on possible improvement will be taken up soon, whether it is feasible to improve it
further or not will reveal itself in due course of time. But for now, we think about a simple variation in the problem statement and try solving it with help of approach discussed so far.
</p>
<!--................................-->
<h5 id="autosec-306">Variation</h5>
<a id="index-autopage-306"></a>



<p>
As mentioned in the problem statement, it was desired to find any one in case of multiple occurrence of the value sought after. How about finding all of these instead ? This problem is one of the
variations of <em>saddleback search</em>(discussed in the previous section). Here instead of locating an occurrence, it counts the number of occurrences.
</p>
<!--................................-->
<h6 id="autosec-307">Find First Occurrence</h6>
<a id="index-autopage-307"></a>



<p>
Before we march ahead towards a solution, we need to work on a strategy to spot the very first occurrence of \(x\), because the earlier approach was focused to find any occurrence in case of multiple
ones. So if we try to build our logic on the earlier approach, we may miss few occurrences.<br />
Therefore, we have to be a little more judicious in starting point which cannot simply be set to either rightmost top corner or leftmost bottom corner.<br />
To understand it better, let us stick to our earlier solution for now as illustrated ahead and take it from there towards an appropriate solution.<br />
We have to design an efficient algorithm to search for a given integer x in a 2-dimensional <b>sorted</b> array a[0..m][0..n]. Please note that it is sorted row-wise and column-wise in ascending
order. In case of multiple occurrences, please find the very first occurrence, i.e, the occurrence with the smallest value of the row index and at the same time the occurrence with the smallest value of
the column index as well. Please note that row index and column index at topmost left corner is being treated as (0, 0).
</p>

<ul style="list-style-type:none">


<li>
<p>
1. Find any occurrence using original saddleback search algorithm which finds the entry corresponding to smallest row index and highest column index, i.e., it finds the very first row containing that
value but the column index depict the last most occurrence in that particular row.
</p>


</li>
<li>


<p>
2. Search backwards to adjust the column index to point to lowest index corresponding to that entry in that row.
</p>
</li>
</ul>

<figure id="autoid-31" class="figure ">
<div class="center">

<p>
<span
      class="fbox"
      style="display:inline-block ; border:1pt solid #000000; padding:3pt ; color:#000000"
><b><span
      class="textcolor"
      style="color:#808000"
>Saddleback Search Algorithm : Find First Occurrence</span></b></span>
</p>
</div>
<ul style="list-style-type:none">


<li>
<p>
1: <span style="width:0pt; display:inline-block;"></span><b>function</b> <span class="textsc">Saddleback-search</span>(a[0..m-1, 0..n-1], x)
</p>


</li>
<li>


<p>
2:     <span style="width:15pt; display:inline-block;"></span>\(i \gets 0\)
</p>


</li>
<li>


<p>
3:     <span style="width:15pt; display:inline-block;"></span>\(j \gets n - 1\)
</p>


</li>
<li>


<p>
4:     <span style="width:15pt; display:inline-block;"></span><b>while</b> \(x \neq a[i, j]\) <b>do</b>
</p>


</li>
<li>


<p>
5:       <span style="width:30pt; display:inline-block;"></span><b>if</b> a[i, j] < x <b>then</b>
</p>


</li>
<li>


<p>
6:          <span style="width:45pt; display:inline-block;"></span>\(i \gets i + 1\)
</p>


</li>
<li>


<p>
7:       <span style="width:30pt; display:inline-block;"></span><b>else</b> <b>if</b> a[i, j] > x <b>then</b>f
</p>


</li>
<li>


<p>
8:          <span style="width:45pt; display:inline-block;"></span>\(j \gets j - 1\)
</p>


</li>
<li>


<p>
9:       <span style="width:30pt; display:inline-block;"></span><b>end</b> <b>if</b>
</p>


</li>
<li>


<p>
10:     <span style="width:15pt; display:inline-block;"></span><b>end</b> <b>while</b>
</p>


</li>
<li>


<p>
11:     <span style="width:15pt; display:inline-block;"></span><b>while</b> \(x == a[i, j]\) <b>do</b>
</p>


</li>
<li>


<p>
12:       <span style="width:30pt; display:inline-block;"></span>\(j \gets j - 1\)
</p>


</li>
<li>


<p>
13:     <span style="width:15pt; display:inline-block;"></span><b>end</b> <b>while</b>
</p>


</li>
<li>


<p>
14:     <span style="width:15pt; display:inline-block;"></span>\(j \gets j + 1\)
</p>


</li>
<li>


<p>
15: <span style="width:0pt; display:inline-block;"></span><b>end</b> <b>function</b>
</p>
</li>
</ul>

</figure>
<a id="autoid-32" ></a >



<div class="figurecaption">

<p>
Listing&nbsp;31.3:&nbsp;Saddleback Search : First Occurrence
</p>
</div>
<pre class="programlisting">
1 #include &lt;algorithm&gt;
2 #include &lt;array&gt;
3
4 using Point = std::pair&lt;int, int&gt;;
5
6 template &lt;int m, int n&gt;
7 using TwoDimArray
8    = std::array&lt;std::array&lt;int, n&gt;, m&gt;;
9
10 template &lt;int m, int n&gt;
11 Point saddleback_search_first(TwoDimArray&lt;m, n&gt;
12                                   &amp; a, int x)
13 {
14     Point p(−1, −1);
15
16     int i = 0, j = n − 1;
17
18     while(x != a[i][ j ])
19     {
20          if (a[i ][ j ] &lt; x) ++i;
21          else −−j;
22     }
23
24     while(x == a[i][j]) −−j;
25
26     ++j;
27
28     p. first = i;
29     p.second = j;
30
31     return p;
32 }
</pre>
<a id="autoid-33" ></a >



<div class="figurecaption">

<p>
Listing&nbsp;31.4:&nbsp;Using Saddleback Search : First Occurrence
</p>
</div>
<pre class="programlisting">
1 #include ”saddleback_search_first.hpp”
2 #include &lt;iostream&gt;
3
4 int main()
5{
6     TwoDimArray&lt;4, 4&gt; a = {
7                               2, 2, 3, 5,
8                               3, 4, 6, 6,
9                               3, 5, 6, 6,
10                               3, 6, 6, 9
11                           };
12
13     Point p
14         = saddleback_search_first&lt;4, 4&gt;(a, 6);
15
16     std::cout &lt;&lt; ”6 is found at : a[”
17              &lt;&lt; p. first &lt;&lt; ” ][ ”
18              &lt;&lt; p.second &lt;&lt; ”]”
19              &lt;&lt; std::endl;
20
21 }
</pre>

<p>
It prints:
</p>
<pre class="boxedverbatim">
6 is found at : a[1][2]
</pre>

<p>
First part of this algorithm uses original saddleback search whose complexity is \(O(n + m)\). Second part involves linear search in backward dimension in the given row \(\implies \) \(O(n)\).
Hence time complexity of <i>Saddleback Search : Find First Occurrence</i> is \(O(n + m)\). Please note that second part of this algorithm can be accomplished using binary search. We leave this
an exercise to the reader.
</p>
<!--................................-->
<h6 id="autosec-312">Find All Occurrences</h6>
<a id="index-autopage-312"></a>



<p>
Before we undertake solving the problem of finding the count of \(x\), let us turn our attention to a related twister which requires reporting of all the occurrences of a given integer x in the array a[m,
n], i.e., it will report all the row-indices (\(i\)) and column-indices (\(j\)) of the array where \(x == a[i, j]\).<br />
So far our termination condition was derived upon the first occurrence of \(x\) in the array, but now we need to modify to proceed further till array is completely exhausted and maintain a list of
vertices found relevant so far.<br />


</p>

<figure id="autoid-34" class="figure ">
<div class="center">

<p>
<span
      class="fbox"
      style="display:inline-block ; border:1pt solid #000000; padding:3pt ; color:#000000"
><b><span
      class="textcolor"
      style="color:#808000"
>Saddleback Search Algorithm : Find All Occurrences</span></b></span>
</p>
</div>
<ul style="list-style-type:none">


<li>
<p>
1: <span style="width:0pt; display:inline-block;"></span><b>function</b> <span class="textsc">Saddleback-findall</span>(a[0..m-1, 0..n-1], x)
</p>


</li>
<li>


<p>
2:     <span style="width:15pt; display:inline-block;"></span>\(i \gets 0\)
</p>


</li>
<li>


<p>
3:     <span style="width:15pt; display:inline-block;"></span>\(j \gets n - 1\)
</p>


</li>
<li>


<p>
4:     <span style="width:15pt; display:inline-block;"></span>\(currrent\_col\_index \gets j\)
</p>


</li>
<li>


<p>
5:     <span style="width:15pt; display:inline-block;"></span>\(List&lt;Pair&lt;rowindex, columnindex&gt; &gt; list\_indices\)
</p>


</li>
<li>


<p>
6:     <span style="width:15pt; display:inline-block;"></span><b>while</b> \(j \leq n - 1\) <b>do</b>
</p>


</li>
<li>


<p>
7:       <span style="width:30pt; display:inline-block;"></span><b>if</b> a[i, j] < x <b>then</b>
</p>


</li>
<li>


<p>
8:          <span style="width:45pt; display:inline-block;"></span>\(i \gets i + 1\)
</p>


</li>
<li>


<p>
9:       <span style="width:30pt; display:inline-block;"></span><b>else</b> <b>if</b> a[i, j] > x <b>then</b>
</p>


</li>
<li>


<p>
10:          <span style="width:45pt; display:inline-block;"></span>\(j \gets j - 1\)
</p>


</li>
<li>


<p>
11:       <span style="width:30pt; display:inline-block;"></span><b>else</b> <b>if</b> a[i, j] == x <b>then</b>
</p>


</li>
<li>


<p>
12:          <span style="width:45pt; display:inline-block;"></span>\(currrent\_col\_index \gets j\)
</p>


</li>
<li>


<p>
13:          <span style="width:45pt; display:inline-block;"></span><b>while</b> currrent_col_index \(\geq \) 0 <b>and</b> a[i][currrent_col_index] == x <b>do</b>
</p>


</li>
<li>


<p>
14:             <span style="width:60pt; display:inline-block;"></span>list_indices.insert(Pair<rowindex, columnindex>(i, currrent_col_index))
</p>


</li>
<li>


<p>
15:             <span style="width:60pt; display:inline-block;"></span>\(currrent\_col\_index \gets currrent\_col\_index\ - 1\)
</p>


</li>
<li>


<p>
16:          <span style="width:45pt; display:inline-block;"></span><b>end</b> <b>while</b>
</p>


</li>
<li>


<p>
17:          <span style="width:45pt; display:inline-block;"></span>\(i \gets i + 1\)
</p>


</li>
<li>


<p>
18:       <span style="width:30pt; display:inline-block;"></span><b>end</b> <b>if</b>
</p>


</li>
<li>


<p>
19:     <span style="width:15pt; display:inline-block;"></span><b>end</b> <b>while</b>
</p>


</li>
<li>


<p>
20: <span style="width:0pt; display:inline-block;"></span><b>end</b> <b>function</b>
</p>
</li>
</ul>

</figure>

<p>
Key thing to notice here is how to start the next search after first occurrence is reported, say a[i, j] ?<br />
If \(x\) is equal to a[i, j] for a given row index \(i\) and column index \(j\), then it is obvious that these correspond to smallest values of row and column indices. Our algorithm developed for finding
the first occurrence ends up traversing the path from the last most to first most in a given row, so all we need to do is to record this path and march towards the next row.
</p>
<a id="autoid-35" ></a >



<div class="figurecaption">

<p>
Listing&nbsp;31.5:&nbsp;Saddleback Find All
</p>
</div>
<pre class="programlisting">
1 #include &lt;algorithm&gt;
2 #include &lt;array&gt;
3 #include &lt;vector&gt;
4
5 template &lt;int m, int n&gt;
6 using TwoDimArray
7     = std::array&lt;std::array&lt;int, n&gt;, m&gt;;
8
9 typedef std::pair&lt;int, int&gt; PairIndices;
10
11 typedef std::vector&lt;PairIndices&gt; ListIndices;
12
13 template &lt;int m, int n&gt;
14 ListIndices saddleback_findall(
15                    TwoDimArray&lt;m, n&gt; &amp; a, int x)
16 {
17     size_t i = 0, j = n − 1;
18     ListIndices list_indices ;
19     int currrent_col_index = j;
20
21     while(j &lt;= n − 1)
22     {
23         if (a[i ][ j ] &lt; x) i += 1;
24         else if (a[i ][ j ] &gt; x) j −= 1;
25         else // a[i ][ j ] == x
26         {
27              currrent_col_index = j;
28              while(currrent_col_index &gt;=0 &amp;&amp;
29                       a[i ][ currrent_col_index] == x)
30              list_indices .push_back(
31            PairIndices(i , currrent_col_index−−));
32
33              ++i;
34         }
35     }
36
37     return list_indices;
38 }
</pre>
<a id="autoid-36" ></a >



<div class="figurecaption">

<p>
Listing&nbsp;31.6:&nbsp;Using Saddleback Find All
</p>
</div>
<pre class="programlisting">
1 #include ”saddleback_findall.hpp”
2 #include &lt;iostream&gt;
3
4 int main()
5{
6     TwoDimArray&lt;4, 4&gt; a = {
7                               2, 2, 3, 5,
8                               3, 4, 5, 6,
9                               3, 5, 6, 8,
10                               3, 6, 7, 9
11                           };
12
13     ListIndices indexList
14         = saddleback_findall&lt;4, 4&gt;(a, 6);
15
16     std::cout &lt;&lt; ”6 is found at : \n”;
17     for(PairIndices &amp; p : indexList)
18     std::cout &lt;&lt; ”a[” &lt;&lt; p. first &lt;&lt; ”]”
19               &lt;&lt; ”[” &lt;&lt; p.second &lt;&lt; ”]”
20               &lt;&lt; std::endl;
21 }
</pre>

<p>
It prints :
</p>
<pre class="boxedverbatim">
6 is found at :
a[1][3]
a[2][2]
a[3][1]
</pre>
<a id="autoid-37" ></a >



<div class="figurecaption">

<p>
Listing&nbsp;31.7:&nbsp;Another Usage of Saddleback Find All
</p>
</div>
<pre class="programlisting">
1 #include ”saddleback_findall.hpp”
2 #include &lt;iostream&gt;
3
4 int main()
5{
6     TwoDimArray&lt;4, 4&gt; a = {
7                               2, 2, 3, 5,
8                               3, 4, 6, 6,
9                               3, 5, 6, 6,
10                               3, 6, 6, 9
11                           };
12
13     ListIndices indexList
14         = saddleback_findall&lt;4, 4&gt;(a, 6);
15
16     std::cout &lt;&lt; ”6 is found at : \n”;
17     for(PairIndices &amp; p : indexList)
18     std::cout &lt;&lt; ”a[” &lt;&lt; p. first &lt;&lt; ”]”
19               &lt;&lt; ”[” &lt;&lt; p.second &lt;&lt; ”]”
20               &lt;&lt; std::endl;
21 }
</pre>

<p>
It prints :
</p>
<pre class="boxedverbatim">
6 is found at :
a[1][3]
a[1][2]
a[2][3]
a[2][2]
a[3][2]
a[3][1]
</pre>
<a id="autoid-38" ></a >



<div class="figurecaption">

<p>
Listing&nbsp;31.8:&nbsp;Continue Using Saddleback Find All
</p>
</div>
<pre class="programlisting">
1 #include ”saddleback_findall.hpp”
2 #include &lt;iostream&gt;
3
4 int main()
5{
6     TwoDimArray&lt;4, 4&gt; a = {
7                               6, 6, 6, 6,
8                               6, 6, 6, 6,
9                               6, 6, 6, 6,
10                               6, 6, 6, 6
11                           };
12
13     ListIndices indexList
14         = saddleback_findall&lt;4, 4&gt;(a, 6);
15
16     std::cout &lt;&lt; ”6 is found at : \n”;
17     for(PairIndices &amp; p : indexList)
18     std::cout &lt;&lt; ”a[” &lt;&lt; p. first &lt;&lt; ”]”
19               &lt;&lt; ”[” &lt;&lt; p.second &lt;&lt; ”]”
20               &lt;&lt; std::endl;
21 }
</pre>

<p>
It prints :
</p>
<pre class="boxedverbatim">
6 is found at :
a[0][3]
a[0][2]
a[0][1]
a[0][0]
a[1][3]
a[1][2]
a[1][1]
a[1][0]
a[2][3]
a[2][2]
a[2][1]
a[2][0]
a[3][3]
a[3][2]
a[3][1]
a[3][0]
</pre>

<p>
<b>Time Complexity</b> is \(O(mn)\).
</p>
<!--................................-->
<h6 id="autosec-321">Saddleback Count</h6>
<a id="index-autopage-321"></a>



<p>
Now our task becomes easier to work out original problem posed earlier, i.e., finding the count of a given integer \(x\) in the array \(a\).
</p>

<figure id="autoid-39" class="figure ">
<div class="center">

<p>
<span
      class="fbox"
      style="display:inline-block ; border:1pt solid #000000; padding:3pt ; color:#000000"
><b><span
      class="textcolor"
      style="color:#808000"
>Saddleback Count Algorithm : Initial Approach</span></b></span>
</p>
</div>
<ul style="list-style-type:none">


<li>
<p>
1: <span style="width:0pt; display:inline-block;"></span><b>function</b> <span class="textsc">Saddleback-count</span>(a[0..m-1, 0..n-1], x)
</p>


</li>
<li>


<p>
2:     <span style="width:15pt; display:inline-block;"></span>\(i \gets 0\)
</p>


</li>
<li>


<p>
3:     <span style="width:15pt; display:inline-block;"></span>\(j \gets n - 1\)
</p>


</li>
<li>


<p>
4:     <span style="width:15pt; display:inline-block;"></span>\(count \gets 0\)
</p>


</li>
<li>


<p>
5:     <span style="width:15pt; display:inline-block;"></span><b>while</b> \(j \leq n - 1\) <b>do</b>
</p>


</li>
<li>


<p>
6:       <span style="width:30pt; display:inline-block;"></span><b>if</b> a[i, j] < x <b>then</b>
</p>


</li>
<li>


<p>
7:          <span style="width:45pt; display:inline-block;"></span>\(i \gets i + 1\)
</p>


</li>
<li>


<p>
8:       <span style="width:30pt; display:inline-block;"></span><b>else</b> <b>if</b> a[i, j] > x <b>then</b>
</p>


</li>
<li>


<p>
9:          <span style="width:45pt; display:inline-block;"></span>\(j \gets j - 1\)
</p>


</li>
<li>


<p>
10:       <span style="width:30pt; display:inline-block;"></span><b>else</b> <b>if</b> a[i, j] == x <b>then</b>
</p>


</li>
<li>


<p>
11:          <span style="width:45pt; display:inline-block;"></span>\(i \gets i + 1\)
</p>


</li>
<li>


<p>
12:          <span style="width:45pt; display:inline-block;"></span>\(j \gets j - 1\)
</p>


</li>
<li>


<p>
13:          <span style="width:45pt; display:inline-block;"></span>\(count \gets count + 1\)
</p>


</li>
<li>


<p>
14:       <span style="width:30pt; display:inline-block;"></span><b>end</b> <b>if</b>
</p>


</li>
<li>


<p>
15:     <span style="width:15pt; display:inline-block;"></span><b>end</b> <b>while</b>
</p>


</li>
<li>


<p>
16: <span style="width:0pt; display:inline-block;"></span><b>end</b> <b>function</b>
</p>
</li>
</ul>

</figure>
<!--................................-->



<p>
<span class="paragraph" id="autosec-323">C++11 Implementation</span>
<a id="index-autopage-323"></a>


</p>
<a id="autoid-40" ></a >



<div class="figurecaption">

<p>
Listing&nbsp;31.9:&nbsp;Saddleback Count : Initial Approach
</p>
</div>
<pre class="programlisting">
1 #include &lt;algorithm&gt;
2 #include &lt;array&gt;
3
4 template &lt;int m, int n&gt;
5 using TwoDimArray
6     = std::array&lt;std::array&lt;int, n&gt;, m&gt;;
7
8 template &lt;int m, int n&gt;
9 size_t saddleback_count(
10     TwoDimArray&lt;m, n&gt; &amp; a, int x)
11 {
12     size_t i = 0, j = n − 1, count = 0;
13
14     while(j &lt;= n − 1)
15     {
16         if (a[i ][ j ] &lt; x) i += 1;
17         else if (a[i ][ j ] &gt; x) j −= 1;
18         else // a[i ][ j ] == x
19         {
20              count += 1;
21              i += 1;
22              j −= 1;
23         }
24     }
25
26     return count;
27 }
</pre>
<a id="autoid-41" ></a >



<div class="figurecaption">

<p>
Listing&nbsp;31.10:&nbsp;Using Saddleback Count
</p>
</div>
<pre class="programlisting">
1 #include ”saddleback_count.hpp”
2 #include &lt;iostream&gt;
3
4 int main()
5{
6     TwoDimArray&lt;4, 4&gt; a = {
7                               2, 2, 3, 5,
8                               3, 4, 5, 6,
9                               3, 5, 6, 8,
10                               3, 6, 7, 9
11                           };
12
13     size_t count
14         = saddleback_count&lt;4, 4&gt;(a, 6);
15
16     std::cout &lt;&lt; ”Count of 6 is : ”
17               &lt;&lt; count &lt;&lt; std::endl;
18 }
</pre>

<p>
It prints : Count of 6 is: 3 which is fine so far.<br />
Let us take another example:
</p>
<a id="autoid-42" ></a >



<div class="figurecaption">

<p>
Listing&nbsp;31.11:&nbsp;Using Saddleback Count : Count of 6 should be 6
</p>
</div>
<pre class="programlisting">
1 #include ”saddleback_count.hpp”
2 #include &lt;iostream&gt;
3
4 int main()
5{
6     TwoDimArray&lt;4, 4&gt; a = {
7                               2, 2, 3, 5,
8                               3, 4, 6, 6,
9                               3, 5, 6, 6,
10                               3, 6, 6, 9
11                           };
12
13     size_t count
14         = saddleback_count&lt;4, 4&gt;(a, 6);
15
16     std::cout &lt;&lt; ”Count of 6 is : ”
17               &lt;&lt; count &lt;&lt; std::endl;
18 }
</pre>

<p>
This too prints : Count of 6 is: 3 which is wrong because it should print : Count of 6 is: 6.<br />
As an astute reader, you can figure out that ordering of rows and columns plays a key role here. Saddleback search has to locate such an occurrence, more precisely, the occurrence with the smallest
value of the row index and at the same time the occurrence with the smallest value of the column index as well. Please note that the earlier logic relied on locating the occurrence with the smallest
value of the row index and at the same time the occurrence with the largest value of the column index. So let us use the insight gained in the solution of finding first occurrence followed by finding all
the occurrences of saddleback search with necessary modifications.
</p>

<figure id="autoid-43" class="figure ">
<div class="center">

<p>
<span
      class="fbox"
      style="display:inline-block ; border:1pt solid #000000; padding:3pt ; color:#000000"
><b><span
      class="textcolor"
      style="color:#808000"
>Saddleback Count : Correct Algorithm</span></b></span>
</p>
</div>
<ul style="list-style-type:none">


<li>
<p>
1: <span style="width:0pt; display:inline-block;"></span><b>function</b> <span class="textsc">Saddleback-count</span>(a[0..m-1, 0..n-1], x)
</p>


</li>
<li>


<p>
2:     <span style="width:15pt; display:inline-block;"></span>\(i \gets 0\)
</p>


</li>
<li>


<p>
3:     <span style="width:15pt; display:inline-block;"></span>\(j \gets n - 1\)
</p>


</li>
<li>


<p>
4:     <span style="width:15pt; display:inline-block;"></span>\(currrent\_col\_index \gets j\)
</p>


</li>
<li>


<p>
5:     <span style="width:15pt; display:inline-block;"></span>\(count \gets 0\)
</p>


</li>
<li>


<p>
6:     <span style="width:15pt; display:inline-block;"></span><b>while</b> \(j \leq n - 1\) <b>do</b>
</p>


</li>
<li>


<p>
7:       <span style="width:30pt; display:inline-block;"></span><b>if</b> a[i, j] < x <b>then</b>
</p>


</li>
<li>


<p>
8:          <span style="width:45pt; display:inline-block;"></span>\(i \gets i + 1\)
</p>


</li>
<li>


<p>
9:       <span style="width:30pt; display:inline-block;"></span><b>else</b> <b>if</b> a[i, j] > x <b>then</b>
</p>


</li>
<li>


<p>
10:          <span style="width:45pt; display:inline-block;"></span>\(j \gets j - 1\)
</p>


</li>
<li>


<p>
11:       <span style="width:30pt; display:inline-block;"></span><b>else</b> <b>if</b> a[i, j] == x <b>then</b>
</p>


</li>
<li>


<p>
12:          <span style="width:45pt; display:inline-block;"></span>\(currrent\_col\_index \gets j\)
</p>


</li>
<li>


<p>
13:          <span style="width:45pt; display:inline-block;"></span><b>while</b> currrent_col_index \(\geq \) 0 <b>and</b> a[i][currrent_col_index] == x <b>do</b>
</p>


</li>
<li>


<p>
14:            <span style="width:60pt; display:inline-block;"></span>\(count \gets count + 1\)
</p>


</li>
<li>


<p>
15:            <span style="width:60pt; display:inline-block;"></span>\(currrent\_col\_index \gets currrent\_col\_index\ - 1\)
</p>


</li>
<li>


<p>
16:          <span style="width:45pt; display:inline-block;"></span><b>end</b> <b>while</b>
</p>


</li>
<li>


<p>
17:          <span style="width:45pt; display:inline-block;"></span>\(i \gets i + 1\)
</p>


</li>
<li>


<p>
18:       <span style="width:30pt; display:inline-block;"></span><b>end</b> <b>if</b>
</p>


</li>
<li>


<p>
19:     <span style="width:15pt; display:inline-block;"></span><b>end</b> <b>while</b>
</p>


</li>
<li>


<p>
20:     <span style="width:15pt; display:inline-block;"></span><b>return</b> count
</p>


</li>
<li>


<p>
21: <span style="width:0pt; display:inline-block;"></span><b>end</b> <b>function</b>
</p>
</li>
</ul>

</figure>
<a id="autoid-44" ></a >



<div class="figurecaption">

<p>
Listing&nbsp;31.12:&nbsp;Implementing Saddleback Count
</p>
</div>
<pre class="programlisting">
1 #include &lt;algorithm&gt;
2 #include &lt;array&gt;
3
4 template &lt;int m, int n&gt;
5 using TwoDimArray
6     = std::array&lt;std::array&lt;int, n&gt;, m&gt;;
7
8 template &lt;int m, int n&gt;
9 size_t saddleback_count(
10     TwoDimArray&lt;m, n&gt; &amp; a, int x)
11 {
12     size_t i = 0, j = n − 1, count = 0;
13     int current_col_index = j;
14
15     while(j &lt;= n − 1)
16     {
17         if (a[i ][ j ] &lt; x) i += 1;
18         else if (a[i ][ j ] &gt; x) j −= 1;
19         else // a[i ][ j ] == x
20         {
21              current_col_index = j;
22              while(current_col_index &gt;=0 &amp;&amp;
23                a[i ][ current_col_index] == x)
24              {
25                    ++count;
26                    current_col_index−−;
27              }
28              ++i;
29         }
30     }
31
32     return count;
33 }
</pre>
<a id="autoid-45" ></a >



<div class="figurecaption">

<p>
Listing&nbsp;31.13:&nbsp;Using Saddleback Count
</p>
</div>
<pre class="programlisting">
1 #include ”saddleback_count_correct.hpp”
2 #include &lt;iostream&gt;
3
4 int main()
5{
6     TwoDimArray&lt;4, 4&gt; a = {
7                               2, 2, 3, 5,
8                               3, 4, 6, 6,
9                               3, 5, 6, 6,
10                               3, 6, 6, 9
11                           };
12
13     size_t count
14         = saddleback_count&lt;4, 4&gt;(a, 6);
15
16     std::cout &lt;&lt; ”Count of 6 is : ”
17               &lt;&lt; count &lt;&lt; std::endl;
18 }
</pre>

<p>
It prints :
</p>
<pre class="boxedverbatim">
Count of 6 is: 6
</pre>
<a id="autoid-46" ></a >



<div class="figurecaption">

<p>
Listing&nbsp;31.14:&nbsp;another Usage of Saddleback Count
</p>
</div>
<pre class="programlisting">
1 #include ”saddleback_count_correct.hpp”
2 #include &lt;iostream&gt;
3
4 int main()
5{
6     TwoDimArray&lt;4, 4&gt; a = {
7                               6, 6, 6, 6,
8                               6, 6, 6, 6,
9                               6, 6, 6, 6,
10                               6, 6, 6, 6
11                           };
12
13     size_t count
14         = saddleback_count&lt;4, 4&gt;(a, 6);
15
16     std::cout &lt;&lt; ”Count of 6 is : ”
17               &lt;&lt; count &lt;&lt; std::endl;
18 }
</pre>

<p>
It prints :
</p>
<pre class="boxedverbatim">
Count of 6 is: 16
</pre>

<p>
Time complexity is same as that of find all, i.e., \(O(mn)\).
</p>
<!--................................-->
<h5 id="autosec-333">Remarks</h5>
<a id="index-autopage-333"></a>



<p>
It is called <em>Saddleback Search</em> because the search space is confined by a region with the smallest element at the top-left, largest at bottom-right and two wings gives it a look like a saddle.
</p>

</section>

</main>

</div>

<footer>

<p>
<a href="Top-10-Coding-Interview-Problems-Asked-in-Google-with-Solutions.html" class="linkhome" >
Next</a>
</p>

</footer>



<nav class="botnavigation"><a href="index.html" class="linkhome" >
Home</a></nav>

</body>
</html>
