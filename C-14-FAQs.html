
<!DOCTYPE html>
<html lang="en-US">
<head>
<meta charset="UTF-8" />
<meta name="generator" content="LaTeX Lwarp package" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<!--[if lt IE 9]>
<script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
<![endif]-->
<title>Ancient Science Publishers — C++14 FAQs</title>
<link rel="stylesheet" type="text/css" href="lwarp_sagebrush.css" />

<script>
// Lwarp MathJax emulation code
//
// Based on code by Davide P. Cervone.
// Equation numbering: https://github.com/mathjax/MathJax/issues/2427
// Starred and ifnextchar macros: https://github.com/mathjax/MathJax/issues/2428
// \left, \right delimiters: https://github.com/mathjax/MathJax/issues/2535
//
// Modified by Brian Dunn to adjust equation numbering and add subequations.
//
// LaTeX can use \seteqnumber{subequations?}{section}{number} before each equation.
// subequations? is 0 usually, 1 if inside subequations.
// section is a string printed as-is, or empty.
// number is auto-incremented by MathJax between equations.
//
MathJax = {
   subequations: "0",
   section: "",
   loader: {
      load: ['[tex]/tagformat', '[tex]/textmacros'],
   },
   startup: {
      ready() {
        // These would be replaced by import commands if you wanted to make
        // a proper extension.
        const Configuration = MathJax._.input.tex.Configuration.Configuration;
        const CommandMap = MathJax._.input.tex.SymbolMap.CommandMap;
        const Macro = MathJax._.input.tex.Symbol.Macro;
        const TexError = MathJax._.input.tex.TexError.default;
        const ParseUtil = MathJax._.input.tex.ParseUtil.default;
        const expandable = MathJax._.util.Options.expandable;

           // Insert the replacement string into the TeX string, and check
           // that there haven't been too many maxro substitutions (prevents
           // infinite loops).
           const useArgument = (parser, text) => {
             parser.string = ParseUtil.addArgs(parser, text, parser.string.slice(parser.i));
             parser.i = 0;
             if (++parser.macroCount > parser.configuration.options.maxMacros) {
               throw new TexError('MaxMacroSub1',
               'MathJax maximum macro substitution count exceeded; ' +
               'is there a recursive macro call?');
             }
           }

           // Create the command map for:
           //      \ifstar, \ifnextchar, \ifblank, \ifstrequal, \seteqnumber
           new CommandMap('Lwarp-macros', {
              ifstar: 'IfstarFunction',
              ifnextchar: 'IfnextcharFunction',
              ifblank: 'IfblankFunction',
              ifstrequal: 'IfstrequalFunction',
              seteqnumber: 'SeteqnumberFunction'
           }, {
              // This function implements an ifstar macro.
              IfstarFunction(parser, name) {
                 const resultstar = parser.GetArgument(name);
                 const resultnostar = parser.GetArgument(name);
                 const star = parser.GetStar();                 // true if there is a *
                 useArgument(parser, star ? resultstar : resultnostar);
              },

             // This function implements an ifnextchar macro.
             IfnextcharFunction(parser, name) {
                let whichchar = parser.GetArgument(name);
                if (whichchar.match(/^(?:0x[0-9A-F]+|[0-9]+)$/i)) {
                  // $ syntax highlighting
                  whichchar = String.fromCodePoint(parseInt(whichchar));
                }
                const resultnextchar = parser.GetArgument(name);
                const resultnotnextchar = parser.GetArgument(name);
                const gotchar = (parser.GetNext() === whichchar);
                useArgument(parser, gotchar ? resultnextchar : resultnotnextchar);
             },

             // This function implements an ifblank macro.
             IfblankFunction(parser, name) {
                const blankarg = parser.GetArgument(name);
                const resultblank = parser.GetArgument(name);
                const resultnotblank = parser.GetArgument(name);
                const isblank = (blankarg.trim() == "");
                useArgument(parser, isblank ? resultblank : resultnotblank);
             },

             // This function implements an ifstrequal macro.
             IfstrequalFunction(parser, name) {
                const strequalfirst = parser.GetArgument(name);
                const strequalsecond = parser.GetArgument(name);
                const resultequal = parser.GetArgument(name);
                const resultnotequal = parser.GetArgument(name);
                const isequal = (strequalfirst == strequalsecond);
                useArgument(parser, isequal ? resultequal : resultnotequal);
             },

             // This function modifies the equation numbers.
             SeteqnumberFunction(parser, name) {
                 // Get the macro parameters
                 const star = parser.GetStar();                  // true if there is a *
                 const optBrackets = parser.GetBrackets(name);   // contents of optional brackets
                 const newsubequations = parser.GetArgument(name); // the subequations argument
                 const neweqsection = parser.GetArgument(name); // the eq section argument
                 const neweqnumber = parser.GetArgument(name);   // the eq number argument
                 MathJax.config.subequations=newsubequations ;   // a string with boolean meaning
                 MathJax.config.section=neweqsection ;           // a string with numeric meaning
                 parser.tags.counter = parser.tags.allCounter = neweqnumber ;
             }

           });

           // Create the Lwarp-macros package
           Configuration.create('Lwarp-macros', {
             handler: {macro: ['Lwarp-macros']}
           });

           MathJax.startup.defaultReady();

           // For forward references:
           MathJax.startup.input[0].preFilters.add(({math}) => {
             if (math.inputData.recompile){
                 MathJax.config.subequations = math.inputData.recompile.subequations;
                 MathJax.config.section = math.inputData.recompile.section;
             }
           });
           MathJax.startup.input[0].postFilters.add(({math}) => {
             if (math.inputData.recompile){
                 math.inputData.recompile.subequations = MathJax.config.subequations;
                 math.inputData.recompile.section = MathJax.config.section;
             }
           });

             // For \left, \right with unicode-math:
             const {DelimiterMap} = MathJax._.input.tex.SymbolMap;
             const {Symbol} = MathJax._.input.tex.Symbol;
             const {MapHandler} = MathJax._.input.tex.MapHandler;
             const delimiter = MapHandler.getMap('delimiter');
             delimiter.add('\\lBrack', new Symbol('\\lBrack', '\u27E6'));
             delimiter.add('\\rBrack', new Symbol('\\rBrack', '\u27E7'));
             delimiter.add('\\lAngle', new Symbol('\\lAngle', '\u27EA'));
             delimiter.add('\\rAngle', new Symbol('\\rAngle', '\u27EB'));
             delimiter.add('\\lbrbrak', new Symbol('\\lbrbrak', '\u2772'));
             delimiter.add('\\rbrbrak', new Symbol('\\rbrbrak', '\u2773'));
             delimiter.add('\\lbag', new Symbol('\\lbag', '\u27C5'));
             delimiter.add('\\rbag', new Symbol('\\rbag', '\u27C6'));
             delimiter.add('\\llparenthesis', new Symbol('\\llparenthesis', '\u2987'));
             delimiter.add('\\rrparenthesis', new Symbol('\\rrparenthesis', '\u2988'));
             delimiter.add('\\llangle', new Symbol('\\llangle', '\u2989'));
             delimiter.add('\\rrangle', new Symbol('\\rrangle', '\u298A'));
             delimiter.add('\\Lbrbrak', new Symbol('\\Lbrbrak', '\u27EC'));
             delimiter.add('\\Rbrbrak', new Symbol('\\Rbrbrak', '\u27ED'));
             delimiter.add('\\lBrace', new Symbol('\\lBrace', '\u2983'));
             delimiter.add('\\rBrace', new Symbol('\\rBrace', '\u2984'));
             delimiter.add('\\lParen', new Symbol('\\lParen', '\u2985'));
             delimiter.add('\\rParen', new Symbol('\\rParen', '\u2986'));
             delimiter.add('\\lbrackubar', new Symbol('\\lbrackubar', '\u298B'));
             delimiter.add('\\rbrackubar', new Symbol('\\rbrackubar', '\u298C'));
             delimiter.add('\\lbrackultick', new Symbol('\\lbrackultick', '\u298D'));
             delimiter.add('\\rbracklrtick', new Symbol('\\rbracklrtick', '\u298E'));
             delimiter.add('\\lbracklltick', new Symbol('\\lbracklltick', '\u298F'));
             delimiter.add('\\rbrackurtick', new Symbol('\\rbrackurtick', '\u2990'));
             delimiter.add('\\langledot', new Symbol('\\langledot', '\u2991'));
             delimiter.add('\\rangledot', new Symbol('\\rangledot', '\u2992'));
             delimiter.add('\\lparenless', new Symbol('\\lparenless', '\u2993'));
             delimiter.add('\\rparengtr', new Symbol('\\rparengtr', '\u2994'));
             delimiter.add('\\Lparengtr', new Symbol('\\Lparengtr', '\u2995'));
             delimiter.add('\\Rparenless', new Symbol('\\Rparenless', '\u2996'));
             delimiter.add('\\lblkbrbrak', new Symbol('\\lblkbrbrak', '\u2997'));
             delimiter.add('\\rblkbrbrak', new Symbol('\\rblkbrbrak', '\u2998'));
             delimiter.add('\\lvzigzag', new Symbol('\\lvzigzag', '\u29D8'));
             delimiter.add('\\rvzigzag', new Symbol('\\rvzigzag', '\u29D9'));
             delimiter.add('\\Lvzigzag', new Symbol('\\Lvzigzag', '\u29DA'));
             delimiter.add('\\Rvzigzag', new Symbol('\\Rvzigzag', '\u29DB'));
             delimiter.add('\\lcurvyangle', new Symbol('\\lcurvyangle', '\u29FC'));
             delimiter.add('\\rcurvyangle', new Symbol('\\rcurvyangle', '\u29FD'));
             delimiter.add('\\Vvert', new Symbol('\\Vvert', '\u2980'));
       }     // ready
  },         // startup

  tex: {
    packages: {'[+]': ['tagformat', 'Lwarp-macros', 'textmacros']},
    tags: "ams",
         tagformat: {
             number: function (n) {
                 if(MathJax.config.subequations==0)
                      return(MathJax.config.section + n);
                 else
                      return(MathJax.config.section + String.fromCharCode(96+n));
             },
         },
  }
}
</script>

<script
    id="MathJax-script"
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"
></script>


</head>
<body>



<a id="index-autopage-160"></a>
<nav class="topnavigation"><a href="index.html" class="linkhome" >
Home</a></nav>

<header>

<p>
<a href="Advanced-C-FAQs-Vol-1-2.html" class="linkhome" >
Previous</a>
</p>

</header>



<div class="bodyandsidetoc">
<div class="sidetoccontainer">



<nav class="sidetoc">



<div class="sidetoctitle">

<p>
<span class="sidetocthetitle">Ancient Science Publishers</span>
</p>

<p>
Contents
</p>
</div>



<div class="sidetoccontents">

<p>
<a href="index.html" class="linkhome" >
Home</a>
</p>

<p>
<a href="textcolor-redComputer-Science.html#autosec-9" class="tocpart" >
<span class="sectionnumber">I</span>&#x2003;<span
      class="textcolor"
      style="color:#FF0000"
>Computer Science</span></a>
</p>



<p>
<a href="textcolor-redComputer-Science.html#autosec-10" class="tocchapter" >
<span class="sectionnumber">1</span>&#x2003;Discipline of Competitive Programming : A Hacker’s Perspective</a>
</p>



<p>
<a href="Elements-Coding-Science-Deriving-Correct-Programs.html#autosec-13" class="tocchapter" >
<span class="sectionnumber">2</span>&#x2003;Elements of Coding : Science of Deriving Correct Programs</a>
</p>



<p>
<a href="Elements-Coding-Linear-Algebra-The-Nucleus-Artificial-Intelligence.html#autosec-16" class="tocchapter" >
<span class="sectionnumber">3</span>&#x2003;Elements of Coding Linear Algebra : The Nucleus of Artificial Intelligence</a>
</p>



<p>
<a href="Elements-Software-Design-Patterns.html#autosec-24" class="tocchapter" >
<span class="sectionnumber">4</span>&#x2003;Elements of Software Design Patterns</a>
</p>



<p>
<a href="Elements-Coding-AI.html#autosec-90" class="tocchapter" >
<span class="sectionnumber">5</span>&#x2003;Elements of Coding AI</a>
</p>



<p>
<a href="Elements-Coding-DL-Deep-Learning.html#autosec-92" class="tocchapter" >
<span class="sectionnumber">6</span>&#x2003;Elements of Coding DL (Deep Learning)</a>
</p>



<p>
<a href="Elements-Coding-ML-Internals-Machine-Learning-Library-MLPack.html#autosec-94" class="tocchapter" >
<span class="sectionnumber">7</span>&#x2003;Elements of Coding ML : Internals of Machine Learning Library MLPack</a>
</p>



<p>
<a href="Conceptual-BitCoin-Blockchain-Coding.html#autosec-96" class="tocchapter" >
<span class="sectionnumber">8</span>&#x2003;Conceptual BitCoin : Blockchain Coding</a>
</p>



<p>
<a href="Conceptual-Data-Science-Interviews.html#autosec-98" class="tocchapter" >
<span class="sectionnumber">9</span>&#x2003;Conceptual Data Science Interviews</a>
</p>



<p>
<a href="Conceptual-Dependency-Injection-Unwiring-Simplified-in-C.html#autosec-100" class="tocchapter" >
<span class="sectionnumber">10</span>&#x2003;Conceptual Dependency Injection : Unwiring Simplified in C++</a>
</p>



<p>
<a href="Conceptual-Dynamic-Programming-Optimal-Coding-Simplified.html#autosec-102" class="tocchapter" >
<span class="sectionnumber">11</span>&#x2003;Conceptual Dynamic Programming : Optimal Coding Simplified</a>
</p>



<p>
<a href="Conceptual-Programming-Interviews.html#autosec-104" class="tocchapter" >
<span class="sectionnumber">12</span>&#x2003;Conceptual Programming Interviews</a>
</p>



<p>
<a href="Conceptual-Machine-Learning.html#autosec-106" class="tocchapter" >
<span class="sectionnumber">13</span>&#x2003;Conceptual Machine Learning</a>
</p>



<p>
<a href="Conceptual-Programming-STL-Algorithms.html#autosec-108" class="tocchapter" >
<span class="sectionnumber">14</span>&#x2003;Conceptual Programming of STL Algorithms</a>
</p>



<p>
<a href="Conceptual-Solutions-CLRS-Introduction-Algorithms.html#autosec-110" class="tocchapter" >
<span class="sectionnumber">15</span>&#x2003;Conceptual Solutions to (CLRS) Introduction to Algorithms</a>
</p>



<p>
<a href="Conceptual-Programming-Algorithms-Using-Dijkstra’s-Approach.html#autosec-112" class="tocchapter" >
<span class="sectionnumber">16</span>&#x2003;Conceptual Programming of Algorithms Using Dijkstra’s Approach</a>
</p>



<p>
<a href="Conceptual-Solutions-Pattern-Recognition-Machine-Learning.html#autosec-114" class="tocchapter" >
<span class="sectionnumber">17</span>&#x2003;Conceptual Solutions to Pattern Recognition and Machine Learning</a>
</p>



<p>
<a href="Science-Deriving-Beautiful-Programs.html#autosec-116" class="tocchapter" >
<span class="sectionnumber">18</span>&#x2003;Science of Deriving Beautiful Programs</a>
</p>



<p>
<a href="Modern-C-Ranges-Revolution-in-STL.html#autosec-118" class="tocchapter" >
<span class="sectionnumber">19</span>&#x2003;Modern C++ Ranges : A Revolution in STL</a>
</p>



<p>
<a href="Elements-C-20.html#autosec-120" class="tocchapter" >
<span class="sectionnumber">20</span>&#x2003;Elements of C++20</a>
</p>



<p>
<a href="Solving-Problems-using-Dynamic-Programming-Hacker’s-Perspective.html#autosec-126" class="tocchapter" >
<span class="sectionnumber">21</span>&#x2003;Solving Problems using Dynamic Programming : A Hacker’s Perspective</a>
</p>



<p>
<a href="Hacking-TensorFlow-Internals-An-Insider’s-Commentary-on-Learning-System.html#autosec-157" class="tocchapter" >
<span class="sectionnumber">22</span>&#x2003;Hacking TensorFlow Internals : An Insider’s Commentary on A Learning System</a>
</p>



<p>
<a href="Advanced-C-FAQs-Vol-1-2.html#autosec-159" class="tocchapter" >
<span class="sectionnumber">23</span>&#x2003;Advanced C++ FAQs Vol 1 &amp; 2</a>
</p>



<p>
<a href="C-14-FAQs.html#autosec-161" class="tocchapter" >
<span class="sectionnumber">24</span>&#x2003;C++14 FAQs</a>
</p>



<p>
<a href="The-Boost-C-Libraries-Generic-Programming.html#autosec-261" class="tocchapter" >
<span class="sectionnumber">25</span>&#x2003;The Boost C++ Libraries: Generic Programming</a>
</p>



<p>
<a href="Generic-Algorithms-Data-Structures-using-C-11.html#autosec-263" class="tocchapter" >
<span class="sectionnumber">26</span>&#x2003;Generic Algorithms and Data Structures using C++11</a>
</p>



<p>
<a href="C-11-Standard-Library-Usage-Implementation.html#autosec-265" class="tocchapter" >
<span class="sectionnumber">27</span>&#x2003;C++11 Standard Library: Usage and Implementation</a>
</p>



<p>
<a href="Foundation-Algorithms-in-C-11.html#autosec-267" class="tocchapter" >
<span class="sectionnumber">28</span>&#x2003;Foundation of Algorithms in C++11</a>
</p>



<p>
<a href="C-11-Algorithms-Using-Extending-C-11-Boost-Beyond.html#autosec-269" class="tocchapter" >
<span class="sectionnumber">29</span>&#x2003;C++11 Algorithms : Using and Extending C++11, Boost and Beyond</a>
</p>



<p>
<a href="Cracking-Programming-Interviews-500-Questions-with-Solutions.html#autosec-271" class="tocchapter" >
<span class="sectionnumber">30</span>&#x2003;Cracking Programming Interviews : 500 Questions with Solutions</a>
</p>



<p>
<a href="Top-20-Coding-Interview-Problems-Asked-in-Google-with-Solutions.html#autosec-305" class="tocchapter" >
<span class="sectionnumber">31</span>&#x2003;Top 20 Coding Interview Problems Asked in Google with Solutions</a>
</p>



<p>
<a href="Top-10-Coding-Interview-Problems-Asked-in-Google-with-Solutions.html#autosec-367" class="tocchapter" >
<span class="sectionnumber">32</span>&#x2003;Top 10 Coding Interview Problems Asked in Google with Solutions</a>
</p>



<p>
<a href="Physics.html#autosec-403" class="tocpart" >
<span class="sectionnumber">II</span>&#x2003;Physics</a>
</p>



<p>
<a href="Mathematics.html#autosec-405" class="tocpart" >
<span class="sectionnumber">III</span>&#x2003;Mathematics</a>
</p>



</div>

</nav>

</div>



<main class="bodycontainer">



<section class="textbody">

<h1>Ancient Science Publishers</h1>

<!--MathJax customizations:-->



<div class="hidden">

\(\newcommand{\footnotename}{footnote}\)

\(\def \LWRfootnote {1}\)

\(\newcommand {\footnote }[2][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\newcommand {\footnotemark }[1][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\let \LWRorighspace \hspace \)

\(\renewcommand {\hspace }{\ifstar \LWRorighspace \LWRorighspace }\)

\(\newcommand {\mathnormal }[1]{{#1}}\)

\(\newcommand \ensuremath [1]{#1}\)

\(\newcommand {\LWRframebox }[2][]{\fbox {#2}} \newcommand {\framebox }[1][]{\LWRframebox } \)

\(\newcommand {\setlength }[2]{}\)

\(\newcommand {\addtolength }[2]{}\)

\(\newcommand {\setcounter }[2]{}\)

\(\newcommand {\addtocounter }[2]{}\)

\(\newcommand {\arabic }[1]{}\)

\(\newcommand {\number }[1]{}\)

\(\newcommand {\noalign }[1]{\text {#1}\notag \\}\)

\(\newcommand {\cline }[1]{}\)

\(\newcommand {\directlua }[1]{\text {(directlua)}}\)

\(\newcommand {\luatexdirectlua }[1]{\text {(directlua)}}\)

\(\newcommand {\protect }{}\)

\(\def \LWRabsorbnumber #1 {}\)

\(\def \LWRabsorbquotenumber &quot;#1 {}\)

\(\newcommand {\LWRabsorboption }[1][]{}\)

\(\newcommand {\LWRabsorbtwooptions }[1][]{\LWRabsorboption }\)

\(\def \mathchar {\ifnextchar &quot;\LWRabsorbquotenumber \LWRabsorbnumber }\)

\(\def \mathcode #1={\mathchar }\)

\(\let \delcode \mathcode \)

\(\let \delimiter \mathchar \)

\(\def \oe {\unicode {x0153}}\)

\(\def \OE {\unicode {x0152}}\)

\(\def \ae {\unicode {x00E6}}\)

\(\def \AE {\unicode {x00C6}}\)

\(\def \aa {\unicode {x00E5}}\)

\(\def \AA {\unicode {x00C5}}\)

\(\def \o {\unicode {x00F8}}\)

\(\def \O {\unicode {x00D8}}\)

\(\def \l {\unicode {x0142}}\)

\(\def \L {\unicode {x0141}}\)

\(\def \ss {\unicode {x00DF}}\)

\(\def \SS {\unicode {x1E9E}}\)

\(\def \dag {\unicode {x2020}}\)

\(\def \ddag {\unicode {x2021}}\)

\(\def \P {\unicode {x00B6}}\)

\(\def \copyright {\unicode {x00A9}}\)

\(\def \pounds {\unicode {x00A3}}\)

\(\let \LWRref \ref \)

\(\renewcommand {\ref }{\ifstar \LWRref \LWRref }\)

\( \newcommand {\multicolumn }[3]{#3}\)

\(\require {textcomp}\)

\(\newcommand {\toprule }[1][]{\hline }\)

\(\let \midrule \toprule \)

\(\let \bottomrule \toprule \)

\(\def \LWRbooktabscmidruleparen (#1)#2{}\)

\(\newcommand {\LWRbooktabscmidrulenoparen }[1]{}\)

\(\newcommand {\cmidrule }[1][]{\ifnextchar (\LWRbooktabscmidruleparen \LWRbooktabscmidrulenoparen }\)

\(\newcommand {\morecmidrules }{}\)

\(\newcommand {\specialrule }[3]{\hline }\)

\(\newcommand {\addlinespace }[1][]{}\)

\(\def \LWRpagenote {1}\)

\(\newcommand {\pagenote }[2][\LWRpagenote ]{{}^{\mathrm {#1}}}\)

\(\newcommand {\intertext }[1]{\text {#1}\notag \\}\)

\(\let \Hat \hat \)

\(\let \Check \check \)

\(\let \Tilde \tilde \)

\(\let \Acute \acute \)

\(\let \Grave \grave \)

\(\let \Dot \dot \)

\(\let \Ddot \ddot \)

\(\let \Breve \breve \)

\(\let \Bar \bar \)

\(\let \Vec \vec \)

\(\newcommand {\conceptequiv }{\triangleq }\)

\(\newcommand {\CC }{\mathcal {C}}\)

\(\newcommand {\refines }{\looparrowright }\)

\(\newcommand {\weakens }{\looparrowleft }\)

\(\DeclareMathOperator *{\Max }{Max}\)

\(\DeclareMathOperator *{\Min }{Min}\)

\(\newcommand {\mleft }{\left }\)

\(\newcommand {\mright }{\right }\)

\(\newcommand {\mleftright }{}\)

\(\newcommand {\mleftrightrestore }{}\)

\(\require {physics}\)

\(\newcommand {\bigO }{\mathcal {O}}\)

</div>

<p>
<!--................................-->
<h3 id="autosec-161">Monograph&nbsp;<span class="sectionnumber">24&#x2003;</span>C++14 FAQs</h3>
<a id="index-autopage-161"></a>
<a id="index-autofile-24"></a>
<div class="marginblock" role="note" style="width:217pt; float:right; ">
<div class="center">

<p>


<a href="cpp14faqs/cover.svg" target="_blank" ><img
      src="cpp14faqs/cover.svg"
      style="
      width:217pt;
      "
      class="inlineimage"
      alt="(image)"
></a>
</p>
</div>

</div>

<p>
This book contains selected questions (<b>84</b>) related to C++14 with detailed solutions to all of these which will help the reader to hone her skills to solve a particular problem.
</p>

<p>
Primary source of this collection is <em>Advanced C++ FAQs: Volumes 1 &amp; 2</em>.
</p>

<p>
This book is not an introduction to C++. It assumes that the reader is aware of the basics of C++98 and C++03 and wants to expand her horizon to latest and greatest in C++14(aka C++1y). The
problems are marked on a scale of one(*)(simplest) to five stars(*****)(hardest).
</p>



<div class="hrule">

</div>
<!--................................-->
<h4 id="autosec-164">Table of Contents</h4>
<a id="index-autopage-164"></a>



<ul style="list-style-type:none">


<li>
<p>
1. variable templates
</p>


</li>
<li>


<p>
2. Constexpr static data members of class templates
</p>


</li>
<li>


<p>
3. constexpr function templates
</p>


</li>
<li>


<p>
4. variable templates in action
</p>


</li>
<li>


<p>
5. static data member template
</p>


</li>
<li>


<p>
6. specialization of variable template
</p>


</li>
<li>


<p>
7. default argument and specialization of variable template
</p>


</li>
<li>


<p>
8. lambda and variable template
</p>


</li>
<li>


<p>
9. variable templates variables vary
</p>


</li>
<li>


<p>
10. auto variable templates
</p>


</li>
<li>


<p>
11. valid specialization but error ?
</p>


</li>
<li>


<p>
12. variable templates and lambda revisited
</p>


</li>
<li>


<p>
13. Incremental improvement to integral_constant
</p>


</li>
<li>


<p>
14. is_same musings
</p>


</li>
<li>


<p>
15. auto variable template and generic lambda
</p>


</li>
<li>


<p>
16. constexpr member functions and implicit const
</p>


</li>
<li>


<p>
17. constexpr constructor and initialization
</p>


</li>
<li>


<p>
18. constexpr and branching
</p>


</li>
<li>


<p>
19. constexpr and looping iteration
</p>


</li>
<li>


<p>
20. constexpr and mutation
</p>


</li>
<li>


<p>
21. constexpr vs static vs uninitialized
</p>


</li>
<li>


<p>
22. constexpr vs member function revisited
</p>


</li>
<li>


<p>
23. deprecated attribute
</p>


</li>
<li>


<p>
24. Member initializers and aggregate class
</p>


</li>
<li>


<p>
25. Member initializers and aggregate array
</p>


</li>
<li>


<p>
26. Data Member initializers
</p>


</li>
<li>


<p>
27. time duration literals
</p>


</li>
<li>


<p>
28. Expressing π multiplication
</p>


</li>
<li>


<p>
29. Compile Time _binary Literal Operator
</p>


</li>
<li>


<p>
30. Square Literal Operator
</p>


</li>
<li>


<p>
31. Type Transformation Aliases
</p>


</li>
<li>


<p>
32. unique_ptr vs make_unique as function argument
</p>


</li>
<li>


<p>
33. make_unique as perfect forwarding guy
</p>


</li>
<li>


<p>
34. make_unique and new
</p>


</li>
<li>


<p>
35. make_unique and value initialization
</p>


</li>
<li>


<p>
36. make_unique and single object
</p>


</li>
<li>


<p>
37. make_unique and default initialization
</p>


</li>
<li>


<p>
38. make_unique and array T[n]
</p>


</li>
<li>


<p>
39. make_unique and array T[]
</p>


</li>
<li>


<p>
40. make_unique and default initialization with T[]
</p>


</li>
<li>


<p>
41. Extend make_unique : Support list initialization T[]
</p>


</li>
<li>


<p>
42. Extend make_unique : Value Initialize T[]
</p>


</li>
<li>


<p>
43. Extend make_unique : T[N]
</p>


</li>
<li>


<p>
44. allocate_unique
</p>


</li>
<li>


<p>
45. Compile-time integer sequences
</p>


</li>
<li>


<p>
46. Simplified Creation of std::integer_sequence
</p>


</li>
<li>


<p>
47. std::index_sequence
</p>


</li>
<li>


<p>
48. Custom Sequence : Addition
</p>


</li>
<li>


<p>
49. Custom Sequence : Multiply
</p>


</li>
<li>


<p>
50. Custom Sequence : Split
</p>


</li>
<li>


<p>
51. Extract from tuple
</p>


</li>
<li>


<p>
52. convert std::array to std::tuple
</p>


</li>
<li>


<p>
53. Piecewise construction of std::pair
</p>


</li>
<li>


<p>
54. Compile Time Integer Sequence Simplified
</p>


</li>
<li>


<p>
55. sfinae and represent type of function
</p>


</li>
<li>


<p>
56. metafunction : check presence of type member
</p>


</li>
<li>


<p>
57. std::common_type and sfinae
</p>


</li>
<li>


<p>
58. Contextual Conversion
</p>


</li>
<li>


<p>
59. Single quotation mark as digit separator
</p>


</li>
<li>


<p>
60. Binary Literals
</p>


</li>
<li>


<p>
61. auto return type in function declaration
</p>


</li>
<li>


<p>
62. return type deduction for function
</p>


</li>
<li>


<p>
63. return type deduction for lambdas
</p>


</li>
<li>


<p>
64. return type deduction for lambdas contd..
</p>


</li>
<li>


<p>
65. decltype(auto)
</p>


</li>
<li>


<p>
66. return type deduction for function templates
</p>


</li>
<li>


<p>
67. explicit instantiation and auto
</p>


</li>
<li>


<p>
68. return type deduction and virtual
</p>


</li>
<li>


<p>
69. deduce return type
</p>


</li>
<li>


<p>
70. generalized lambda capture
</p>


</li>
<li>


<p>
71. generic lambda and product vector
</p>


</li>
<li>


<p>
72. generic lambda
</p>


</li>
<li>


<p>
73. generic lambda definition
</p>


</li>
<li>


<p>
74. conversion function of generic lambda
</p>


</li>
<li>


<p>
75. generic lambda quiz
</p>


</li>
<li>


<p>
76. Preventing Name Hijacking
</p>


</li>
<li>


<p>
77. Find First Null Pointer in a Container
</p>


</li>
<li>


<p>
78. Generic Operator Functors
</p>


</li>
<li>


<p>
79. Exchange Utility
</p>


</li>
<li>


<p>
80. Addressing Tuple By Type
</p>


</li>
<li>


<p>
81. Quoted manipulators
</p>


</li>
<li>


<p>
82. Null Iterator
</p>


</li>
<li>


<p>
83. std::move is rvalue_cast
</p>


</li>
<li>


<p>
84. C++14 Compiler
</p>
</li>
</ul>



<div class="hrule">

</div>

<p>
<span class="underline"><b><span
      class="textcolor"
      style="color:#FF7D00"
>Excerpt</span> <span
      class="textcolor"
      style="color:#4D0000"
>(Questions 1-23 with Solutions):</span></b></span>
</p>
<!--................................-->
<h4 id="autosec-165">variable templates</h4>
<a id="index-autopage-165"></a>


<a id="ex01"></a>



<div class="center">

<p>
<b>*** Question 1&#x2003;&#x2003;variable template</b>
</p>
</div>

<a id="autoid-3" ></a >

<p>
What is a <em>variable template</em> ?

<a id="ex01-Answer"></a>
</p>
<div class="center">

<p>
<b><span class="textsc">Solution</span> <a href="C-14-FAQs.html#ex01">1</a></b>
</p>
</div>

<p>
A <em>variable template</em> is a declaration which is introduced by a template declaration of a variable. As we already know that a template declaration is also a definition if its declaration defines
a function, a class, a variable, or a static data member.
</p>

<p>
A <em>variable template</em> at class scope is a <em>static data member template</em>.
</p>

<p>
Consider a simple template meta function, which uses variable template feature to store the boolean value of result of comparing two types:
</p>
<pre class="programlisting">
1 template &lt;typename T, typename U&gt;
2 constexpr bool is_same = std::is_same&lt;T, U&gt;::value;
3
4 bool t = is_same&lt;int, int&gt;; // true
5 bool f = is_same&lt;int, float&gt;; // false
</pre>

<p>
The types of variable templates are not restricted to just built-in types; they can be user defined types.
</p>
<pre class="programlisting">
1 struct matrix_constants
2{
3     template&lt;typename T&gt;
4     using pauli = hermitian_matrix&lt;T, 2&gt;;
5
6     template&lt;typename T&gt;
7     constexpr pauli&lt;T&gt; sigma1 = { { 0, 1 }, { 1, 0 } };
8
9     template&lt;typename T&gt;
10     constexpr pauli&lt;T&gt; sigma2 = { { 0, −1i }, { 1i, 0 } };
11
12     template&lt;typename T&gt;
13     constexpr pauli&lt;T&gt; sigma3 = { { 1, 0 }, { −1, 0 } };
14 };
</pre>

<p>
It makes definitions and uses of parameterized constants much simpler, leading to simplified and more uniform programming rules to teach and to remember like:
</p>
<pre class="programlisting">
1 template&lt;typename T&gt;
2 struct lexical_cast_fn
3{
4     template&lt;typename U&gt;
5     T operator()(U const &amp;u) const
6     {
7          // ...
8     }
9 };
10
11 template&lt;typename T&gt;
12 constexpr lexical_cast_fn&lt;T&gt; lexical_cast{};
13
14 int main()
15 {
16      lexical_cast &lt;int&gt;(”42”);
17 }
</pre>
<!--................................-->
<h4 id="autosec-170">Constexpr static data members of class templates</h4>
<a id="index-autopage-170"></a>


<a id="ex02"></a>



<div class="center">

<p>
<b>*** Question 2&#x2003;&#x2003;Constexpr static data members of class templates</b>
</p>
</div>

<a id="autoid-4" ></a >

<p>
What is issue with constexpr static data members of class templates ?

<a id="ex02-Answer"></a>
</p>
<div class="center">

<p>
<b><span class="textsc">Solution</span> <a href="C-14-FAQs.html#ex02">2</a></b>
</p>
</div>

<p>
Let us revisit how <em>std::is_same</em> is designed:
</p>
<pre class="programlisting">
1 template&lt;typename T, T v&gt;
2 struct integral_constant
3{
4     static constexpr T value = v;
5     typedef T value_type;
6      ....
7 };
8
9 template&lt;typename T, T v&gt;
10 constexpr T integral_constant&lt;T, v&gt;::value;
11
12 typedef integral_constant&lt;bool, true&gt; true_type;
13 typedef integral_constant&lt;bool, false&gt; false_type;
14
15 template&lt;typename T, typename U&gt;
16 struct is_same : false_type{};
17
18 template&lt;typename T&gt;
19 struct is_same&lt;T, T&gt; : true_type{};
</pre>

<p>
The main problems with <em>static data member</em> are:
</p>
<ul style="list-style-type:none">


<li>
<p>
• they require <em>duplicate</em> declarations:
</p>
<ul style="list-style-type:none">


<li>
<p>
1. once inside the class template,
</p>


</li>
<li>


<p>
2. once outside the class template to provide the real definition in case the constants is odr(One Definition Rule) used.
</p>
</li>
</ul>
</li>
<li>


<p>
• It creates confusion by the necessity of providing twice the same declaration, whereas ordinary constant declarations do not need duplicate declarations.
</p>
</li>
</ul>

<p>
The standard class <em>numeric_limits</em> also suffers from the same problem as far as constexpr static data members are concerned.
</p>
<!--................................-->
<h4 id="autosec-172">constexpr function templates</h4>
<a id="index-autopage-172"></a>


<a id="ex03"></a>



<div class="center">

<p>
<b>*** Question 3&#x2003;&#x2003;constexpr function templates</b>
</p>
</div>

<a id="autoid-5" ></a >

<p>
What is issue with constexpr function templates ?

<a id="ex03-Answer"></a>
</p>
<div class="center">

<p>
<b><span class="textsc">Solution</span> <a href="C-14-FAQs.html#ex03">3</a></b>
</p>
</div>

<p>
Constexpr functions templates provide functional abstraction.
</p>

<p>
A simple constexpr function template :
</p>
<pre class="programlisting">
1 template &lt;typename T, typename U&gt;
2 constexpr bool is_same()
3{
4    return std::is_same&lt;T, U&gt;::value;
5}
</pre>

<p>
Constexpr functions templates do not have the duplicate declarations issue that static data members have.
</p>

<p>
However, they force us to chose in advance, at the definition site, how the constants are to be delivered: either by a const reference, or by plain non-reference type.
</p>

<p>
If delivered by const reference then the constants must be systematically be allocated in static storage.
</p>

<p>
If by non-reference type, then the constants need copying.
</p>

<p>
Copying isn’t an issue for built-in types, but it is an issue for user-defined types with value semantics that aren’t just wrappers around tiny built-in types
</p>

<p>
Whereas ordinary const(expr) variables do not suffer from this problem. A simple definition is provided, and the decision of whether the constants actually needs to be layout out in storage only
depends on the usage, not the definition.
</p>

<p>
Another examples are the static member functions of <em>std::numeric_limits</em> and functions like \(boost::constants::pi&lt;T&gt;()\):
</p>
<pre class="programlisting">
1 #include &lt;boost/math/constants/constants.hpp&gt;
2
3 template &lt;class Real&gt;
4 Real area(Real r)
5{
6   using namespace boost::math::constants;
7   return pi&lt;Real&gt;() ∗ r ∗ r;
8}
</pre>

<p>
The function template versions of the constants are simple inline functions that return a constant of the correct precision for the type used. In addition, these functions are declared constexpr for
those compilers that support this, allowing the result to be used in constant expressions provided the template argument is a literal type.
</p>

<p>
It looks like we are creating constexpr functions only to return a constant.
</p>
<!--................................-->
<h4 id="autosec-176">variable templates in action</h4>
<a id="index-autopage-176"></a>


<a id="ex04"></a>



<div class="center">

<p>
<b>** Question 4&#x2003;&#x2003;variable templates in action</b>
</p>
</div>

<a id="autoid-6" ></a >

<p>
Illustrate how <em>variable templates</em> can be used to compute the area of a circle for a given type with appropriate precision?

<a id="ex04-Answer"></a>
</p>
<div class="center">

<p>
<b><span class="textsc">Solution</span> <a href="C-14-FAQs.html#ex04">4</a></b>
</p>
</div>

<p>
<em>variable templates</em> address both of the issues illustrated before and no syntax modification was required to incorporate this feature in C++11 because current grammar allows any
declaration to be parameterized. It was prohibited earlier via semantic constraints which is relaxed now on template declarations.
</p>

<p>
Let us first represent the mathematical constant \(\pi \) with precision dictated by a floating point datatype:
</p>
<a id="autoid-7" ></a >



<div class="figurecaption">

<p>
Listing&nbsp;24.1:&nbsp;\(\pi \) and variable template
</p>
</div>
<pre class="programlisting">
1 #include &lt;iostream&gt;
2 #include &lt;iomanip&gt;
3
4 template&lt;typename T&gt;
5 constexpr T pi = T(3.1415926535897932385);
6
7 int main()
8{
9     std::cout &lt;&lt; std::setprecision(40);
10     std::cout &lt;&lt; ”pi&lt;int&gt; : ” &lt;&lt; pi&lt;int&gt; &lt;&lt; std::endl;
11     std::cout &lt;&lt; ”pi&lt; float &gt; : ” &lt;&lt; pi&lt;float&gt; &lt;&lt; std::endl;
12     std::cout &lt;&lt; ”pi&lt;double&gt; : ” &lt;&lt; pi&lt;double&gt; &lt;&lt;std::endl;
13 }
</pre>

<p>
With the following command:
</p>
<pre class="verbatim">
clang++ -std=c++1y variable_template.cpp


</pre>

<p>
we get the following output:
</p>
<pre class="verbatim">
pi<int> : 3
pi<float> : 3.1415927410125732421875
pi<double> : 3.141592653589793115997963468544185161591


</pre>

<p>
This variable template can be used in a generic function to compute the area of a circle for a given radius:
</p>
<pre class="programlisting">
1 template&lt;typename T&gt;
2 T area_circle(T r)
3{
4     return pi&lt;T&gt; ∗ r ∗ r;
5}
</pre>



</p>
<!--................................-->
<h4 id="autosec-182">static data member template</h4>
<a id="index-autopage-182"></a>


<a id="ex05"></a>



<div class="center">

<p>
<b>** Question 5&#x2003;&#x2003;static data member template</b>
</p>
</div>

<a id="autoid-8" ></a >

<p>
Provide a suitable definition of the static data member template <em>min</em>:
</p>
<pre class="programlisting">
1 struct limits
2{
3     template&lt;typename T&gt;
4     static const T min; // declaration of min
5 };
</pre>

<a id="ex05-Answer"></a>



<div class="center">

<p>
<b><span class="textsc">Solution</span> <a href="C-14-FAQs.html#ex05">5</a></b>
</p>
</div>

<p>
As we already know that a variable template at class scope is a <em>static data member template</em> and a definition for a static data member or static data member template may be provided in a
namespace scope enclosing the definition of the static member’s class template.
</p>
<pre class="programlisting">
1 struct limits
2{
3     template&lt;typename T&gt;
4     static const T min; // declaration of min
5 };
6
7 template&lt;typename T&gt;
8 const T limits::min = { }; // definition of min
</pre>
<!--................................-->
<h4 id="autosec-185">specialization of variable template</h4>
<a id="index-autopage-185"></a>


<a id="ex06"></a>



<div class="center">

<p>
<b>*** Question 6&#x2003;&#x2003;specialization of variable template</b>
</p>
</div>

<a id="autoid-9" ></a >

<p>
Simplify the program below to do the needful:
</p>
<pre class="programlisting">
1 template &lt;typename T, typename U&gt;
2 constexpr bool is_same = std::is_same&lt;T, U&gt;::value;
3
4 bool t = is_same&lt;int, int&gt;; // true
5 bool f = is_same&lt;int, float&gt;; // false
</pre>

<a id="ex06-Answer"></a>



<div class="center">

<p>
<b><span class="textsc">Solution</span> <a href="C-14-FAQs.html#ex06">6</a></b>
</p>
</div>

<p>
Variable templates are subject to template specialization like template functions, so we can simplify the code as follows:
</p>
<pre class="programlisting">
1 template&lt;typename T, typename U&gt;
2 constexpr bool is_same = false;
3
4 template&lt;typename T&gt;
5 constexpr bool is_same&lt;T, T&gt; = true;
</pre>
<!--................................-->
<h4 id="autosec-186">default argument and specialization of variable template</h4>
<a id="index-autopage-186"></a>


<a id="ex07"></a>



<div class="center">

<p>
<b>*** Question 7&#x2003;&#x2003;default argument and specialization of variable template</b>
</p>
</div>

<a id="autoid-10" ></a >

<p>
What is the output of the program ?
</p>
<pre class="programlisting">
1 #include &lt;iostream&gt;
2 #include &lt;iomanip&gt;
3
4 template&lt;typename T=double&gt;
5 constexpr T pi = T(3.1415926535897932385);
6
7 template&lt;&gt;
8 constexpr float pi&lt;int&gt; = pi&lt;float&gt;;
9
10 int main()
11 {
12     std::cout &lt;&lt; std::setprecision(30);
13     std::cout &lt;&lt; ”pi&lt;&gt; : ” &lt;&lt; pi&lt;&gt; &lt;&lt; std::endl;
14     std::cout &lt;&lt; ”pi&lt;int&gt; : ” &lt;&lt; pi&lt;int&gt; &lt;&lt; std::endl;
15     std::cout &lt;&lt; ”pi&lt; float &gt; : ” &lt;&lt; pi&lt;float&gt; &lt;&lt; std::endl;
16 }
</pre>

<a id="ex07-Answer"></a>



<div class="center">

<p>
<b><span class="textsc">Solution</span> <a href="C-14-FAQs.html#ex07">7</a></b>
</p>
</div>
<pre class="verbatim">
pi<> : 3.14159265358979311599796346854
pi<int> : 3.1415927410125732421875
pi<float> : 3.1415927410125732421875


</pre>
<!--................................-->
<h4 id="autosec-188">lambda and variable template</h4>
<a id="index-autopage-188"></a>


<a id="ex08"></a>



<div class="center">

<p>
<b>*** Question 8&#x2003;&#x2003;lambda and variable template</b>
</p>
</div>

<a id="autoid-11" ></a >

<p>
Simplify the program below.
</p>
<pre class="programlisting">
1 template&lt;typename T&gt;
2 T area_circle(T r)
3{
4     return pi&lt;T&gt; ∗ r ∗ r;
5}
</pre>

<a id="ex08-Answer"></a>
</p>
<div class="center">

<p>
<b><span class="textsc">Solution</span> <a href="C-14-FAQs.html#ex08">8</a></b>
</p>
</div>
<pre class="programlisting">
1 template&lt;typename T&gt;
2 auto area_circle = [](auto r) { return pi&lt;T&gt; ∗ r ∗ r; };
</pre>
<!--................................-->
<h4 id="autosec-191">variable templates variables vary</h4>
<a id="index-autopage-191"></a>


<a id="ex09"></a>



<div class="center">

<p>
<b>** Question 9&#x2003;&#x2003;variable templates variables vary</b>
</p>
</div>

<a id="autoid-12" ></a >

<p>
Is this a legal code ?
</p>
<pre class="programlisting">
1 #include &lt;iostream&gt;
2
3 template&lt;typename T&gt;
4 T magicVal = 42;
5
6 int main()
7{
8     std::cout &lt;&lt; magicVal&lt;int&gt; &lt;&lt;std::endl;;
9
10     magicVal&lt;int&gt; = 0;
11
12     std::cout &lt;&lt; magicVal&lt;int&gt; &lt;&lt;std::endl;;
13 }
</pre>

<p>
If yes, what is the output ?
</p>

<a id="ex09-Answer"></a>



<div class="center">

<p>
<b><span class="textsc">Solution</span> <a href="C-14-FAQs.html#ex09">9</a></b>
</p>
</div>

<p>
Yes, the code is correct because variable template instances are first-class objects.
</p>

<p>
Output is :
</p>
<pre class="verbatim">
42
0


</pre>
<!--................................-->
<h4 id="autosec-194">auto variable templates</h4>
<a id="index-autopage-194"></a>


<a id="ex010"></a>



<div class="center">

<p>
<b>** Question 10&#x2003;&#x2003;variable templates variables vary</b>
</p>
</div>

<a id="autoid-13" ></a >

<p>
Is this a legal code ?
</p>
<pre class="programlisting">
1 template&lt;class&gt; constexpr auto X = 42;
2
3 int main()
4{
5        static_assert (X&lt;int&gt; == 42, ””);
6}
</pre>

<a id="ex010-Answer"></a>



<div class="center">

<p>
<b><span class="textsc">Solution</span> <a href="C-14-FAQs.html#ex010">10</a></b>
</p>
</div>

<p>
Yes, a specialization of a variable template is a variable and as per the standard : <em>No diagnostic shall be issued for a template for which a valid specialization can be generated</em>.
</p>
<!--................................-->
<h4 id="autosec-196">valid specialization but error ?</h4>
<a id="index-autopage-196"></a>


<a id="ex011"></a>



<div class="center">

<p>
<b>*** Question 11&#x2003;&#x2003;valid specialization but error</b>
</p>
</div>

<a id="autoid-14" ></a >

<p>
Why this code doesn’t compile ?
</p>
<pre class="programlisting">
1 class Y
2{
3     typedef int type;
4 };
5
6 template&lt;Y::type N&gt;
7 struct X { };
</pre>

<a id="ex011-Answer"></a>



<div class="center">

<p>
<b><span class="textsc">Solution</span> <a href="C-14-FAQs.html#ex011">11</a></b>
</p>
</div>

<p>
Typical error is:
</p>
<pre class="verbatim">
specialize.cpp:3:17: error: ‘typedef int Y::type’ is private
     typedef int type;
                 ^
specialize.cpp:6:13: error: within this context
 template<Y::type N>
             ^


</pre>

<p>
Because the template parameter declaration is ill-formed, it gets diagnosed immediately and does not form any larger structure. Hence there is no template to be specialized in the first place. There
is no “being ill-formed”, because ill-formedness implies the state of not being.
</p>

<p>
So, if the parameter is nonsensical, then we don’t have a template declaration. And if the template declaration itself is nonsensical, we don’t have a declaration to specialize, hencde the compiler
error is issued.



</p>
<!--................................-->
<h4 id="autosec-199">variable templates and lambda revisited</h4>
<a id="index-autopage-199"></a>


<a id="ex012"></a>



<div class="center">

<p>
<b>*** Question 12&#x2003;&#x2003;variable templates and lambda revisited</b>
</p>
</div>

<a id="autoid-15" ></a >

<p>
Exploit <em>variable templates</em> and <em>lambda</em> to compute the area of a circle class.
</p>

<a id="ex012-Answer"></a>



<div class="center">

<p>
<b><span class="textsc">Solution</span> <a href="C-14-FAQs.html#ex012">12</a></b>
</p>
</div>
<pre class="programlisting">
1 template&lt;typename T&gt;
2 struct Circle
3{
4     T radius;
5
6     using value_type = T;
7
8     Circle(T r) : radius(r) {}
9     Circle(const Circle&amp; c) : radius(c.radius) {}
10 };
11
12 template&lt;typename T=double&gt;
13 constexpr T pi = T(3.1415926535897932385);
14
15 auto area = []( auto c )
16 {
17     using T = typename decltype(c)::value_type;
18     return pi&lt;T&gt; ∗ c.radius ∗ c.radius;
19 };
</pre>

<p>
Alternatively:
</p>
<pre class="programlisting">
1 template&lt;typename T&gt;
2 using f_type = T(∗)(Circle&lt;T&gt;);
3
4 template&lt;typename T&gt;
5 f_type&lt;T&gt; area = []( Circle&lt;T&gt; c )
6{
7     return pi&lt;T&gt; ∗ c.radius ∗ c.radius;
8 };
</pre>
<!--................................-->
<h4 id="autosec-201">Incremental improvement to integral_constant</h4>
<a id="index-autopage-201"></a>


<a id="ex013"></a>



<div class="center">

<p>
<b>*** Question 13&#x2003;&#x2003;Incremental improvement to integral_constant</b>
</p>
</div>

<a id="autoid-16" ></a >

<p>
Revisit the class template <em>is_arithmetic</em>:
</p>
<pre class="programlisting">
1 template &lt;class T&gt;
2 struct is_arithmetic
3     :
4     integral_constant&lt;
5     bool,
6     is_integral &lt;T&gt;::value ||
7     is_floating_point &lt;T&gt;::value
8 &gt; {};
</pre>

<p>
Before C++14, the typical usage of such a class template was:
</p>
<pre class="programlisting">
1 std::is_arithmetic&lt;T&gt;::value
</pre>

<p>
or
</p>
<pre class="programlisting">
1 static_cast&lt;bool&gt;(std::is_arithmetic&lt;T&gt;{})
</pre>

<p>
What was the increment improvement to the class <em>integral_constant</em> to enable simplified usage like
</p>
<pre class="programlisting">
1 std::is_arithmetic&lt;T&gt;{}()
</pre>

<a id="ex013-Answer"></a>



<div class="center">

<p>
<b><span class="textsc">Solution</span> <a href="C-14-FAQs.html#ex013">13</a></b>
</p>
</div>

<p>
The following addition was made in order to allow the template to serve as a source of compile-time function objects:
</p>
<pre class="programlisting">
1 constexpr value_type operator()() { return value; }
</pre>

<p>
So the final class looked like:
</p>
<pre class="programlisting">
1 template &lt;class T, T v&gt;
2 struct integral_constant
3{
4     static constexpr T value = v;
5     using value_type = T;
6     using type = integral_constant&lt;T,v&gt;;
7
8     constexpr operator value_type() { return value; }
9
10     constexpr value_type operator()() { return value; } // C++14
11 };
</pre>
<!--................................-->
<h4 id="autosec-208">is_same musings</h4>
<a id="index-autopage-208"></a>


<a id="ex014"></a>



<div class="center">

<p>
<b>** Question 14&#x2003;&#x2003;is_same musing</b>
</p>
</div>

<a id="autoid-17" ></a >

<p>
Enumerate different ways to use \(is\_same&lt;T, U&gt;\).

<a id="ex014-Answer"></a>
</p>
<div class="center">

<p>
<b><span class="textsc">Solution</span> <a href="C-14-FAQs.html#ex014">14</a></b>
</p>
</div>

<ul style="list-style-type:none">


<li>
<p>
1. As a function object:
</p>
<pre class="programlisting">
      std::is_same&lt;T, U&gt;()
</pre>
</li>
<li>


<p>
2. As a compile time evaluation by invoking the nested <em>value_type</em>:
</p>
<pre class="programlisting">
   std::is_same&lt;T, U&gt;::value
</pre>
</li>
<li>


<p>
3. By having a template alias as follows:
</p>
<pre class="programlisting">
   template&lt;typename T, typename U&gt;
   using is_same_v = typename std::is_same&lt;T, U&gt;::value;
</pre>
<p>
Now we can use it like
</p>
<pre class="programlisting">
   is_same_v&lt;T, U&gt;()
</pre>
</li>
<li>


<p>
4. In C++11:
</p>
<pre class="programlisting">
   static_cast&lt;bool&gt;(std::is_same&lt;T, U&gt;{})
</pre>
</li>
<li>


<p>
5. Using variable template like:
</p>
<pre class="programlisting">
   template&lt;typename T, typename U&gt;
   constexpr bool is_same = false;
   template&lt;typename T&gt;
   constexpr bool is_same&lt;T, T&gt; = true;
</pre>
<p>
It can be used like a variable:
</p>
<pre class="programlisting">
      is_same&lt;T, U&gt;
</pre>
</li>
</ul>

<p>
Note that in C++14, template aliases like the following are incorporated:
</p>
<pre class="programlisting">
1 template &lt;class T, class U&gt;
2    using is_same_t = typename is_same&lt;T, U&gt;::type;
</pre>
<!--................................-->
<h4 id="autosec-218">auto variable template and generic lambda</h4>
<a id="index-autopage-218"></a>


<a id="ex015"></a>



<div class="center">

<p>
<b>** Question 15&#x2003;&#x2003;auto variable template and generic lambda</b>
</p>
</div>

<a id="autoid-18" ></a >

<p>
Is this a valid code?
</p>
<pre class="programlisting">
1 template&lt;typename T&gt;
2 auto f = [](auto a, T b){ /∗∗/ };
3
4 int main()
5{
6     f&lt;int&gt;(1, 2);
7}
</pre>

<a id="ex015-Answer"></a>



<div class="center">

<p>
<b><span class="textsc">Solution</span> <a href="C-14-FAQs.html#ex015">15</a></b>
</p>
</div>

<p>
Yes and it works as expected in C++14 and clang 3.5 trunk.



</p>
<!--................................-->
<h4 id="autosec-220">constexpr member functions and implicit const</h4>
<a id="index-autopage-220"></a>


<a id="ex016"></a>



<div class="center">

<p>
<b>*** Question 16&#x2003;&#x2003;constexpr member functions and implicit const</b>
</p>
</div>

<a id="autoid-19" ></a >

<p>
Review the program :
</p>
<pre class="programlisting">
1 #include &lt;iostream&gt;
2
3 struct A
4{
5     constexpr A() : n(3) {}
6     constexpr int getN() const { return n; }
7
8     int n;
9 };
10
11
12 struct B
13 {
14     constexpr B() : a() {}
15     constexpr const A &amp;getA() const
16     {
17          return a;
18     }
19     A &amp;getA()
20     {
21          return a;
22     }
23
24     A a;
25 };
26
27
28 int main()
29 {
30
31     constexpr int n = B().getA().getN();
32 }
</pre>

<a id="ex016-Answer"></a>



<div class="center">

<p>
<b><span class="textsc">Solution</span> <a href="C-14-FAQs.html#ex016">16</a></b>
</p>
</div>

<p>
Compiler error looks like:
</p>
<pre class="verbatim">
constexpr_implicit_const.cpp: In function ‘int main()’:
constexpr_implicit_const.cpp:31:32:
error: call to non-constexpr function ‘A& B::getA()’
     constexpr int n = B().getA().getN();
                                ^


</pre>

<p>
<em>B().getA()</em> selects the non-constant overload version, leading to this error.
</p>

<p>
After rendering the code as :
</p>
<pre class="programlisting">
1 #include &lt;iostream&gt;
2
3 struct A
4{
5     constexpr A() : n(3) {}
6     constexpr int getN() const { return n; }
7
8     int n;
9 };
10
11
12 struct B
13 {
14     constexpr B() : a() {}
15     constexpr const A &amp;getA() const
16     {
17          return a;
18     }
19     constexpr A &amp;getA()
20     {
21          return a;
22     }
23
24     A a;
25 };
26
27
28 int main()
29 {
30
31     constexpr int n = B().getA().getN();
32 }
</pre>

<p>
We get the following compiler error with C++11: clang++ -std=c++11
</p>
<pre class="verbatim">
constexpr_implicit_const1.cpp:19:18:
warning: 'constexpr' non-static member
      function will not be implicitly 'const' in C++1y;
      add 'const' to avoid a
      change in behavior [-Wconstexpr-not-const]
    constexpr A &getA()
                  ^
                         const
constexpr_implicit_const1.cpp:19:18:
error: functions that differ only in their
      return type cannot be overloaded
constexpr_implicit_const1.cpp:15:24:
note: previous declaration is here
    constexpr const A &getA() const
                        ^
constexpr_implicit_const1.cpp:21:16:
error: binding of reference to type 'A' to
      a value of type 'const A' drops qualifiers
        return a;
               ^
1 warning and 2 errors generated.


</pre>

<p>
It points to a couple of issues including the restriction that <em>constexpr member functions are implicitly const in C++11</em> which creates problems for literal class types which desire to be
usable both within constant expressions and outside them.
</p>

<p>
So in C++14, this rule is removed. So it works fine with C++14 compliant compiler like clang 3.5 trunk.
</p>
<!--................................-->
<h4 id="autosec-225">constexpr constructor and initialization</h4>
<a id="index-autopage-225"></a>


<a id="ex017"></a>



<div class="center">

<p>
<b>** Question 17&#x2003;&#x2003;constexpr constructor and initialization</b>
</p>
</div>

<a id="autoid-20" ></a >

<p>
Review the program :
</p>
<pre class="programlisting">
1 int x;
2
3 struct A
4{
5     constexpr A(bool b) : m(b?42:x) { }
6     int m;
7 };
8
9 constexpr int v = A(true).m;
10
11 constexpr int w = A(false).m;
</pre>

<a id="ex017-Answer"></a>



<div class="center">

<p>
<b><span class="textsc">Solution</span> <a href="C-14-FAQs.html#ex017">17</a></b>
</p>
</div>

<p>
Compiler error with gcc 4.9 trunk is:
</p>
<pre class="verbatim">
constexpr_constructor.cpp:11:28:
in constexpr expansion of ‘A(0)’
constexpr_constructor.cpp:11:28:
error: the value of ‘x’ is not usable in a constant expression
 constexpr int w = A(false).m;
                            ^
constexpr_constructor.cpp:1:5: note: ‘int x’ is not const
 int x;
     ^


</pre>

<p>
Compiler error with clang 3.5 trunk is:
</p>
<pre class="verbatim">
constexpr_constructor.cpp:11:15:
error: constexpr variable 'w' must be
       initialized by a constant expression
constexpr int w = A(false).m;
               ^   ~~~~~~~~~~
constexpr_constructor.cpp:5:34:
note: read of non-const variable 'x' is not
       allowed in a constant expression
    constexpr A(bool b) : m(b?42:x) { }
                                  ^
constexpr_constructor.cpp:11:19: note: in call to 'A(false)'
constexpr int w = A(false).m;
                   ^
constexpr_constructor.cpp:1:5: note: declared here
int x;
    ^
1 error generated.


</pre>

<p>
The first call to constructor is ok it initializes m with the value \(42\) whereas the second call is in error because initializer for \(m\) is \(x\), which is non-constant.



</p>
<!--................................-->
<h4 id="autosec-229">constexpr and branching</h4>
<a id="index-autopage-229"></a>


<a id="ex018"></a>



<div class="center">

<p>
<b>** Question 18&#x2003;&#x2003;constexpr and branching</b>
</p>
</div>

<a id="autoid-21" ></a >

<p>
Can we use if-then-else version of the following constexpr factorial program:
</p>
<pre class="programlisting">
1 constexpr unsigned long long fact( unsigned long long x )
2{
3    return x &lt;= 1 ? 1ull : x ∗ fact(x−1);
4}
</pre>

<a id="ex018-Answer"></a>



<div class="center">

<p>
<b><span class="textsc">Solution</span> <a href="C-14-FAQs.html#ex018">18</a></b>
</p>
</div>

<p>
C++14 allowed constexpr to include branching, so we can rewrite as follows:
</p>
<pre class="programlisting">
1 constexpr auto fact( unsigned long long x )
2{
3     if ( x &lt;= 1 )
4          return 1ull;
5    else
6          return x ∗ fact(x−1);
7}
</pre>
<!--................................-->
<h4 id="autosec-232">constexpr and looping iteration</h4>
<a id="index-autopage-232"></a>


<a id="ex019"></a>



<div class="center">

<p>
<b>** Question 19&#x2003;&#x2003;constexpr and looping iteration</b>
</p>
</div>

<a id="autoid-22" ></a >

<p>
Can we use if-then-else version of the following constexpr factorial program:
</p>
<pre class="programlisting">
1 constexpr unsigned long long fact( unsigned long long x )
2{
3    return x &lt;= 1 ? 1ull : x ∗ fact(x−1);
4}
</pre>

<a id="ex019-Answer"></a>



<div class="center">

<p>
<b><span class="textsc">Solution</span> <a href="C-14-FAQs.html#ex019">19</a></b>
</p>
</div>

<p>
C++14 allowed constexpr to support loop constructs, so we can rewrite the factorial program in its iterative version as follows:
</p>
<pre class="programlisting">
1 constexpr auto fact( unsigned long long x )
2{
3    auto product = x;
4
5    while( −−x )
6        product ∗= x;
7
8    return product;
9}
</pre>

<p>
C++11 requirement that constexprs be single return statements worked well enough, but simple functions that required more than one line could not be constexpr. It sometimes forced inefficient
implementations in order to have at least some of its results generated at compile-time, but not always all. So this limitation was removed in C++14.
</p>

<p>
Note that this version may be more efficient, both at compile time and run time.



</p>
<!--................................-->
<h4 id="autosec-235">constexpr and mutation</h4>
<a id="index-autopage-235"></a>


<a id="ex020"></a>



<div class="center">

<p>
<b>** Question 20&#x2003;&#x2003;constexpr and mutation</b>
</p>
</div>

<a id="autoid-23" ></a >

<p>
Review the program:
</p>
<pre class="programlisting">
1 constexpr int f(int k)
2{
3    constexpr int x = k;
4    return x;
5}
</pre>

<a id="ex020-Answer"></a>



<div class="center">

<p>
<b><span class="textsc">Solution</span> <a href="C-14-FAQs.html#ex020">20</a></b>
</p>
</div>

<p>
It results into compiler error like:
</p>
<pre class="verbatim">
constexpr_init.cpp:3:19:
error: constexpr variable 'x' must be initialized by a
      constant expression
    constexpr int x = k;
                   ^   ~
constexpr_init.cpp:3:23:
note: read of non-const variable 'k' is not allowed in
      a constant expression
    constexpr int x = k;
                       ^
constexpr_init.cpp:1:21: note: declared here
constexpr int f(int k)
                     ^
1 error generated.



</pre>

<p>
The reason is : \(x\) is not initialized by a constant expression because lifetime of \(k\) began outside the initializer of \(x\).
</p>

<p>
So the line
</p>
<pre class="programlisting">
constexpr int x = k;
</pre>

<p>
should be replaced by:
</p>
<pre class="programlisting">
int x = k;
</pre>

<p>
To understand it better, let us review the following program:
</p>
<pre class="programlisting">
1 constexpr int incr(int &amp;n)
2{
3    return ++n;
4}
5
6 constexpr int g(int k)
7{
8    constexpr int x = incr(k);
9    return x;
10 }
</pre>

<p>
Here also, \(incr(k)\) is not a core constant expression because lifetime of \(k\) began outside the expression \(incr(k)\), so the culprit line responsible for compiler error is:
</p>
<pre class="programlisting">
1 constexpr int x = incr(k);
</pre>

<p>
Note that the following program is valid:
</p>
<pre class="programlisting">
1 constexpr int h(int k)
2{
3    int x = incr(k);
4    return x;
5}
6 constexpr int y = h(1);
</pre>

<p>
Because \(h(1)\) is a core constant expression because the lifetime of \(k\) begins inside \(h(1)\). It initializes \(y\) with the value \(2\).
</p>

<p>
To summarize, C++14 allows <em>mutation of objects whose lifetime began within the constant expression evaluation</em>.



</p>
<!--................................-->
<h4 id="autosec-243">constexpr vs static vs uninitialized</h4>
<a id="index-autopage-243"></a>


<a id="ex021"></a>



<div class="center">

<p>
<b>** Question 21&#x2003;&#x2003;constexpr vs static vs uninitialized</b>
</p>
</div>

<a id="autoid-24" ></a >

<p>
Review the program:
</p>
<pre class="programlisting">
1 constexpr int first (int n)
2{
3    static int value = n;
4    return value;
5}
6
7 constexpr int uninit()
8{
9    int a;
10     return a;
11 }
</pre>

<a id="ex021-Answer"></a>



<div class="center">

<p>
<b><span class="textsc">Solution</span> <a href="C-14-FAQs.html#ex021">21</a></b>
</p>
</div>

<p>
It does not compile. Typical error is, which is self-explanatory:
</p>
<pre class="verbatim">
constexpr_static.cpp:3:16:
error: static variable not permitted in a constexpr
      function
    static int value = n;
               ^
constexpr_static.cpp:9:9:
error: variables defined in a constexpr function must
      be initialized
    int a;
        ^
2 errors generated.


</pre>
<!--................................-->
<h4 id="autosec-246">constexpr vs member function revisited</h4>
<a id="index-autopage-246"></a>


<a id="ex022"></a>



<div class="center">

<p>
<b>** Question 22&#x2003;&#x2003;constexpr vs member function revisited</b>
</p>
</div>

<a id="autoid-25" ></a >

<p>
Is this code valid in C++14 ?
</p>
<pre class="programlisting">
1 struct S
2{
3     constexpr const int &amp;f();
4     int &amp;f();
5 };
</pre>

<a id="ex022-Answer"></a>



<div class="center">

<p>
<b><span class="textsc">Solution</span> <a href="C-14-FAQs.html#ex022">22</a></b>
</p>
</div>

<p>
It was valid in C++11, but no more valid in C++14 because <em>constexpr</em> non-static member functions are not implicitly const member functions anymore.
</p>

<p>
Rationale behind this change was <em>to allow constexpr member functions to mutate the object</em>.
</p>

<p>
So the error is because it declares the same member function twice with different return types.
</p>

<p>
Typical error is, which is self-explanatory:
</p>
<pre class="verbatim">
constexpr_memfn.cpp:4:10:
error: functions that differ only in their return type
      cannot be overloaded
    int &f();
         ^
constexpr_memfn.cpp:3:26: note: previous declaration is here
    constexpr const int &f();
                         ^
1 error generated.


</pre>
<!--................................-->
<h4 id="autosec-249">deprecated attribute</h4>
<a id="index-autopage-249"></a>


<a id="ex023"></a>



<div class="center">

<p>
<b>** Question 23&#x2003;&#x2003;deprecated attribute</b>
</p>
</div>

<a id="autoid-26" ></a >

<p>
Describe a mechanism to mark the usage of the class \(A\) and the function \(func1\) deprecated.
</p>
<pre class="programlisting">
1 class A1 {};
2
3 void func1() {}
4
5 int main()
6{
7     A1 a;
8     func1();
9}
</pre>

<a id="ex023-Answer"></a>



<div class="center">

<p>
<b><span class="textsc">Solution</span> <a href="C-14-FAQs.html#ex023">23</a></b>
</p>
</div>

<p>
C++14 introduced an attribute <em>[[deprecated]]</em> to do the needful. So we can rewrite the above code as:
</p>
<pre class="programlisting">
1 class [[deprecated]] A1 {};
2
3 [[ deprecated]]
4 void func1() {}
5
6 int main()
7{
8      A1 a;
9      func1();
10 }
</pre>

<p>
Compiler diagnostic messages with clang 3.5 trunk :
</p>
<pre class="verbatim">
deprecated_attribute.cpp:8:5: warning: 'A1' is deprecated
       [-Wdeprecated-declarations]
    A1 a;
    ^
deprecated_attribute.cpp:1:22:
note: 'A1' has been explicitly marked deprecated
       here
class [[deprecated]] A1 {};
                       ^
deprecated_attribute.cpp:9:5: warning: 'func1' is deprecated
       [-Wdeprecated-declarations]
    func1();
    ^
deprecated_attribute.cpp:4:6:
note: 'func1' has been explicitly marked
       deprecated here
void func1() {}
     ^
2 warnings generated.


</pre>

<p>
With gcc 4.9 trunk:
</p>
<pre class="verbatim">
deprecated_attribute.cpp: In function ‘int main()’:
deprecated_attribute.cpp:8:8:
warning: ‘A1’ is deprecated
(declared at deprecated_attribute.cpp:1)
[-Wdeprecated-declarations]
     A1 a;
        ^
deprecated_attribute.cpp:9:5:
warning: ‘void func1()’ is deprecated
(declared at deprecated_attribute.cpp:4)
[-Wdeprecated-declarations]
     func1();
     ^
deprecated_attribute.cpp:9:11:
warning: ‘void func1()’ is deprecated
(declared at deprecated_attribute.cpp:4)
 [-Wdeprecated-declarations]
     func1();
           ^


</pre>

<p>
The diagnostic message can be customized by passing a literal string as an argument to <em>[[deprecated]]</em> like:
</p>
<pre class="programlisting">
1 class [[deprecated(”Usage of class A is deprecated. Please class X instead.”)]] A1 {};
2
3 [[ deprecated(”Usage of func1 is deprecated. Please use func2 instead.”)]]
4 void func1() {}
5
6 int main()
7{
8      A1 a;
9      func1();
10 }
</pre>

<p>
gcc 4.9 trunk yields now:
</p>
<pre class="verbatim">
deprecated_attribute_msg.cpp: In function ‘int       main()’:
deprecated_attribute_msg.cpp:8:8:
warning: ‘A1’ is deprecated
(declared at deprecated_attribute_msg.cpp:1):
Usage of class A is deprecated. Please class X       instead.
[-Wdeprecated-declarations]
     A1 a;
        ^
deprecated_attribute_msg.cpp:9:5:
warning: ‘void func1()’ is deprecated
(declared at deprecated_attribute_msg.cpp:4):
Usage of func1 is deprecated. Please use func2       instead.
[-Wdeprecated-declarations]
     func1();
     ^
deprecated_attribute_msg.cpp:9:11:
warning: ‘void func1()’ is deprecated
(declared at deprecated_attribute_msg.cpp:4):
Usage of func1 is deprecated. Please use func2       instead.
[-Wdeprecated-declarations]
     func1();
           ^


</pre>

<p>
The attribute-token <em>deprecated</em> can be used to mark names and entities whose use is still allowed, but is discouraged for some reason.
</p>

<p>
The attribute may be applied to the declaration of
</p>
<ul style="list-style-type:none">


<li>
<p>
• a class,
</p>


</li>
<li>


<p>
• a typedef-name,
</p>


</li>
<li>


<p>
• a variable,
</p>


</li>
<li>


<p>
• a non-static data member,
</p>


</li>
<li>


<p>
• a function,
</p>


</li>
<li>


<p>
• an enumeration, or
</p>


</li>
<li>


<p>
• a template specialization.
</p>
</li>
</ul>

<p>
A name or entity declared without the <em>deprecated</em> attribute can later be redeclared with the attribute and vice-versa.
</p>
<pre class="programlisting">
1 class A;
2 class [[deprecated]] A;
3
4 class A{};
5
6 int main()
7{
8     A a;
9}
</pre>

<p>
Compiler issues proper diagnostic.
</p>

<p>
Thus, an entity initially declared without the attribute can be marked as deprecated by a subsequent redeclaration.
</p>

<p>
However, after an entity is marked as deprecated, later redeclarations do not un-deprecate the entity.
</p>

<p>
So for the code below, compiler still issues the relevant diagnostics:
</p>
<pre class="programlisting">
1 class [[deprecated]] A;
2 class A;
3
4 class A{};
5
6 int main()
7{
8     A a;
9}
</pre>

<p>
Redeclarations using different forms of the attribute, with or without the attribute-argument-clause or with different attribute-argument-clauses) are allowed.
</p>
<pre class="programlisting">
1 class [[deprecated]] A;
2 class [[deprecated(”Do not use A.”)]] A;
3 class [[deprecated(”A is dangerous.”)]] A;
4
5 class A{};
6
7 int main()
8{
9     A a;
10 }
</pre>

<p>
Compiler issues diagnostic message for the last one :
</p>
<pre class="verbatim">
deprecated_redeclare.cpp:9:5:
warning: 'A' is deprecated: A is dangerous.
      [-Wdeprecated-declarations]
    A a;
    ^
deprecated_redeclare.cpp:5:7:
note: 'A' has been explicitly marked deprecated
      here
class A{};
      ^
1 warning generated.



</pre>

</section>

</main>

</div>

<footer>

<p>
<a href="The-Boost-C-Libraries-Generic-Programming.html" class="linkhome" >
Next</a>
</p>

</footer>



<nav class="botnavigation"><a href="index.html" class="linkhome" >
Home</a></nav>

</body>
</html>
