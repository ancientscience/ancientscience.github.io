
<!DOCTYPE html>
<html lang="en-US">
<head>
<meta charset="UTF-8" />
<meta name="generator" content="LaTeX Lwarp package" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<!--[if lt IE 9]>
<script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
<![endif]-->
<title>Ancient Science Publishers — Solving Problems using Dynamic Programming : A Hacker’s Perspective</title>
<link rel="stylesheet" type="text/css" href="lwarp_sagebrush.css" />

<script>
// Lwarp MathJax emulation code
//
// Based on code by Davide P. Cervone.
// Equation numbering: https://github.com/mathjax/MathJax/issues/2427
// Starred and ifnextchar macros: https://github.com/mathjax/MathJax/issues/2428
// \left, \right delimiters: https://github.com/mathjax/MathJax/issues/2535
//
// Modified by Brian Dunn to adjust equation numbering and add subequations.
//
// LaTeX can use \seteqnumber{subequations?}{section}{number} before each equation.
// subequations? is 0 usually, 1 if inside subequations.
// section is a string printed as-is, or empty.
// number is auto-incremented by MathJax between equations.
//
MathJax = {
   subequations: "0",
   section: "",
   loader: {
      load: ['[tex]/tagformat', '[tex]/textmacros'],
   },
   startup: {
      ready() {
        // These would be replaced by import commands if you wanted to make
        // a proper extension.
        const Configuration = MathJax._.input.tex.Configuration.Configuration;
        const CommandMap = MathJax._.input.tex.SymbolMap.CommandMap;
        const Macro = MathJax._.input.tex.Symbol.Macro;
        const TexError = MathJax._.input.tex.TexError.default;
        const ParseUtil = MathJax._.input.tex.ParseUtil.default;
        const expandable = MathJax._.util.Options.expandable;

           // Insert the replacement string into the TeX string, and check
           // that there haven't been too many maxro substitutions (prevents
           // infinite loops).
           const useArgument = (parser, text) => {
             parser.string = ParseUtil.addArgs(parser, text, parser.string.slice(parser.i));
             parser.i = 0;
             if (++parser.macroCount > parser.configuration.options.maxMacros) {
               throw new TexError('MaxMacroSub1',
               'MathJax maximum macro substitution count exceeded; ' +
               'is there a recursive macro call?');
             }
           }

           // Create the command map for:
           //      \ifstar, \ifnextchar, \ifblank, \ifstrequal, \seteqnumber
           new CommandMap('Lwarp-macros', {
              ifstar: 'IfstarFunction',
              ifnextchar: 'IfnextcharFunction',
              ifblank: 'IfblankFunction',
              ifstrequal: 'IfstrequalFunction',
              seteqnumber: 'SeteqnumberFunction'
           }, {
              // This function implements an ifstar macro.
              IfstarFunction(parser, name) {
                 const resultstar = parser.GetArgument(name);
                 const resultnostar = parser.GetArgument(name);
                 const star = parser.GetStar();                 // true if there is a *
                 useArgument(parser, star ? resultstar : resultnostar);
              },

             // This function implements an ifnextchar macro.
             IfnextcharFunction(parser, name) {
                let whichchar = parser.GetArgument(name);
                if (whichchar.match(/^(?:0x[0-9A-F]+|[0-9]+)$/i)) {
                  // $ syntax highlighting
                  whichchar = String.fromCodePoint(parseInt(whichchar));
                }
                const resultnextchar = parser.GetArgument(name);
                const resultnotnextchar = parser.GetArgument(name);
                const gotchar = (parser.GetNext() === whichchar);
                useArgument(parser, gotchar ? resultnextchar : resultnotnextchar);
             },

             // This function implements an ifblank macro.
             IfblankFunction(parser, name) {
                const blankarg = parser.GetArgument(name);
                const resultblank = parser.GetArgument(name);
                const resultnotblank = parser.GetArgument(name);
                const isblank = (blankarg.trim() == "");
                useArgument(parser, isblank ? resultblank : resultnotblank);
             },

             // This function implements an ifstrequal macro.
             IfstrequalFunction(parser, name) {
                const strequalfirst = parser.GetArgument(name);
                const strequalsecond = parser.GetArgument(name);
                const resultequal = parser.GetArgument(name);
                const resultnotequal = parser.GetArgument(name);
                const isequal = (strequalfirst == strequalsecond);
                useArgument(parser, isequal ? resultequal : resultnotequal);
             },

             // This function modifies the equation numbers.
             SeteqnumberFunction(parser, name) {
                 // Get the macro parameters
                 const star = parser.GetStar();                  // true if there is a *
                 const optBrackets = parser.GetBrackets(name);   // contents of optional brackets
                 const newsubequations = parser.GetArgument(name); // the subequations argument
                 const neweqsection = parser.GetArgument(name); // the eq section argument
                 const neweqnumber = parser.GetArgument(name);   // the eq number argument
                 MathJax.config.subequations=newsubequations ;   // a string with boolean meaning
                 MathJax.config.section=neweqsection ;           // a string with numeric meaning
                 parser.tags.counter = parser.tags.allCounter = neweqnumber ;
             }

           });

           // Create the Lwarp-macros package
           Configuration.create('Lwarp-macros', {
             handler: {macro: ['Lwarp-macros']}
           });

           MathJax.startup.defaultReady();

           // For forward references:
           MathJax.startup.input[0].preFilters.add(({math}) => {
             if (math.inputData.recompile){
                 MathJax.config.subequations = math.inputData.recompile.subequations;
                 MathJax.config.section = math.inputData.recompile.section;
             }
           });
           MathJax.startup.input[0].postFilters.add(({math}) => {
             if (math.inputData.recompile){
                 math.inputData.recompile.subequations = MathJax.config.subequations;
                 math.inputData.recompile.section = MathJax.config.section;
             }
           });

             // For \left, \right with unicode-math:
             const {DelimiterMap} = MathJax._.input.tex.SymbolMap;
             const {Symbol} = MathJax._.input.tex.Symbol;
             const {MapHandler} = MathJax._.input.tex.MapHandler;
             const delimiter = MapHandler.getMap('delimiter');
             delimiter.add('\\lBrack', new Symbol('\\lBrack', '\u27E6'));
             delimiter.add('\\rBrack', new Symbol('\\rBrack', '\u27E7'));
             delimiter.add('\\lAngle', new Symbol('\\lAngle', '\u27EA'));
             delimiter.add('\\rAngle', new Symbol('\\rAngle', '\u27EB'));
             delimiter.add('\\lbrbrak', new Symbol('\\lbrbrak', '\u2772'));
             delimiter.add('\\rbrbrak', new Symbol('\\rbrbrak', '\u2773'));
             delimiter.add('\\lbag', new Symbol('\\lbag', '\u27C5'));
             delimiter.add('\\rbag', new Symbol('\\rbag', '\u27C6'));
             delimiter.add('\\llparenthesis', new Symbol('\\llparenthesis', '\u2987'));
             delimiter.add('\\rrparenthesis', new Symbol('\\rrparenthesis', '\u2988'));
             delimiter.add('\\llangle', new Symbol('\\llangle', '\u2989'));
             delimiter.add('\\rrangle', new Symbol('\\rrangle', '\u298A'));
             delimiter.add('\\Lbrbrak', new Symbol('\\Lbrbrak', '\u27EC'));
             delimiter.add('\\Rbrbrak', new Symbol('\\Rbrbrak', '\u27ED'));
             delimiter.add('\\lBrace', new Symbol('\\lBrace', '\u2983'));
             delimiter.add('\\rBrace', new Symbol('\\rBrace', '\u2984'));
             delimiter.add('\\lParen', new Symbol('\\lParen', '\u2985'));
             delimiter.add('\\rParen', new Symbol('\\rParen', '\u2986'));
             delimiter.add('\\lbrackubar', new Symbol('\\lbrackubar', '\u298B'));
             delimiter.add('\\rbrackubar', new Symbol('\\rbrackubar', '\u298C'));
             delimiter.add('\\lbrackultick', new Symbol('\\lbrackultick', '\u298D'));
             delimiter.add('\\rbracklrtick', new Symbol('\\rbracklrtick', '\u298E'));
             delimiter.add('\\lbracklltick', new Symbol('\\lbracklltick', '\u298F'));
             delimiter.add('\\rbrackurtick', new Symbol('\\rbrackurtick', '\u2990'));
             delimiter.add('\\langledot', new Symbol('\\langledot', '\u2991'));
             delimiter.add('\\rangledot', new Symbol('\\rangledot', '\u2992'));
             delimiter.add('\\lparenless', new Symbol('\\lparenless', '\u2993'));
             delimiter.add('\\rparengtr', new Symbol('\\rparengtr', '\u2994'));
             delimiter.add('\\Lparengtr', new Symbol('\\Lparengtr', '\u2995'));
             delimiter.add('\\Rparenless', new Symbol('\\Rparenless', '\u2996'));
             delimiter.add('\\lblkbrbrak', new Symbol('\\lblkbrbrak', '\u2997'));
             delimiter.add('\\rblkbrbrak', new Symbol('\\rblkbrbrak', '\u2998'));
             delimiter.add('\\lvzigzag', new Symbol('\\lvzigzag', '\u29D8'));
             delimiter.add('\\rvzigzag', new Symbol('\\rvzigzag', '\u29D9'));
             delimiter.add('\\Lvzigzag', new Symbol('\\Lvzigzag', '\u29DA'));
             delimiter.add('\\Rvzigzag', new Symbol('\\Rvzigzag', '\u29DB'));
             delimiter.add('\\lcurvyangle', new Symbol('\\lcurvyangle', '\u29FC'));
             delimiter.add('\\rcurvyangle', new Symbol('\\rcurvyangle', '\u29FD'));
             delimiter.add('\\Vvert', new Symbol('\\Vvert', '\u2980'));
       }     // ready
  },         // startup

  tex: {
    packages: {'[+]': ['tagformat', 'Lwarp-macros', 'textmacros']},
    tags: "ams",
         tagformat: {
             number: function (n) {
                 if(MathJax.config.subequations==0)
                      return(MathJax.config.section + n);
                 else
                      return(MathJax.config.section + String.fromCharCode(96+n));
             },
         },
  }
}
</script>

<script
    id="MathJax-script"
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"
></script>


</head>
<body>



<a id="index-autopage-121"></a>
<nav class="topnavigation"><a href="index.html" class="linkhome" >
Home</a></nav>

<header>

<p>
<a href="Elements-C-20.html" class="linkhome" >
Previous</a>
</p>

</header>



<div class="bodyandsidetoc">
<div class="sidetoccontainer">



<nav class="sidetoc">



<div class="sidetoctitle">

<p>
<span class="sidetocthetitle">Ancient Science Publishers</span>
</p>

<p>
Contents
</p>
</div>



<div class="sidetoccontents">

<p>
<a href="index.html" class="linkhome" >
Home</a>
</p>

<p>
<a href="textcolor-redComputer-Science.html#autosec-9" class="tocpart" >
<span class="sectionnumber">I</span>&#x2003;<span
      class="textcolor"
      style="color:#FF0000"
>Computer Science</span></a>
</p>



<p>
<a href="textcolor-redComputer-Science.html#autosec-10" class="tocchapter" >
<span class="sectionnumber">1</span>&#x2003;Discipline of Competitive Programming : A Hacker’s Perspective</a>
</p>



<p>
<a href="Elements-Coding-Science-Deriving-Correct-Programs.html#autosec-13" class="tocchapter" >
<span class="sectionnumber">2</span>&#x2003;Elements of Coding : Science of Deriving Correct Programs</a>
</p>



<p>
<a href="Elements-Coding-Linear-Algebra-The-Nucleus-Artificial-Intelligence.html#autosec-16" class="tocchapter" >
<span class="sectionnumber">3</span>&#x2003;Elements of Coding Linear Algebra : The Nucleus of Artificial Intelligence</a>
</p>



<p>
<a href="Elements-Software-Design-Patterns.html#autosec-24" class="tocchapter" >
<span class="sectionnumber">4</span>&#x2003;Elements of Software Design Patterns</a>
</p>



<p>
<a href="Elements-Coding-AI.html#autosec-90" class="tocchapter" >
<span class="sectionnumber">5</span>&#x2003;Elements of Coding AI</a>
</p>



<p>
<a href="Elements-Coding-DL-Deep-Learning.html#autosec-92" class="tocchapter" >
<span class="sectionnumber">6</span>&#x2003;Elements of Coding DL (Deep Learning)</a>
</p>



<p>
<a href="Elements-Coding-ML-Internals-Machine-Learning-Library-MLPack.html#autosec-94" class="tocchapter" >
<span class="sectionnumber">7</span>&#x2003;Elements of Coding ML : Internals of Machine Learning Library MLPack</a>
</p>



<p>
<a href="Conceptual-BitCoin-Blockchain-Coding.html#autosec-96" class="tocchapter" >
<span class="sectionnumber">8</span>&#x2003;Conceptual BitCoin : Blockchain Coding</a>
</p>



<p>
<a href="Conceptual-Data-Science-Interviews.html#autosec-98" class="tocchapter" >
<span class="sectionnumber">9</span>&#x2003;Conceptual Data Science Interviews</a>
</p>



<p>
<a href="Conceptual-Dependency-Injection-Unwiring-Simplified-in-C.html#autosec-100" class="tocchapter" >
<span class="sectionnumber">10</span>&#x2003;Conceptual Dependency Injection : Unwiring Simplified in C++</a>
</p>



<p>
<a href="Conceptual-Dynamic-Programming-Optimal-Coding-Simplified.html#autosec-102" class="tocchapter" >
<span class="sectionnumber">11</span>&#x2003;Conceptual Dynamic Programming : Optimal Coding Simplified</a>
</p>



<p>
<a href="Conceptual-Programming-Interviews.html#autosec-104" class="tocchapter" >
<span class="sectionnumber">12</span>&#x2003;Conceptual Programming Interviews</a>
</p>



<p>
<a href="Conceptual-Machine-Learning.html#autosec-106" class="tocchapter" >
<span class="sectionnumber">13</span>&#x2003;Conceptual Machine Learning</a>
</p>



<p>
<a href="Conceptual-Programming-STL-Algorithms.html#autosec-108" class="tocchapter" >
<span class="sectionnumber">14</span>&#x2003;Conceptual Programming of STL Algorithms</a>
</p>



<p>
<a href="Conceptual-Solutions-CLRS-Introduction-Algorithms.html#autosec-110" class="tocchapter" >
<span class="sectionnumber">15</span>&#x2003;Conceptual Solutions to (CLRS) Introduction to Algorithms</a>
</p>



<p>
<a href="Conceptual-Programming-Algorithms-Using-Dijkstra’s-Approach.html#autosec-112" class="tocchapter" >
<span class="sectionnumber">16</span>&#x2003;Conceptual Programming of Algorithms Using Dijkstra’s Approach</a>
</p>



<p>
<a href="Conceptual-Solutions-Pattern-Recognition-Machine-Learning.html#autosec-114" class="tocchapter" >
<span class="sectionnumber">17</span>&#x2003;Conceptual Solutions to Pattern Recognition and Machine Learning</a>
</p>



<p>
<a href="Science-Deriving-Beautiful-Programs.html#autosec-116" class="tocchapter" >
<span class="sectionnumber">18</span>&#x2003;Science of Deriving Beautiful Programs</a>
</p>



<p>
<a href="Modern-C-Ranges-Revolution-in-STL.html#autosec-118" class="tocchapter" >
<span class="sectionnumber">19</span>&#x2003;Modern C++ Ranges : A Revolution in STL</a>
</p>



<p>
<a href="Elements-C-20.html#autosec-120" class="tocchapter" >
<span class="sectionnumber">20</span>&#x2003;Elements of C++20</a>
</p>



<p>
<a href="Solving-Problems-using-Dynamic-Programming-Hacker’s-Perspective.html#autosec-122" class="tocchapter" >
<span class="sectionnumber">21</span>&#x2003;Solving Problems using Dynamic Programming : A Hacker’s Perspective</a>
</p>



<p>
<a href="Hacking-TensorFlow-Internals-An-Insider’s-Commentary-on-Learning-System.html#autosec-153" class="tocchapter" >
<span class="sectionnumber">22</span>&#x2003;Hacking TensorFlow Internals : An Insider’s Commentary on A Learning System</a>
</p>



<p>
<a href="Advanced-C-FAQs-Vol-1-2.html#autosec-155" class="tocchapter" >
<span class="sectionnumber">23</span>&#x2003;Advanced C++ FAQs Vol 1 &amp; 2</a>
</p>



<p>
<a href="C-14-FAQs.html#autosec-157" class="tocchapter" >
<span class="sectionnumber">24</span>&#x2003;C++14 FAQs</a>
</p>



<p>
<a href="The-Boost-C-Libraries-Generic-Programming.html#autosec-257" class="tocchapter" >
<span class="sectionnumber">25</span>&#x2003;The Boost C++ Libraries: Generic Programming</a>
</p>



<p>
<a href="Generic-Algorithms-Data-Structures-using-C-11.html#autosec-259" class="tocchapter" >
<span class="sectionnumber">26</span>&#x2003;Generic Algorithms and Data Structures using C++11</a>
</p>



<p>
<a href="C-11-Standard-Library-Usage-Implementation.html#autosec-261" class="tocchapter" >
<span class="sectionnumber">27</span>&#x2003;C++11 Standard Library: Usage and Implementation</a>
</p>



<p>
<a href="Foundation-Algorithms-in-C-11.html#autosec-263" class="tocchapter" >
<span class="sectionnumber">28</span>&#x2003;Foundation of Algorithms in C++11</a>
</p>



<p>
<a href="C-11-Algorithms-Using-Extending-C-11-Boost-Beyond.html#autosec-265" class="tocchapter" >
<span class="sectionnumber">29</span>&#x2003;C++11 Algorithms : Using and Extending C++11, Boost and Beyond</a>
</p>



<p>
<a href="Cracking-Programming-Interviews-500-Questions-with-Solutions.html#autosec-267" class="tocchapter" >
<span class="sectionnumber">30</span>&#x2003;Cracking Programming Interviews : 500 Questions with Solutions</a>
</p>



<p>
<a href="Top-20-Coding-Interview-Problems-Asked-in-Google-with-Solutions.html#autosec-269" class="tocchapter" >
<span class="sectionnumber">31</span>&#x2003;Top 20 Coding Interview Problems Asked in Google with Solutions</a>
</p>



<p>
<a href="Top-10-Coding-Interview-Problems-Asked-in-Google-with-Solutions.html#autosec-271" class="tocchapter" >
<span class="sectionnumber">32</span>&#x2003;Top 10 Coding Interview Problems Asked in Google with Solutions</a>
</p>



<p>
<a href="Physics.html#autosec-273" class="tocpart" >
<span class="sectionnumber">II</span>&#x2003;Physics</a>
</p>



<p>
<a href="Mathematics.html#autosec-275" class="tocpart" >
<span class="sectionnumber">III</span>&#x2003;Mathematics</a>
</p>



</div>

</nav>

</div>



<main class="bodycontainer">



<section class="textbody">

<h1>Ancient Science Publishers</h1>

<!--MathJax customizations:-->



<div class="hidden">

\(\newcommand{\footnotename}{footnote}\)

\(\def \LWRfootnote {1}\)

\(\newcommand {\footnote }[2][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\newcommand {\footnotemark }[1][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\let \LWRorighspace \hspace \)

\(\renewcommand {\hspace }{\ifstar \LWRorighspace \LWRorighspace }\)

\(\newcommand {\mathnormal }[1]{{#1}}\)

\(\newcommand \ensuremath [1]{#1}\)

\(\newcommand {\LWRframebox }[2][]{\fbox {#2}} \newcommand {\framebox }[1][]{\LWRframebox } \)

\(\newcommand {\setlength }[2]{}\)

\(\newcommand {\addtolength }[2]{}\)

\(\newcommand {\setcounter }[2]{}\)

\(\newcommand {\addtocounter }[2]{}\)

\(\newcommand {\arabic }[1]{}\)

\(\newcommand {\number }[1]{}\)

\(\newcommand {\noalign }[1]{\text {#1}\notag \\}\)

\(\newcommand {\cline }[1]{}\)

\(\newcommand {\directlua }[1]{\text {(directlua)}}\)

\(\newcommand {\luatexdirectlua }[1]{\text {(directlua)}}\)

\(\newcommand {\protect }{}\)

\(\def \LWRabsorbnumber #1 {}\)

\(\def \LWRabsorbquotenumber &quot;#1 {}\)

\(\newcommand {\LWRabsorboption }[1][]{}\)

\(\newcommand {\LWRabsorbtwooptions }[1][]{\LWRabsorboption }\)

\(\def \mathchar {\ifnextchar &quot;\LWRabsorbquotenumber \LWRabsorbnumber }\)

\(\def \mathcode #1={\mathchar }\)

\(\let \delcode \mathcode \)

\(\let \delimiter \mathchar \)

\(\def \oe {\unicode {x0153}}\)

\(\def \OE {\unicode {x0152}}\)

\(\def \ae {\unicode {x00E6}}\)

\(\def \AE {\unicode {x00C6}}\)

\(\def \aa {\unicode {x00E5}}\)

\(\def \AA {\unicode {x00C5}}\)

\(\def \o {\unicode {x00F8}}\)

\(\def \O {\unicode {x00D8}}\)

\(\def \l {\unicode {x0142}}\)

\(\def \L {\unicode {x0141}}\)

\(\def \ss {\unicode {x00DF}}\)

\(\def \SS {\unicode {x1E9E}}\)

\(\def \dag {\unicode {x2020}}\)

\(\def \ddag {\unicode {x2021}}\)

\(\def \P {\unicode {x00B6}}\)

\(\def \copyright {\unicode {x00A9}}\)

\(\def \pounds {\unicode {x00A3}}\)

\(\let \LWRref \ref \)

\(\renewcommand {\ref }{\ifstar \LWRref \LWRref }\)

\( \newcommand {\multicolumn }[3]{#3}\)

\(\require {textcomp}\)

\(\newcommand {\toprule }[1][]{\hline }\)

\(\let \midrule \toprule \)

\(\let \bottomrule \toprule \)

\(\def \LWRbooktabscmidruleparen (#1)#2{}\)

\(\newcommand {\LWRbooktabscmidrulenoparen }[1]{}\)

\(\newcommand {\cmidrule }[1][]{\ifnextchar (\LWRbooktabscmidruleparen \LWRbooktabscmidrulenoparen }\)

\(\newcommand {\morecmidrules }{}\)

\(\newcommand {\specialrule }[3]{\hline }\)

\(\newcommand {\addlinespace }[1][]{}\)

\(\def \LWRpagenote {1}\)

\(\newcommand {\pagenote }[2][\LWRpagenote ]{{}^{\mathrm {#1}}}\)

\(\newcommand {\intertext }[1]{\text {#1}\notag \\}\)

\(\let \Hat \hat \)

\(\let \Check \check \)

\(\let \Tilde \tilde \)

\(\let \Acute \acute \)

\(\let \Grave \grave \)

\(\let \Dot \dot \)

\(\let \Ddot \ddot \)

\(\let \Breve \breve \)

\(\let \Bar \bar \)

\(\let \Vec \vec \)

\(\newcommand {\conceptequiv }{\triangleq }\)

\(\newcommand {\CC }{\mathcal {C}}\)

\(\newcommand {\refines }{\looparrowright }\)

\(\newcommand {\weakens }{\looparrowleft }\)

\(\DeclareMathOperator *{\Max }{Max}\)

\(\DeclareMathOperator *{\Min }{Min}\)

\(\newcommand {\mleft }{\left }\)

\(\newcommand {\mright }{\right }\)

\(\newcommand {\mleftright }{}\)

\(\newcommand {\mleftrightrestore }{}\)

\(\require {physics}\)

\(\newcommand {\bigO }{\mathcal {O}}\)

</div>

<p>
<!--................................-->
<h3 id="autosec-122">Monograph&nbsp;<span class="sectionnumber">21&#x2003;</span>Solving Problems using Dynamic Programming : A Hacker’s Perspective</h3>
<a id="index-autopage-122"></a>
<a id="index-autofile-21"></a>
<div class="marginblock" role="note" style="width:217pt; float:right; ">
<div class="center">

<p>


<a href="solvingdpp/cover/dpp-cover.svg" target="_blank" ><img
      src="solvingdpp/cover/dpp-cover.svg"
      style="
      width:217pt;
      "
      class="inlineimage"
      alt="(image)"
></a>
</p>
</div>

</div>

<p>
<span style="width:14pt; display:inline-block"><!----></span>A hacker’s approach to a coding problem is beyond the foundational aspect of underlying genetic and computational
structures, often termed as \(\color {Orange}\mathbf {\pi ^\infty }\).
</p>

<p>
<span style="width:14pt; display:inline-block"><!----></span>A concept becomes <span
      class="textcolor"
      style="color:#9E00FF"
><em>not difficult</em></span> because the <span
      class="textcolor"
      style="color:#9E00FF"
><em>complexities</em></span> built into it are clarified. In a bid to reach the <span
      class="textcolor"
      style="color:#9E00FF"
><em>core</em></span> of the problem, the concept is split-broken into fragments, <span
      class="textcolor"
      style="color:#9E00FF"
><em>complexities</em></span> are exposed and <span
      class="textcolor"
      style="color:#9E00FF"
><em>delicate</em></span> points are examined. Then the concept is <span
      class="textcolor"
      style="color:#9E00FF"
><em>recomposed</em></span> to make it integral and as a result, this reintegrated concept becomes sufficiently simple and comprehensible.
</p>

<p>
<span style="width:14pt; display:inline-block"><!----></span>This helps build a hacker’s insight to reveal the internal structure and internal logic of the concepts, algorithms and
mathematical theorems.
</p>

<p>
This book provides a hacker’s perspective to solving problems using dynamic programming. Written in an extremely lively form of problems and solutions (including code in modern C++ and pseudo
style), this leads to extreme simplification of optimal coding with great emphasis on unconventional and integrated science of dynamic Programming. Though aimed primarily at serious
programmers, it imparts the knowledge of deep internals of underlying concepts and beyond to computer scientists alike.
</p>

<p>
Ancient Science Publishers &#x2003;&#x2003;<em>Chandra Shekhar Kumar</em>
</p>

<p>
July, 2020. &#x2003;&#x2003;256 pages &#x2003;&#x2003;ISBN 9781722497170
</p>
<blockquote>

<p>
<span style="width:14pt; display:inline-block"><!----></span><span
      class="textcolor"
      style="color:#9E00FF"
><em>Beautiful (C++) code snippets. Unique yogic exposition to coding.</em></span>
</p>
</blockquote>

<p>
&#x2003;&#x2003;Ancient   Science Hackers
</p>

<p>
<span class="underline"><b><span
      class="textcolor"
      style="color:#FF7D00"
>Excerpt from the Chapter</span> <span
      class="textcolor"
      style="color:#4D0000"
>(Optimal Loot Partition):</span></b></span>
</p>
<div class="amsthmbodyproblemstyle">

<ul style="list-style-type:none">



<li>
<p>
<a id="index-autopage-127"></a>
<span class="amsthmnameproblemstyle"><b>§ Problem</b></span>. <span
      class="textcolor"
      style="color:#9E00FF"
><em>The head of a gang of robbers embarks on distribution of the looted amount \(l (&gt; 0)\), starting with division into two parts : \(x\) and \(l - x\) for \(0 \le x \le l\). From \(x\) : they
get a return of \(u(x)\) such that they are left with a lesser amount \(\alpha x\) : \(0 &lt; \alpha &lt; 1\) and from \(l - x\) : a return of \(v(l - x)\) such that they are left with a lesser
amount \(\beta (l - x)\) : \(0 &lt; \beta &lt; 1\). So the total amount left after the first step of division is \(\alpha x + \beta (l - x)\) and the process continues. Devise the partition
strategy to help them maximize the return obtained in a finite \(n\) or infinite number of steps.</em></span> <span class="theoremendmark">♢</span>
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="index-autopage-128"></a>

<ul style="list-style-type:none">



<li>
<p>
<span class="amsthmproofname"><em><b> §§ Solution</b></em>.</span> Let \(y(x)\) denote the return after the first step:
</p>
<span class="hidden"> \(\seteqnumber{0}{21.}{0}\)</span>



<!--




                                                                                                         ∴ y(x) = u(x) + v(l − x)




-->



<p>


\begin{gather*}
\therefore y(x) = u(x) + v(l - x)
\end{gather*}
Assuming \(u\) and \(v\) to be continuous functions, it is trivial to find the maximum of \(y(x)\) over \(x \in [0, l]\) using calculus (or graphical approach) :
</p>
<span class="hidden"> \(\seteqnumber{0}{21.}{0}\)</span>



<!--



                                                                                        dy    d         d
                                                                                           =    u(x) +    v(l − x) = 0 (for extrema).
                                                                                        dx   dx        dx



-->



<p>


\begin{gather*}
\dfrac {d y}{d x} = \dfrac {d}{d x} u(x) + \dfrac {d}{d x} v(l - x) = 0 \text { (for extrema)}.
\end{gather*}
Solve for \(x\) and \(y(x)\) is maximum for that \(x\) for which \(\dfrac {d^2 y}{d x^2} &lt; 0\).
</p>

<p>
Suppose \(u(x) = x\) and \(v(l - x) = -(l - x)^2 \), then
</p>
<span class="hidden"> \(\seteqnumber{0}{21.}{0}\)</span>



<!--




                                                                                                               y = x − (l − x)2
                                                                                                       dy
                                                                                                         ∴ = 1 + 2(l − x) = 0,
                                                                                                       dx
                                                                                                                      1
                                                                                                           ∴x=l+ .
                                                                                                                      2
                                                                                                          d2 y
                                                                                                               = −2 < 0.
                                                                                                          dx2
                                                                                                                 1 1          1
                                                                                                   ∴ ymax = l + − = l + .
                                                                                                                 2 4          4



-->



<p>


\begin{gather*}
y = x - (l - x)^2 \\ \therefore \dfrac {d y}{d x} = 1 + 2(l - x) = 0, \\ \therefore x = l + \dfrac {1}{2}.\\ \dfrac {d^2 y}{d x^2} = -2 &lt; 0. \\ \therefore
y_{max} = l + \dfrac {1}{2} - \dfrac {1}{4} = l + \dfrac {1}{4}.
\end{gather*}
After the first step, the initial amount \(l\) is reduced to \(l_1\)(say):
</p>
<span class="hidden"> \(\seteqnumber{0}{21.}{0}\)</span>



<!--




                                                                                                             ∴ l1 = αx + β(l − x)




-->



<p>


\begin{gather*}
\therefore l_1 = \alpha x + \beta (l - x)
\end{gather*}
In the second step, \(l_1\) is partitioned into \(x_1\) (say) and \((l_1 - x_1)\) for \(0 \le x_1 \le l_1\). Hence, the return from the second step is \(u(x_1) + v(l_1 - x_1)\). Therefore, the
total return after the two steps is:
</p>
<span class="hidden"> \(\seteqnumber{0}{21.}{0}\)</span>



<!--




                                                                                       ∴ y(x, x1 ) = u(x) + v(l − x) + u(x1 ) + v(l1 − x1 ).




-->



<p>


\begin{gather*}
\therefore y(x, x_1) = u(x) + v(l - x) + u(x_1) + v(l_1 - x_1).
\end{gather*}
Maximum of the function \(y(x, x_1)\) over the 2-dimensional space \((x, x_1)\) yields the maximum return, such that \(x \in [0, l]\) and \(x_1 \in [0, l_1]\).
</p>

<p>
Similarly, the total return after \(n\) steps is :
</p>
<span class="hidden"> \(\seteqnumber{0}{21.}{0}\)</span>



<!--



                                                                                                                                    ∑
                                                                                                                                    n−1
                                                                             ∴ y(x, x1 , x2 , . . . , xn−1 ) = u(x) + v(l − x) +          [u(xi ) + v(li − xi )] .                                  (21.1)
                                                                                                                                    i=1




-->



<p>


\begin{gather}
\therefore y(x, x_1, x_2, \ldots , x_{n - 1}) = u(x) + v(l - x) + \sum _{i=1}^{n - 1}\left [u(x_i) + v(l_i - x_i)\right ].
\end{gather}


</p>

<p>
Here \(x_i \in [0, l_i]\).
</p>

<p>
Using this <em>enumerative</em> approach to maximize the \(n\)-dimen-sional return, the computation procedure soon becomes cumbersome, error-prone and exponential in nature.
</p>

<p>
Any choice of \(x, x_1, x_2, \ldots \) is a <em>policy</em>.
</p>

<p>
The policy maximizing \(y(x, x_1, x_2, \ldots )\) is an <em>optimal policy</em>.
</p>

<p>
It can be noted that each step depends on the respective policy only. Hence at the \((i + 1)^{th}\) step, the corresponding <em>one-dimensional</em> choice is made : a choice of \(x_i \in [0,
l]\).
</p>

<p>
Hence an optimal policy leads to the corresponding maximum return.
</p>

<p>
Let \(y_n (l)\) denote the maximum total return, given the initial amount \(l\) and n steps.
</p>
<span class="hidden"> \(\seteqnumber{0}{21.}{1}\)</span>



<!--




                                                                                                 ∴ y1 (l) = Max [u(x) + v(l − x)] .
                                                                                                                x∈[0,l]




-->



<p>


\begin{gather*}
\therefore y_1 (l) = \Max \limits _{x \in [0, l]} \left [u(x) + v(l - x)\right ].
\end{gather*}
After the first step, \(l\) becomes \(\alpha x + \beta (l - x)\) :
</p>
<span class="hidden"> \(\seteqnumber{0}{21.}{1}\)</span>



<!--




                                                                                     ∴ y2 (l) = Max [u(x) + v(l − x) + y1 (αx + β(l − x))] .
                                                                                                x∈[0,l]




-->



<p>


\begin{gather*}
\therefore y_2 (l) = \Max \limits _{x \in [0, l]} \left [u(x) + v(l - x) + y_1\left (\alpha x + \beta (l - x)\right ) \right ].
\end{gather*}
This leads to a recurrence relation :
</p>
<span class="hidden"> \(\seteqnumber{0}{21.}{1}\)</span>



<!--




                                                                                   ∴ yn (l) = Max [u(x) + v(l −(21.2)
                                                                                                                x) + yn−1 (αx + β(l − x))] .                         --><a id="lootpartition:e1"></a><!--
                                                                                               x∈[0,l]




-->



<p>


\begin{gather}
\therefore y_n (l) = \Max \limits _{x \in [0, l]} \left [u(x) + v(l - x) + y_{n - 1} \left (\alpha x + \beta (l - x)\right ) \right ] . \label {lootpartition:e1}
\end{gather}


</p>

<p>
Hence a single \(n\)-dimensional problem is reduced to a sequence of \(n\) one-dimensional problems.
</p>

<p>
Here, the optimal return depends on the initial amount \(l\) and initial decision of division into the parts \(l\) and \(l - x\) only.
</p>

<p>
This is possible due to <b><span
      class="textcolor"
      style="color:#808000"
>the Principle of Optimality</span></b> :
</p>
<blockquote>

<p>
<span
      class="textcolor"
      style="color:#9E00FF"
><em>An optimal policy has the property that whatever the initial state and initial decision are, the remaining decisions must constitute an optimal policy with regard to the state resulting from the
first decision.</em></span>
</p>
</blockquote>

<p>
Hence&nbsp;Eq. <span class="textup">(<a href="Solving-Problems-using-Dynamic-Programming-Hacker’s-Perspective.html#lootpartition:e1">21.2</a>)</span> is the
required optimal strategy. <span class="theoremendmark">&#x220E;</span>
</p>

</li>

</ul>

</div>

<p>
<span class="underline"><b><span
      class="textcolor"
      style="color:#FF7D00"
>Excerpt from the Chapter</span> <span
      class="textcolor"
      style="color:#4D0000"
>(Constrained Subsequence):</span></b></span>
</p>
<!--................................-->
<h4 id="autosec-130">Maximum Sum</h4>
<a id="index-autopage-130"></a>
<div class="amsthmbodyproblemstyle">

<ul style="list-style-type:none">



<li>
<p>
<a id="index-autopage-131"></a>
<span class="amsthmnameproblemstyle"><b>§ Problem</b></span>. <a id="maxsubarray : sum"></a> Given a sequence of \(n \in (-\infty , \; \infty )\) integers, determine the
largest possible sum of the contiguous subsequence. <span class="theoremendmark">♢</span>
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="index-autopage-132"></a>

<ul style="list-style-type:none">



<li>
<p>
<span class="amsthmproofname"><em><b> §§ Solution</b></em>.</span> Let \(f_n(i)\) be the maximum sum of a contiguous subsequence ending at index \(i\), obtained using an optimal
policy and \(n\) steps.
</p>

<p>
Let \(s_i\) be the value of the element at index \(i\), i.e. \(s_i\) is used at the \(n^{th}\) step. The we can use an optimal policy starting with previously accumulated maximum sum of a contiguous
subsequence ending at index \(i-1\).
</p>

<p>
Hence the required optimal procedure is
</p>
<span class="hidden"> \(\seteqnumber{0}{21.}{2}\)</span>



<!--




                                                                                     ∴ fn (i) =     Max        [fn−1 (i − 1) + si ]
                                                                                                  i∈[0, n−1]




-->



<p>


\begin{align*}
\therefore f_n(i) &amp;= \Max \limits _{i \in [0, \; n-1]} \left [f_{n-1}(i-1) + s_i\right ]
\end{align*}


</p>

<p>
At each step (with addition of \(s_i\)), there are 2 options :
</p>
<ul style="list-style-type:none">


<li>
<p>
1. leverage the previous accumulated maximum sum if<br />
\(f_{n-1}(i-1) + s_i &gt; 0\), because it is better to continue with a positive running sum or
</p>


</li>
<li>


<p>
2. start afresh with a new range (with the starting sum as 0) if \(f_{n-1}(i-1) + s_i &lt; 0\), because it is better to start with 0 than continuing with a negative running sum.
</p>
</li>
</ul>

<p>
Also note that:
</p>
<ul style="list-style-type:none">


<li>
<p>
• If all the elements are negative, then there is no such subsequence, i.e. the required sum is 0.
</p>


</li>
<li>


<p>
• If all the elements are positive, then the entire sequence is the required subsequence, i.e. the required sum is the sum of all the elements of the sequence.
</p>


</li>
<li>


<p>
• The required subsequence (if any) starts at and ends with a positive value.
</p>
</li>
</ul>

<figure id="autoid-1" class="figure ">
<div class="center">

<p>
<span
      class="fbox"
      style="display:inline-block ; border:1pt solid #000000; padding:3pt ; color:#000000"
><b><span
      class="textcolor"
      style="color:#808000"
>Maximum sum contiguous subsequence : compute sum</span></b></span>
</p>
</div>
<ul style="list-style-type:none">


<li>
<p>
1: <span style="width:0pt; display:inline-block;"></span><b>function</b> <span class="textsc">maxseq</span>(\(s[0..n-1]\))
</p>


</li>
<li>


<p>
2:     <span style="width:15pt; display:inline-block;"></span>\(currentsum \gets 0\)
</p>


</li>
<li>


<p>
3:     <span style="width:15pt; display:inline-block;"></span>\(maxsum \gets 0\)
</p>


</li>
<li>


<p>
4:     <span style="width:15pt; display:inline-block;"></span><b>for</b> \(x \in s[0 .. n-1]\) <b>do</b>
</p>


</li>
<li>


<p>
5:       <span style="width:30pt; display:inline-block;"></span>\(currentsum \gets \) <b>max</b>\((currentsum + x, 0)\)
</p>


</li>
<li>


<p>
6:       <span style="width:30pt; display:inline-block;"></span>\(maxsum \gets \) <b>max</b>\((maxsum, currentsum)\)
</p>


</li>
<li>


<p>
7:     <span style="width:15pt; display:inline-block;"></span><b>end</b> <b>for</b>
</p>


</li>
<li>


<p>
8:     <span style="width:15pt; display:inline-block;"></span><b>return</b> \(maxsum\)
</p>


</li>
<li>


<p>
9: <span style="width:0pt; display:inline-block;"></span><b>end</b> <b>function</b>
</p>
</li>
</ul>

</figure>

<p>
Time complexity is \(\bigO (n)\). Space complexity is \(\bigO (1)\).
</p>
<pre class="programlisting">
1 int   maxseq(std::vector&lt;int&gt; &amp; s)
2{
3       int current_sum = 0;
4       int max_sum = 0;
5
6       for(int x : s)
7       {
8           current_sum = std::max(current_sum + x, 0);
9           max_sum = std::max(max_sum, current_sum);
10        }
11        return max_sum;
12 }
</pre>

<p>
<span class="theoremendmark">&#x220E;</span>
</p>

</li>

</ul>

</div>
<!--................................-->
<h4 id="autosec-135">Circular Sequence</h4>
<a id="index-autopage-135"></a>
<div class="amsthmbodyproblemstyle">

<ul style="list-style-type:none">



<li>
<p>
<a id="index-autopage-136"></a>
<span class="amsthmnameproblemstyle"><b>§ Problem</b></span>. <a id="maxcircular:p1"></a> Given a circular sequence \(s\) of \(n \in (-\infty , \infty )\) integers, find the
maximum possible sum of a non-empty contiguous subsequence of \(s\). <span class="theoremendmark">♢</span>
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="index-autopage-137"></a>

<ul style="list-style-type:none">



<li>
<p>
<span class="amsthmproofname"><em><b> §§ Solution</b></em>.</span> The end of a circular sequence wraps around the start of the sequence itself, i.e.
</p>
<span class="hidden"> \(\seteqnumber{0}{21.}{2}\)</span>



<!--




                                                                              ∵ i ≡ (i + n) mod n ∀i ∈ [0, n)
                                                                               ∴ si ≡ s(i+n) mod n   ∀i ∈ [0, n).




-->



<p>


\begin{gather*}
\because i \equiv (i + n) \; \mathbf {mod} \; n \quad \forall i \in [0, n) \\ \therefore s_i \equiv s_{(i+n) \; \mathbf {mod} \; n} \quad \forall i \in [0, n).
\end{gather*}


</p>
<div class="center">

<p>
<span
      id="lateximage-index-30"
      class="lateximagesource"
><!--
s0    s1    ...    si    ...   sn−1
sn   sn+1   ...   sn+i   ...   s2n−1
--><img
      src="index-images/image-30.svg"
      alt="(-tikz-&nbsp;diagram)"
      style=""
      class="lateximage"
></span>
</p>
</div>

<p>
For a maximum contiguous subsequence \(\mleft [s_i \cdots s_j\mright ]\), the solution of&nbsp;Dialogue&nbsp;<a
href="Solving-Problems-using-Dynamic-Programming-Hacker’s-Perspective.html#maxsubarray : sum">21</a> can be used.
</p>
<div class="center">

<p>
<span
      id="lateximage-index-31"
      class="lateximagesource"
><!--
s0   ···   si   si+1 · · · sj−1 sj   · · · sn−1

           max subsequence
--><img
      src="index-images/image-31.svg"
      alt="(-tikz-&nbsp;diagram)"
      style=""
      class="lateximage"
></span>
</p>
</div>

<p>
For a maximum contiguous subsequence \(\mleft [s_j \cdots s_{n-1}, s_0 \cdots s_i\mright ]\), the left-over part \(\mleft [s_{i+1} \cdots s_{j-1}\mright ]\) forms a minimum
contiguous subsequence.
</p>
<div class="center">

<p>
<span
      id="lateximage-index-32"
      class="lateximagesource"
><!--
                  min subsequence


  s0   ···   si   si+1 · · · sj−1 sj   · · · sn−1

max subseq part 2               max subseq part 1
--><img
      src="index-images/image-32.svg"
      alt="(-tikz-&nbsp;diagram)"
      style=""
      class="lateximage"
></span>
</p>
</div>

<p>
Summation of the contiguous subsequence<br />
\(\mleft [s_j \cdots s_{n-1}, s_0 \cdots s_i\mright ]\) is
</p>
<span class="hidden"> \(\seteqnumber{0}{21.}{2}\)</span>



<!--




                                                                            = sj + · · · + sn−1 + s0 + · · · + si
                                                                            = s0 + · · · + sn−1 − [si+1 + · · · + sj−1 ]




-->



<p>


\begin{align*}
&amp;= s_j + \cdots + s_{n-1} + s_0 + \cdots + s_i \\ &amp;= s_0 + \cdots + s_{n-1} - \mleft [s_{i+1} + \cdots + s_{j-1} \mright ]
\end{align*}
This is maximum when \(\mleft [s_{i+1} + \cdots + s_{j-1} \mright ]\) is minimum.
</p>
<span class="hidden"> \(\seteqnumber{0}{21.}{2}\)</span>



<!--



                                                                                                              ∑
                                                                                                             k=n−1               ∑
                                                                                                                                k=j−1
                                                             ∴ Max[sj + · · · + sn−1 + s0 + · · · + si ] =           sk − Min           sk
                                                                                                              k=0               k=i+1

                                                           ∴ Maximum sum subsequence = Total sum of the sequence
                                                                                                 − Minimum sum subsequence




-->



<p>


\begin{gather*}
\therefore \Max \mleft [s_j + \cdots + s_{n-1} + s_0 + \cdots + s_i\mright ] = \sum \limits _{k=0}^{k=n-1} s_k - \Min \sum \limits _{k=i+1}^{k=j-1} s_k \\
\therefore \text {Maximum sum subsequence } = \text { Total sum of the sequence } \\ \quad \quad \quad \qq {}\qq {}\qq {} \qq {}\qq {}\qq {} - \text { Minimum
sum subsequence}
\end{gather*}


</p>

<figure id="autoid-2" class="figure ">
<div class="center">

<p>
<span
      class="fbox"
      style="display:inline-block ; border:1pt solid #000000; padding:3pt ; color:#000000"
><b><span
      class="textcolor"
      style="color:#808000"
>Maximum sum circular subsequence</span></b></span>
</p>
</div>
<ul style="list-style-type:none">


<li>
<p>
1: <span style="width:0pt; display:inline-block;"></span><b>function</b> <span class="textsc">maxcircularseq</span>(\(s[0..n-1]\))
</p>


</li>
<li>


<p>
2:     <span style="width:15pt; display:inline-block;"></span>\(currentmax \gets 0\)
</p>


</li>
<li>


<p>
3:     <span style="width:15pt; display:inline-block;"></span>\(maxsum \gets -\infty \)
</p>


</li>
<li>


<p>
4:     <span style="width:15pt; display:inline-block;"></span>\(currentmin \gets 0\)
</p>


</li>
<li>


<p>
5:     <span style="width:15pt; display:inline-block;"></span>\(minsum \gets \infty \)
</p>


</li>
<li>


<p>
6:     <span style="width:15pt; display:inline-block;"></span>\(totalsum \gets 0\)
</p>


</li>
<li>


<p>


</p>


</li>
<li>


<p>
7:     <span style="width:15pt; display:inline-block;"></span><b>for</b> \(x \in s[0 .. n-1]\) <b>do</b>
</p>


</li>
<li>


<p>
8:       <span style="width:30pt; display:inline-block;"></span>\(currentmax \gets \) <b>max</b>\((currentmax + x, x)\)
</p>


</li>
<li>


<p>
9:       <span style="width:30pt; display:inline-block;"></span>\(maxsum \gets \) <b>max</b>\((maxsum, currentmax)\)
</p>


</li>
<li>


<p>


</p>


</li>
<li>


<p>
10:       <span style="width:30pt; display:inline-block;"></span>\(currentmin \gets \) <b>min</b>\((currentmin + x, x)\)
</p>


</li>
<li>


<p>
11:       <span style="width:30pt; display:inline-block;"></span>\(minsum \gets \) <b>min</b>\((minsum, currentmin)\)
</p>


</li>
<li>


<p>


</p>


</li>
<li>


<p>
12:       <span style="width:30pt; display:inline-block;"></span>\(totalsum \gets totalsum + x\)
</p>


</li>
<li>


<p>
13:     <span style="width:15pt; display:inline-block;"></span><b>end</b> <b>for</b>
</p>


</li>
<li>


<p>


</p>


</li>
<li>


<p>
14:     <span style="width:15pt; display:inline-block;"></span><b>if</b> \(totalsum == minsum\) <b>then</b> <span class="floatright">&#x25B7; All elements are -ve</span>
</p>


</li>
<li>


<p>
15:       <span style="width:30pt; display:inline-block;"></span><b>return</b> \(maxsum\) <span class="floatright">&#x25B7; Value of the least -ve element</span>
</p>


</li>
<li>


<p>
16:     <span style="width:15pt; display:inline-block;"></span><b>else</b>
</p>


</li>
<li>


<p>
17:       <span style="width:30pt; display:inline-block;"></span><b>return</b> <b>max</b>\((maxsum, \; totalsum - minsum)\)
</p>


</li>
<li>


<p>
18:     <span style="width:15pt; display:inline-block;"></span><b>end</b> <b>if</b>
</p>


</li>
<li>


<p>
19: <span style="width:0pt; display:inline-block;"></span><b>end</b> <b>function</b>
</p>
</li>
</ul>

</figure>

<p>
Time complexity is \(\bigO (n)\). Space complexity is \(\bigO (1)\).
</p>
<pre class="programlisting">
1 int   maxsum_circular(std::vector&lt;int&gt; &amp; s)
2{
3       int current_max = 0, max_sum = std::numeric_limits&lt;int&gt;::min();
4       int current_min = 0, min_sum = std::numeric_limits&lt;int&gt;::max();
5       int total_sum = 0;
6
7       for(int x : s)
8       {
9           current_max = std::max(current_max + x, x);
10           max_sum = std::max(max_sum, current_max);
11
12          current_min = std::min(current_min + x, x);
13          min_sum = std::min(min_sum, current_min);
14
15           total_sum += x;
16       }
17       // when all elements are −ve =&gt; total_sum == min_sum,
18       // i .e. total_sum − min_sum becomes 0 =&gt; empty subsequence
19       // but max_sum still holds the value of the least −ve element,
20       // hence return this singleton than an empty one
21       return total_sum == min_sum ? max_sum : std::max(max_sum, total_sum − min_sum);
22 }
</pre>

<p>
<span class="theoremendmark">&#x220E;</span>
</p>

</li>

</ul>

</div>
<!--................................-->
<h4 id="autosec-149">Brief Table of Contents</h4>
<a id="index-autopage-149"></a>



<ul style="list-style-type:none">


<li>
<p>
1. Genesis
</p>
<ul style="list-style-type:none">


<li>
<p>
a) Optimal Loot Partition
</p>
<ul style="list-style-type:none">


<li>
<p>
i. Deterministic
</p>


</li>
<li>


<p>
ii. Stochastic
</p>
</li>
</ul>
</li>
<li>


<p>
b) Exam Prep
</p>


</li>
<li>


<p>
c) Optimal Coin Tossing
</p>


</li>
<li>


<p>
d) Proving Optimality Principle
</p>
</li>
</ul>
</li>
<li>


<p>
2. Computation
</p>
<ul style="list-style-type:none">


<li>
<p>
a) Ascension to Heaven
</p>


</li>
<li>


<p>
b) Fibonacci Line Search
</p>


</li>
<li>


<p>
c) Coin Change
</p>


</li>
<li>


<p>
d) Constrained Subsequence
</p>
<ul style="list-style-type:none">


<li>
<p>
i. Maximum Sum
</p>


</li>
<li>


<p>
ii. Minimum Sum
</p>


</li>
<li>


<p>
iii. Circular Sequence
</p>


</li>
<li>


<p>
iv. Maximum Product
</p>
</li>
</ul>
</li>
<li>


<p>
e) Stock Trading
</p>


</li>
<li>


<p>
f) Binary Tree Mall Loot
</p>


</li>
<li>


<p>
g) Binary Search Tree Generation
</p>


</li>
<li>


<p>
h) Quantify Yogic Effect
</p>


</li>
<li>


<p>
i) Path to Heaven
</p>
<ul style="list-style-type:none">


<li>
<p>
i. Stairway
</p>


</li>
<li>


<p>
ii. Kriya Grid
</p>
</li>
</ul>
</li>
<li>


<p>
j) Kriya Sequence
</p>


</li>
<li>


<p>
k) Kriya Catalysis
</p>
</li>
</ul>
</li>
</ul>
<!--................................-->
<h4 id="autosec-150">List of Algorithms/Programs</h4>
<a id="index-autopage-150"></a>



<ul style="list-style-type:none">


<li>
<p>
1. Minimum Coin Change : Iterative (Bottom-up) Approach
</p>


</li>
<li>


<p>
2. Minimum Coin Change : Recursive (Top-down) Approach
</p>


</li>
<li>


<p>
3. Minimum Coin Change : Optimal set of coins
</p>


</li>
<li>


<p>
4. Coin Change : No of Ways
</p>


</li>
<li>


<p>
5. Maximum sum contiguous subsequence : compute sum
</p>


</li>
<li>


<p>
6. Maximum sum contiguous subsequence : compute indices
</p>


</li>
<li>


<p>
7. Maximum sum non-contiguous subsequence : compute sum
</p>


</li>
<li>


<p>
8. Maximum sum non-contiguous subsequence : compute sum : space optimized
</p>


</li>
<li>


<p>
9. Minimum sum contiguous subsequence .
</p>


</li>
<li>


<p>
10. Min sum contiguous subsequence : Find max of -ve
</p>


</li>
<li>


<p>
11. Minimum sum contiguous subsequence : compute indices
</p>


</li>
<li>


<p>
12. Maximum sum circular subsequence
</p>


</li>
<li>


<p>
13. Minimum sum circular subsequence
</p>


</li>
<li>


<p>
14. Maximum product contiguous subsequence : compute product
</p>


</li>
<li>


<p>
15. Maximum product contiguous subsequence : compute product : modified
</p>


</li>
<li>


<p>
16. Stock Trading : Maximum Profit : One Transaction
</p>


</li>
<li>


<p>
17. Maximize Profit : Maximum sum contiguous subsequence
</p>


</li>
<li>


<p>
18. Maximize Profit : Buy and Sell Days
</p>


</li>
<li>


<p>
19. Stock Trading : Maximum Profit : Two Transactions
</p>


</li>
<li>


<p>
20. Stock Trading : Maximum Profit : m(< n) Transactions
</p>


</li>
<li>


<p>
21. Stock Trading : Maximum Profit : m(> n) or Unlimited Transactions
</p>


</li>
<li>


<p>
22. Stock Trading : Maximum Profit : m(> n) or Unlimited Transactions : Alternative
</p>


</li>
<li>


<p>
23. Count Unique BSTs
</p>


</li>
<li>


<p>
24. Generate Unique BSTs
</p>


</li>
<li>


<p>
25. Quantify Yogic Effect : Drink Air Therapy
</p>


</li>
<li>


<p>
26. Quantify Yogic Effect : Khechari Kriya
</p>


</li>
<li>


<p>
27. Quantify Yogic Effect : Mool Kriya
</p>


</li>
<li>


<p>
28. Quantify Yogic Effect : Tandav Kriya
</p>


</li>
<li>


<p>
29. Quantify Yogic Effect : Minimax Kriya Selection .
</p>


</li>
<li>


<p>
30. Quantify Yogic Effect : Minimax Kriya Selection : Optimized Computation
</p>


</li>
<li>


<p>
31. Quantify Yogic Effect : Trikaldarshi
</p>


</li>
<li>


<p>
32. Quantify Yogic Effect : Trikaldarshi : Print Kriya Triangles
</p>


</li>
<li>


<p>
33. Staircase to Heaven : Count Distinct Ways
</p>


</li>
<li>


<p>
34. Staircase to Heaven : Count Distinct Ways with step-list
</p>


</li>
<li>


<p>
35. Staircase to Heaven : Optimal Pranayams
</p>


</li>
<li>


<p>
36. Distinct Kriya Grid Paths to Heaven
</p>


</li>
<li>


<p>
37. Distinct Kriya Grid Paths to Heaven : Space Optimization
</p>


</li>
<li>


<p>
38. Distinct Kriya Grid Paths to Heaven : With Prohibition
</p>


</li>
<li>


<p>
39. Distinct Kriya Grid Paths to Heaven : With Prohibition : Space Optimization
</p>


</li>
<li>


<p>
40. Distinct Kriya Grid Paths to Heaven : With Prohibition : Space Optimization : Alternative
</p>


</li>
<li>


<p>
41. Kriya Grid Paths to Heaven : Optimal Pranayams
</p>


</li>
<li>


<p>
42. Constrained Kriya Grid Paths to Heaven : Optimal Pranayams
</p>


</li>
<li>


<p>
43. Constrained Kriya Grid Paths to Heaven : Optimal Pranayams : Diff Cols
</p>


</li>
<li>


<p>
44. Constrained Kriya Grid Paths to Heaven : Optimal Pranayams : Diff Cols : Optimized
</p>


</li>
<li>


<p>
45. Optimal Pranayams to reach Heaven
</p>


</li>
<li>


<p>
46. Count ways : First Kriya
</p>


</li>
<li>


<p>
47. Count ways : First Kriya : Space Optimization
</p>


</li>
<li>


<p>
48. Out of Kriya Grid : Count ways
</p>


</li>
<li>


<p>
49. Out of Kriya Grid : Count ways : Space Optimization
</p>


</li>
<li>


<p>
50. Triangular Kriya Grid : Optimal Pranayams
</p>


</li>
<li>


<p>
51. Triangular Kriya Grid : Optimal Pranayams : Alternative
</p>


</li>
<li>


<p>
52. Maximal Square Kriya Grid
</p>


</li>
<li>


<p>
53. Max Zerones Kriya Sequences
</p>


</li>
<li>


<p>
54. Perfect Kriya
</p>


</li>
<li>


<p>
55. Generate Kriya
</p>


</li>
<li>


<p>
56. Vanish Kriya
</p>


</li>
<li>


<p>
57. Split Kriya
</p>


</li>
<li>


<p>
58. Threshold Kriya
</p>


</li>
<li>


<p>
59. Threshold Kriya : Space Optimization
</p>


</li>
<li>


<p>
60. Rejuvenate Kriya
</p>


</li>
<li>


<p>
61. Rejuvenate Kriya : Space Optimization
</p>


</li>
<li>


<p>
62. \(\beta \)-Dimensional Kriya
</p>


</li>
<li>


<p>
63. \(\beta \)-Dimensional Kriya : Space Optimization
</p>


</li>
<li>


<p>
64. Kriya Moves
</p>


</li>
<li>


<p>
65. Marking Kriya
</p>


</li>
<li>


<p>
66. Marking Kriya : Space Optimization
</p>


</li>
<li>


<p>
67. Kriya Selection
</p>


</li>
<li>


<p>
68. Kriya Sets : Possible Moves
</p>


</li>
<li>


<p>
69. Kriya Sets : Space Optimization
</p>


</li>
<li>


<p>
70. Count Distinct Pranayams Sets
</p>


</li>
<li>


<p>
71. Partition Kriya : Iso-Pranayams Sets
</p>


</li>
<li>


<p>
72. Partition Kriya : Iso-Pranayams Sets : Space Optimization
</p>


</li>
<li>


<p>
73. Kriya Probability
</p>


</li>
<li>


<p>
74. Combine Kriya
</p>


</li>
<li>


<p>
75. Sort Kriya : Optimal Interchanges
</p>


</li>
<li>


<p>
76. Sort Kriya : Space Optimization
</p>


</li>
<li>


<p>
77. Longest Increasing Subsequence (LIS) of Kriyas
</p>


</li>
<li>


<p>
78. Permute Kriyas
</p>


</li>
<li>


<p>
79. Length of LCS Kriya
</p>


</li>
<li>


<p>
80. LCS Kriya
</p>


</li>
<li>


<p>
81. Compute and Print LCS Kriya
</p>


</li>
<li>


<p>
82. Compute and Print LCS Kriya : Alternative
</p>


</li>
<li>


<p>
83. Compute All The LCS Kriya
</p>


</li>
<li>


<p>
84. Length of LCS Kriya : Space Optimization
</p>


</li>
<li>


<p>
85. Length of SCS Kriya
</p>


</li>
<li>


<p>
86. Reconstruction of SCS Kriya from Optimal Solution
</p>


</li>
<li>


<p>
87. Print SCS : Recursive Approach
</p>


</li>
<li>


<p>
88. Compute All The SCS Kriya
</p>


</li>
<li>


<p>
89. Computation SCS from LCS Kriya
</p>


</li>
<li>


<p>
90. SCS Kriya : Alternative Solution from LCS
</p>


</li>
<li>


<p>
91. Counting Palindromic Kriya Contiguous Subsequence
</p>


</li>
<li>


<p>
92. Longest Palindromic Kriya Contiguous Sub sequences
</p>


</li>
<li>


<p>
93. Maximum Length of Palindromic Kriya Subsequence
</p>


</li>
<li>


<p>
94. Max Length of Palindromic Kriya Subsequence : Alternative
</p>


</li>
<li>


<p>
95. Maximum Length of Palindromic Kriya Subsequence : Space Optimization
</p>


</li>
<li>


<p>
96. Max Length of Palindromic Kriya Subsequence : Space Optimization : Alternative
</p>


</li>
<li>


<p>
97. Count of Distinct Kriya Subsequences
</p>


</li>
<li>


<p>
98. Count of Distinct Kriya Subsequences : Space Optimization
</p>


</li>
<li>


<p>
99. Transform Kriya
</p>


</li>
<li>


<p>
100. Print Transformation Path
</p>
</li>
<li>


<p>
101. Transform Kriya : Space Optimization
</p>


</li>
<li>


<p>
102. Print Operations
</p>


</li>
<li>


<p>
103. Reconstruct Operations
</p>


</li>
<li>


<p>
104. Transform Kriya and Reconstruct Operations
</p>


</li>
<li>


<p>
105. Print Operations
</p>


</li>
<li>


<p>
106. Reconstruct Operations
</p>


</li>
<li>


<p>
107. Transform Kriya and Reconstruct Operations
</p>


</li>
<li>


<p>
108. Transform Kriya : Unrestricted Operations
</p>


</li>
<li>


<p>
109. Edit Distance : Print Operations with Copy and Finish
</p>


</li>
<li>


<p>
110. Edit Distance : Print Custom Operations with Reconstruct Operations
</p>


</li>
<li>


<p>
111. Edit Distance : Transform Kriya and Reconstruct Custom Operations
</p>


</li>
<li>


<p>
112. Reconstruct and Print Aligned Kriya Sequences
</p>


</li>
<li>


<p>
113. Generate Aligned Kriya Sequences
</p>


</li>
<li>


<p>
114. Generate &amp; Reconstruct Aligned Kriya Sequences
</p>


</li>
<li>


<p>
115. Identical Kriya Sequences
</p>


</li>
<li>


<p>
116. Identical Kriya Sequences with Reconstruction
</p>


</li>
<li>


<p>
117. Identical Kriya Sequences : Reconstruction (Recursive)
</p>


</li>
<li>


<p>
118. Generate Identical Kriya Sequences with Reconstruction (Recursive)
</p>


</li>
<li>


<p>
119. Generate Identical Kriya Sequences : Optimal Space
</p>


</li>
<li>


<p>
120. Optimal Removed Kriyas
</p>


</li>
<li>


<p>
121. Kriya Sequence Generation : Count Ways : Constraints of Favourable Comparisons
</p>


</li>
<li>


<p>
122. Preferred Kriya Practice : Count Ways
</p>


</li>
<li>


<p>
123. Preferred Kriya Practice : Count Ways : Space Optimization
</p>


</li>
<li>


<p>
124. Binary Split Kriyas : Count Ways
</p>


</li>
<li>


<p>
125. Organize Kriyas : Ways of Non-adjacent ones
</p>


</li>
<li>


<p>
126. Select Kriyas Alternately : Optimal Difference
</p>


</li>
<li>


<p>
127. Decode Kriya Sequence from Digits Sequence
</p>


</li>
<li>


<p>
128. Sorted Kriya Sequence : Transduction Quotient
</p>


</li>
<li>


<p>
129. Cross Kriya Potential
</p>


</li>
<li>


<p>
130. Maximum Sum : Linear and Circular Kriya Sequence
</p>
</li>
</ul>

</section>

</main>

</div>

<footer>

<p>
<a href="Hacking-TensorFlow-Internals-An-Insider’s-Commentary-on-Learning-System.html" class="linkhome" >
Next</a>
</p>

</footer>



<nav class="botnavigation"><a href="index.html" class="linkhome" >
Home</a></nav>

</body>
</html>
