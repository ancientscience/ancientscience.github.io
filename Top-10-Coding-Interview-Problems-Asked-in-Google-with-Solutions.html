
<!DOCTYPE html>
<html lang="en-US">
<head>
<meta charset="UTF-8" />
<meta name="generator" content="LaTeX Lwarp package" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<!--[if lt IE 9]>
<script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
<![endif]-->
<title>Ancient Science Publishers — Top 10 Coding Interview Problems Asked in Google with Solutions</title>
<link rel="stylesheet" type="text/css" href="lwarp_sagebrush.css" />

<script>
// Lwarp MathJax emulation code
//
// Based on code by Davide P. Cervone.
// Equation numbering: https://github.com/mathjax/MathJax/issues/2427
// Starred and ifnextchar macros: https://github.com/mathjax/MathJax/issues/2428
// \left, \right delimiters: https://github.com/mathjax/MathJax/issues/2535
//
// Modified by Brian Dunn to adjust equation numbering and add subequations.
//
// LaTeX can use \seteqnumber{subequations?}{section}{number} before each equation.
// subequations? is 0 usually, 1 if inside subequations.
// section is a string printed as-is, or empty.
// number is auto-incremented by MathJax between equations.
//
MathJax = {
   subequations: "0",
   section: "",
   loader: {
      load: ['[tex]/tagformat', '[tex]/textmacros'],
   },
   startup: {
      ready() {
        // These would be replaced by import commands if you wanted to make
        // a proper extension.
        const Configuration = MathJax._.input.tex.Configuration.Configuration;
        const CommandMap = MathJax._.input.tex.SymbolMap.CommandMap;
        const Macro = MathJax._.input.tex.Symbol.Macro;
        const TexError = MathJax._.input.tex.TexError.default;
        const ParseUtil = MathJax._.input.tex.ParseUtil.default;
        const expandable = MathJax._.util.Options.expandable;

           // Insert the replacement string into the TeX string, and check
           // that there haven't been too many maxro substitutions (prevents
           // infinite loops).
           const useArgument = (parser, text) => {
             parser.string = ParseUtil.addArgs(parser, text, parser.string.slice(parser.i));
             parser.i = 0;
             if (++parser.macroCount > parser.configuration.options.maxMacros) {
               throw new TexError('MaxMacroSub1',
               'MathJax maximum macro substitution count exceeded; ' +
               'is there a recursive macro call?');
             }
           }

           // Create the command map for:
           //      \ifstar, \ifnextchar, \ifblank, \ifstrequal, \seteqnumber
           new CommandMap('Lwarp-macros', {
              ifstar: 'IfstarFunction',
              ifnextchar: 'IfnextcharFunction',
              ifblank: 'IfblankFunction',
              ifstrequal: 'IfstrequalFunction',
              seteqnumber: 'SeteqnumberFunction'
           }, {
              // This function implements an ifstar macro.
              IfstarFunction(parser, name) {
                 const resultstar = parser.GetArgument(name);
                 const resultnostar = parser.GetArgument(name);
                 const star = parser.GetStar();                 // true if there is a *
                 useArgument(parser, star ? resultstar : resultnostar);
              },

             // This function implements an ifnextchar macro.
             IfnextcharFunction(parser, name) {
                let whichchar = parser.GetArgument(name);
                if (whichchar.match(/^(?:0x[0-9A-F]+|[0-9]+)$/i)) {
                  // $ syntax highlighting
                  whichchar = String.fromCodePoint(parseInt(whichchar));
                }
                const resultnextchar = parser.GetArgument(name);
                const resultnotnextchar = parser.GetArgument(name);
                const gotchar = (parser.GetNext() === whichchar);
                useArgument(parser, gotchar ? resultnextchar : resultnotnextchar);
             },

             // This function implements an ifblank macro.
             IfblankFunction(parser, name) {
                const blankarg = parser.GetArgument(name);
                const resultblank = parser.GetArgument(name);
                const resultnotblank = parser.GetArgument(name);
                const isblank = (blankarg.trim() == "");
                useArgument(parser, isblank ? resultblank : resultnotblank);
             },

             // This function implements an ifstrequal macro.
             IfstrequalFunction(parser, name) {
                const strequalfirst = parser.GetArgument(name);
                const strequalsecond = parser.GetArgument(name);
                const resultequal = parser.GetArgument(name);
                const resultnotequal = parser.GetArgument(name);
                const isequal = (strequalfirst == strequalsecond);
                useArgument(parser, isequal ? resultequal : resultnotequal);
             },

             // This function modifies the equation numbers.
             SeteqnumberFunction(parser, name) {
                 // Get the macro parameters
                 const star = parser.GetStar();                  // true if there is a *
                 const optBrackets = parser.GetBrackets(name);   // contents of optional brackets
                 const newsubequations = parser.GetArgument(name); // the subequations argument
                 const neweqsection = parser.GetArgument(name); // the eq section argument
                 const neweqnumber = parser.GetArgument(name);   // the eq number argument
                 MathJax.config.subequations=newsubequations ;   // a string with boolean meaning
                 MathJax.config.section=neweqsection ;           // a string with numeric meaning
                 parser.tags.counter = parser.tags.allCounter = neweqnumber ;
             }

           });

           // Create the Lwarp-macros package
           Configuration.create('Lwarp-macros', {
             handler: {macro: ['Lwarp-macros']}
           });

           MathJax.startup.defaultReady();

           // For forward references:
           MathJax.startup.input[0].preFilters.add(({math}) => {
             if (math.inputData.recompile){
                 MathJax.config.subequations = math.inputData.recompile.subequations;
                 MathJax.config.section = math.inputData.recompile.section;
             }
           });
           MathJax.startup.input[0].postFilters.add(({math}) => {
             if (math.inputData.recompile){
                 math.inputData.recompile.subequations = MathJax.config.subequations;
                 math.inputData.recompile.section = MathJax.config.section;
             }
           });

             // For \left, \right with unicode-math:
             const {DelimiterMap} = MathJax._.input.tex.SymbolMap;
             const {Symbol} = MathJax._.input.tex.Symbol;
             const {MapHandler} = MathJax._.input.tex.MapHandler;
             const delimiter = MapHandler.getMap('delimiter');
             delimiter.add('\\lBrack', new Symbol('\\lBrack', '\u27E6'));
             delimiter.add('\\rBrack', new Symbol('\\rBrack', '\u27E7'));
             delimiter.add('\\lAngle', new Symbol('\\lAngle', '\u27EA'));
             delimiter.add('\\rAngle', new Symbol('\\rAngle', '\u27EB'));
             delimiter.add('\\lbrbrak', new Symbol('\\lbrbrak', '\u2772'));
             delimiter.add('\\rbrbrak', new Symbol('\\rbrbrak', '\u2773'));
             delimiter.add('\\lbag', new Symbol('\\lbag', '\u27C5'));
             delimiter.add('\\rbag', new Symbol('\\rbag', '\u27C6'));
             delimiter.add('\\llparenthesis', new Symbol('\\llparenthesis', '\u2987'));
             delimiter.add('\\rrparenthesis', new Symbol('\\rrparenthesis', '\u2988'));
             delimiter.add('\\llangle', new Symbol('\\llangle', '\u2989'));
             delimiter.add('\\rrangle', new Symbol('\\rrangle', '\u298A'));
             delimiter.add('\\Lbrbrak', new Symbol('\\Lbrbrak', '\u27EC'));
             delimiter.add('\\Rbrbrak', new Symbol('\\Rbrbrak', '\u27ED'));
             delimiter.add('\\lBrace', new Symbol('\\lBrace', '\u2983'));
             delimiter.add('\\rBrace', new Symbol('\\rBrace', '\u2984'));
             delimiter.add('\\lParen', new Symbol('\\lParen', '\u2985'));
             delimiter.add('\\rParen', new Symbol('\\rParen', '\u2986'));
             delimiter.add('\\lbrackubar', new Symbol('\\lbrackubar', '\u298B'));
             delimiter.add('\\rbrackubar', new Symbol('\\rbrackubar', '\u298C'));
             delimiter.add('\\lbrackultick', new Symbol('\\lbrackultick', '\u298D'));
             delimiter.add('\\rbracklrtick', new Symbol('\\rbracklrtick', '\u298E'));
             delimiter.add('\\lbracklltick', new Symbol('\\lbracklltick', '\u298F'));
             delimiter.add('\\rbrackurtick', new Symbol('\\rbrackurtick', '\u2990'));
             delimiter.add('\\langledot', new Symbol('\\langledot', '\u2991'));
             delimiter.add('\\rangledot', new Symbol('\\rangledot', '\u2992'));
             delimiter.add('\\lparenless', new Symbol('\\lparenless', '\u2993'));
             delimiter.add('\\rparengtr', new Symbol('\\rparengtr', '\u2994'));
             delimiter.add('\\Lparengtr', new Symbol('\\Lparengtr', '\u2995'));
             delimiter.add('\\Rparenless', new Symbol('\\Rparenless', '\u2996'));
             delimiter.add('\\lblkbrbrak', new Symbol('\\lblkbrbrak', '\u2997'));
             delimiter.add('\\rblkbrbrak', new Symbol('\\rblkbrbrak', '\u2998'));
             delimiter.add('\\lvzigzag', new Symbol('\\lvzigzag', '\u29D8'));
             delimiter.add('\\rvzigzag', new Symbol('\\rvzigzag', '\u29D9'));
             delimiter.add('\\Lvzigzag', new Symbol('\\Lvzigzag', '\u29DA'));
             delimiter.add('\\Rvzigzag', new Symbol('\\Rvzigzag', '\u29DB'));
             delimiter.add('\\lcurvyangle', new Symbol('\\lcurvyangle', '\u29FC'));
             delimiter.add('\\rcurvyangle', new Symbol('\\rcurvyangle', '\u29FD'));
             delimiter.add('\\Vvert', new Symbol('\\Vvert', '\u2980'));
       }     // ready
  },         // startup

  tex: {
    packages: {'[+]': ['tagformat', 'Lwarp-macros', 'textmacros']},
    tags: "ams",
         tagformat: {
             number: function (n) {
                 if(MathJax.config.subequations==0)
                      return(MathJax.config.section + n);
                 else
                      return(MathJax.config.section + String.fromCharCode(96+n));
             },
         },
  }
}
</script>

<script
    id="MathJax-script"
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"
></script>


</head>
<body>



<a id="index-autopage-366"></a>
<nav class="topnavigation"><a href="index.html" class="linkhome" >
Home</a></nav>

<header>

<p>
<a href="Top-20-Coding-Interview-Problems-Asked-in-Google-with-Solutions.html" class="linkhome" >
Previous</a>
</p>

</header>



<div class="bodyandsidetoc">
<div class="sidetoccontainer">



<nav class="sidetoc">



<div class="sidetoctitle">

<p>
<span class="sidetocthetitle">Ancient Science Publishers</span>
</p>

<p>
Contents
</p>
</div>



<div class="sidetoccontents">

<p>
<a href="index.html" class="linkhome" >
Home</a>
</p>

<p>
<a href="textcolor-redComputer-Science.html#autosec-9" class="tocpart" >
<span class="sectionnumber">I</span>&#x2003;<span
      class="textcolor"
      style="color:#FF0000"
>Computer Science</span></a>
</p>



<p>
<a href="textcolor-redComputer-Science.html#autosec-10" class="tocchapter" >
<span class="sectionnumber">1</span>&#x2003;Discipline of Competitive Programming : A Hacker’s Perspective</a>
</p>



<p>
<a href="Elements-Coding-Science-Deriving-Correct-Programs.html#autosec-13" class="tocchapter" >
<span class="sectionnumber">2</span>&#x2003;Elements of Coding : Science of Deriving Correct Programs</a>
</p>



<p>
<a href="Elements-Coding-Linear-Algebra-The-Nucleus-Artificial-Intelligence.html#autosec-16" class="tocchapter" >
<span class="sectionnumber">3</span>&#x2003;Elements of Coding Linear Algebra : The Nucleus of Artificial Intelligence</a>
</p>



<p>
<a href="Elements-Software-Design-Patterns.html#autosec-24" class="tocchapter" >
<span class="sectionnumber">4</span>&#x2003;Elements of Software Design Patterns</a>
</p>



<p>
<a href="Elements-Coding-AI.html#autosec-90" class="tocchapter" >
<span class="sectionnumber">5</span>&#x2003;Elements of Coding AI</a>
</p>



<p>
<a href="Elements-Coding-DL-Deep-Learning.html#autosec-92" class="tocchapter" >
<span class="sectionnumber">6</span>&#x2003;Elements of Coding DL (Deep Learning)</a>
</p>



<p>
<a href="Elements-Coding-ML-Internals-Machine-Learning-Library-MLPack.html#autosec-94" class="tocchapter" >
<span class="sectionnumber">7</span>&#x2003;Elements of Coding ML : Internals of Machine Learning Library MLPack</a>
</p>



<p>
<a href="Conceptual-BitCoin-Blockchain-Coding.html#autosec-96" class="tocchapter" >
<span class="sectionnumber">8</span>&#x2003;Conceptual BitCoin : Blockchain Coding</a>
</p>



<p>
<a href="Conceptual-Data-Science-Interviews.html#autosec-98" class="tocchapter" >
<span class="sectionnumber">9</span>&#x2003;Conceptual Data Science Interviews</a>
</p>



<p>
<a href="Conceptual-Dependency-Injection-Unwiring-Simplified-in-C.html#autosec-100" class="tocchapter" >
<span class="sectionnumber">10</span>&#x2003;Conceptual Dependency Injection : Unwiring Simplified in C++</a>
</p>



<p>
<a href="Conceptual-Dynamic-Programming-Optimal-Coding-Simplified.html#autosec-102" class="tocchapter" >
<span class="sectionnumber">11</span>&#x2003;Conceptual Dynamic Programming : Optimal Coding Simplified</a>
</p>



<p>
<a href="Conceptual-Programming-Interviews.html#autosec-104" class="tocchapter" >
<span class="sectionnumber">12</span>&#x2003;Conceptual Programming Interviews</a>
</p>



<p>
<a href="Conceptual-Machine-Learning.html#autosec-106" class="tocchapter" >
<span class="sectionnumber">13</span>&#x2003;Conceptual Machine Learning</a>
</p>



<p>
<a href="Conceptual-Programming-STL-Algorithms.html#autosec-108" class="tocchapter" >
<span class="sectionnumber">14</span>&#x2003;Conceptual Programming of STL Algorithms</a>
</p>



<p>
<a href="Conceptual-Solutions-CLRS-Introduction-Algorithms.html#autosec-110" class="tocchapter" >
<span class="sectionnumber">15</span>&#x2003;Conceptual Solutions to (CLRS) Introduction to Algorithms</a>
</p>



<p>
<a href="Conceptual-Programming-Algorithms-Using-Dijkstra’s-Approach.html#autosec-112" class="tocchapter" >
<span class="sectionnumber">16</span>&#x2003;Conceptual Programming of Algorithms Using Dijkstra’s Approach</a>
</p>



<p>
<a href="Conceptual-Solutions-Pattern-Recognition-Machine-Learning.html#autosec-114" class="tocchapter" >
<span class="sectionnumber">17</span>&#x2003;Conceptual Solutions to Pattern Recognition and Machine Learning</a>
</p>



<p>
<a href="Science-Deriving-Beautiful-Programs.html#autosec-116" class="tocchapter" >
<span class="sectionnumber">18</span>&#x2003;Science of Deriving Beautiful Programs</a>
</p>



<p>
<a href="Modern-C-Ranges-Revolution-in-STL.html#autosec-118" class="tocchapter" >
<span class="sectionnumber">19</span>&#x2003;Modern C++ Ranges : A Revolution in STL</a>
</p>



<p>
<a href="Elements-C-20.html#autosec-120" class="tocchapter" >
<span class="sectionnumber">20</span>&#x2003;Elements of C++20</a>
</p>



<p>
<a href="Solving-Problems-using-Dynamic-Programming-Hacker’s-Perspective.html#autosec-126" class="tocchapter" >
<span class="sectionnumber">21</span>&#x2003;Solving Problems using Dynamic Programming : A Hacker’s Perspective</a>
</p>



<p>
<a href="Hacking-TensorFlow-Internals-An-Insider’s-Commentary-on-Learning-System.html#autosec-157" class="tocchapter" >
<span class="sectionnumber">22</span>&#x2003;Hacking TensorFlow Internals : An Insider’s Commentary on A Learning System</a>
</p>



<p>
<a href="Advanced-C-FAQs-Vol-1-2.html#autosec-159" class="tocchapter" >
<span class="sectionnumber">23</span>&#x2003;Advanced C++ FAQs Vol 1 &amp; 2</a>
</p>



<p>
<a href="C-14-FAQs.html#autosec-161" class="tocchapter" >
<span class="sectionnumber">24</span>&#x2003;C++14 FAQs</a>
</p>



<p>
<a href="The-Boost-C-Libraries-Generic-Programming.html#autosec-261" class="tocchapter" >
<span class="sectionnumber">25</span>&#x2003;The Boost C++ Libraries: Generic Programming</a>
</p>



<p>
<a href="Generic-Algorithms-Data-Structures-using-C-11.html#autosec-263" class="tocchapter" >
<span class="sectionnumber">26</span>&#x2003;Generic Algorithms and Data Structures using C++11</a>
</p>



<p>
<a href="C-11-Standard-Library-Usage-Implementation.html#autosec-265" class="tocchapter" >
<span class="sectionnumber">27</span>&#x2003;C++11 Standard Library: Usage and Implementation</a>
</p>



<p>
<a href="Foundation-Algorithms-in-C-11.html#autosec-267" class="tocchapter" >
<span class="sectionnumber">28</span>&#x2003;Foundation of Algorithms in C++11</a>
</p>



<p>
<a href="C-11-Algorithms-Using-Extending-C-11-Boost-Beyond.html#autosec-269" class="tocchapter" >
<span class="sectionnumber">29</span>&#x2003;C++11 Algorithms : Using and Extending C++11, Boost and Beyond</a>
</p>



<p>
<a href="Cracking-Programming-Interviews-500-Questions-with-Solutions.html#autosec-271" class="tocchapter" >
<span class="sectionnumber">30</span>&#x2003;Cracking Programming Interviews : 500 Questions with Solutions</a>
</p>



<p>
<a href="Top-20-Coding-Interview-Problems-Asked-in-Google-with-Solutions.html#autosec-305" class="tocchapter" >
<span class="sectionnumber">31</span>&#x2003;Top 20 Coding Interview Problems Asked in Google with Solutions</a>
</p>



<p>
<a href="Top-10-Coding-Interview-Problems-Asked-in-Google-with-Solutions.html#autosec-367" class="tocchapter" >
<span class="sectionnumber">32</span>&#x2003;Top 10 Coding Interview Problems Asked in Google with Solutions</a>
</p>



<p>
<a href="Physics.html#autosec-403" class="tocpart" >
<span class="sectionnumber">II</span>&#x2003;Physics</a>
</p>



<p>
<a href="Physics.html#autosec-404" class="tocchapter" >
<span class="sectionnumber">33</span>&#x2003;Questions and Problems in School Physics</a>
</p>



<p>
<a href="Mathematics.html#autosec-469" class="tocpart" >
<span class="sectionnumber">III</span>&#x2003;Mathematics</a>
</p>



<p>
<a href="Mathematics.html#autosec-470" class="tocchapter" >
<span class="sectionnumber">34</span>&#x2003;Concepts, Problems &amp; Solutions in School Calculus : A Dialogue Approach</a>
</p>



</div>

</nav>

</div>



<main class="bodycontainer">



<section class="textbody">

<h1>Ancient Science Publishers</h1>

<!--MathJax customizations:-->



<div class="hidden">

\(\newcommand{\footnotename}{footnote}\)

\(\def \LWRfootnote {1}\)

\(\newcommand {\footnote }[2][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\newcommand {\footnotemark }[1][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\let \LWRorighspace \hspace \)

\(\renewcommand {\hspace }{\ifstar \LWRorighspace \LWRorighspace }\)

\(\newcommand {\mathnormal }[1]{{#1}}\)

\(\newcommand \ensuremath [1]{#1}\)

\(\newcommand {\LWRframebox }[2][]{\fbox {#2}} \newcommand {\framebox }[1][]{\LWRframebox } \)

\(\newcommand {\setlength }[2]{}\)

\(\newcommand {\addtolength }[2]{}\)

\(\newcommand {\setcounter }[2]{}\)

\(\newcommand {\addtocounter }[2]{}\)

\(\newcommand {\arabic }[1]{}\)

\(\newcommand {\number }[1]{}\)

\(\newcommand {\noalign }[1]{\text {#1}\notag \\}\)

\(\newcommand {\cline }[1]{}\)

\(\newcommand {\directlua }[1]{\text {(directlua)}}\)

\(\newcommand {\luatexdirectlua }[1]{\text {(directlua)}}\)

\(\newcommand {\protect }{}\)

\(\def \LWRabsorbnumber #1 {}\)

\(\def \LWRabsorbquotenumber &quot;#1 {}\)

\(\newcommand {\LWRabsorboption }[1][]{}\)

\(\newcommand {\LWRabsorbtwooptions }[1][]{\LWRabsorboption }\)

\(\def \mathchar {\ifnextchar &quot;\LWRabsorbquotenumber \LWRabsorbnumber }\)

\(\def \mathcode #1={\mathchar }\)

\(\let \delcode \mathcode \)

\(\let \delimiter \mathchar \)

\(\def \oe {\unicode {x0153}}\)

\(\def \OE {\unicode {x0152}}\)

\(\def \ae {\unicode {x00E6}}\)

\(\def \AE {\unicode {x00C6}}\)

\(\def \aa {\unicode {x00E5}}\)

\(\def \AA {\unicode {x00C5}}\)

\(\def \o {\unicode {x00F8}}\)

\(\def \O {\unicode {x00D8}}\)

\(\def \l {\unicode {x0142}}\)

\(\def \L {\unicode {x0141}}\)

\(\def \ss {\unicode {x00DF}}\)

\(\def \SS {\unicode {x1E9E}}\)

\(\def \dag {\unicode {x2020}}\)

\(\def \ddag {\unicode {x2021}}\)

\(\def \P {\unicode {x00B6}}\)

\(\def \copyright {\unicode {x00A9}}\)

\(\def \pounds {\unicode {x00A3}}\)

\(\let \LWRref \ref \)

\(\renewcommand {\ref }{\ifstar \LWRref \LWRref }\)

\( \newcommand {\multicolumn }[3]{#3}\)

\(\require {textcomp}\)

\(\newcommand {\toprule }[1][]{\hline }\)

\(\let \midrule \toprule \)

\(\let \bottomrule \toprule \)

\(\def \LWRbooktabscmidruleparen (#1)#2{}\)

\(\newcommand {\LWRbooktabscmidrulenoparen }[1]{}\)

\(\newcommand {\cmidrule }[1][]{\ifnextchar (\LWRbooktabscmidruleparen \LWRbooktabscmidrulenoparen }\)

\(\newcommand {\morecmidrules }{}\)

\(\newcommand {\specialrule }[3]{\hline }\)

\(\newcommand {\addlinespace }[1][]{}\)

\(\def \LWRpagenote {1}\)

\(\newcommand {\pagenote }[2][\LWRpagenote ]{{}^{\mathrm {#1}}}\)

\(\newcommand {\intertext }[1]{\text {#1}\notag \\}\)

\(\let \Hat \hat \)

\(\let \Check \check \)

\(\let \Tilde \tilde \)

\(\let \Acute \acute \)

\(\let \Grave \grave \)

\(\let \Dot \dot \)

\(\let \Ddot \ddot \)

\(\let \Breve \breve \)

\(\let \Bar \bar \)

\(\let \Vec \vec \)

\(\newcommand {\conceptequiv }{\triangleq }\)

\(\newcommand {\CC }{\mathcal {C}}\)

\(\newcommand {\refines }{\looparrowright }\)

\(\newcommand {\weakens }{\looparrowleft }\)

\(\DeclareMathOperator *{\Max }{Max}\)

\(\DeclareMathOperator *{\Min }{Min}\)

\(\newcommand {\mleft }{\left }\)

\(\newcommand {\mright }{\right }\)

\(\newcommand {\mleftright }{}\)

\(\newcommand {\mleftrightrestore }{}\)

\(\require {physics}\)

\(\newcommand {\bigO }{\mathcal {O}}\)

\(\newcommand {\LWResvectvv }[1]{\overrightarrow {#1}}\)

\(\newcommand {\LWResvectvvstar }[2]{\overrightarrow {#1}\!_{#2}}\)

\(\newcommand {\vv }{\ifstar \LWResvectvvstar \LWResvectvv }\)

\(\newcommand {\lmts }[2]{\lim \limits _{#1 \to #2}}\)

</div>

<p>
<!--................................-->
<h3 id="autosec-367">Monograph&nbsp;<span class="sectionnumber">32&#x2003;</span>Top 10 Coding Interview Problems Asked in Google with Solutions</h3>
<a id="index-autopage-367"></a>
<a id="index-autofile-32"></a>
<div class="marginblock" role="note" style="width:217pt; float:right; ">
<div class="center">

<p>


<a href="top10/cover.svg" target="_blank" ><img
      src="top10/cover.svg"
      style="
      width:217pt;
      "
      class="inlineimage"
      alt="(image)"
></a>
</p>
</div>

</div>

<p>
This book is written for helping people prepare for Google Coding Interview. It contains top 10 programming problems frequently asked @Google with detailed worked-out solutions both in
pseudo-code and C++ (and C++11).
</p>

<p>
It came out as a result of numerous requests received from coders across the Globe, primarily from Google aspirants. Author has a vast collection of algorithmic problems since 20 years including
experience in preparing computer science students for participation in programming contests like TopCoder, ACM ICPC and others.
</p>
<div class="center">

<p>
<b>Must Have for Google Aspirants !!!</b>
</p>
</div>

<ul style="list-style-type:none">


<li>
<p>
1. <em><span
      class="textcolor"
      style="color:#4D0000"
>Matching Nuts and Bolts Optimally</span></em>
</p>


</li>
<li>


<p>
2. <em><span
      class="textcolor"
      style="color:#4D0000"
>Searching two-dimensional sorted array</span></em>
</p>


</li>
<li>


<p>
3. <em><span
      class="textcolor"
      style="color:#4D0000"
>Lowest Common Ancestor(LCA) Problem</span></em>
</p>


</li>
<li>


<p>
4. <em><span
      class="textcolor"
      style="color:#4D0000"
>Max Sub-Array Problem</span></em>
</p>


</li>
<li>


<p>
5. <em><span
      class="textcolor"
      style="color:#4D0000"
>Compute Next Higher Number</span></em>
</p>


</li>
<li>


<p>
6. <em><span
      class="textcolor"
      style="color:#4D0000"
>2D Binary Search</span></em>
</p>


</li>
<li>


<p>
7. <em><span
      class="textcolor"
      style="color:#4D0000"
>String Edit Distance</span></em>
</p>


</li>
<li>


<p>
8. <em><span
      class="textcolor"
      style="color:#4D0000"
>Searching in Two Dimensional Sequence</span></em>
</p>


</li>
<li>


<p>
9. <em><span
      class="textcolor"
      style="color:#4D0000"
>Select Kth Smallest Element</span></em>
</p>


</li>
<li>


<p>
10. <em><span
      class="textcolor"
      style="color:#4D0000"
>Searching in Possibly Empty Two Dimensional Sequence</span></em>
</p>
</li>
</ul>

<p>
<span class="underline"><b><span
      class="textcolor"
      style="color:#FF7D00"
>Excerpt from the Chapter</span> <span
      class="textcolor"
      style="color:#4D0000"
>4:</span></b></span>
</p>
<!--................................-->
<h4 id="autosec-371">Max Sub-Array Problem</h4>
<a id="index-autopage-371"></a>
<div class="center">

<p>
<b><span
      class="textcolor"
      style="color:#808000"
>**<span class="textsc">Problem</span> 4 (Kadane)</span></b>
</p>
</div>

<p>
<span
      class="textcolor"
      style="color:#9E00FF"
><em>Design and implement an efficient program to find a contiguous subarray within a one-dimensional array of integers which has the largest sum. Please note that there is at least one positive
integer in the input array.</em></span>
</p>
<div class="center">

<p>
<b><span
      class="textcolor"
      style="color:#808000"
><span class="textsc">Solution</span></span></b>
</p>
</div>
<!--................................-->
<h5 id="autosec-374">Kadane’s Algorithm</h5>
<a id="index-autopage-374"></a>



<p>
There is scanning algorithm known as <i>Kadane’s algorithm</i> which keeps track of the maximum sum subarray by starting at the leftmost element and scanning through to the rightmost
element. It works in a dynamic programming set-up because it has an optimal substructure, i.e., the maximum sum subarray upto the \((i - 1)^{th}\) element is used to find maximum sum
subarray upto \(i^{th}\) element.<br />
The algorithm accumulates a partial sum in max_ending_here and updates the current solution max_so_far appropriately. It is increased by the value contained in \(i^{th}\) index as far as it keeps it
positive, it is reset to zero otherwise.<br />
If all elements of an array are non-negative, this problem is trivial, as the entire array represents the solution. Similarly, if all elements are non-positive, the solution is empty with value 0. So we
consider a data set containing both positive and negative values.
</p>

<figure id="autoid-66" class="figure ">
<div class="center">

<p>
<span
      class="fbox"
      style="display:inline-block ; border:1pt solid #000000; padding:3pt ; color:#000000"
><b><span
      class="textcolor"
      style="color:#808000"
>Kadane’s 1D Algorithm</span></b></span>
</p>
</div>
<ul style="list-style-type:none">


<li>
<p>
1: <span style="width:0pt; display:inline-block;"></span><b>function</b> <span class="textsc">kadane1D</span>(start, end)
</p>


</li>
<li>


<p>
2:     <span style="width:15pt; display:inline-block;"></span>\(max\_so\_far \gets 0\)
</p>


</li>
<li>


<p>
3:     <span style="width:15pt; display:inline-block;"></span>\(max\_ending\_here \gets 0\)
</p>


</li>
<li>


<p>
4:     <span style="width:15pt; display:inline-block;"></span><b>while</b> \(start \neq end\) <b>do</b>
</p>


</li>
<li>


<p>
5:       <span style="width:30pt; display:inline-block;"></span>max_ending_here \(\gets \) max(max_ending_here + *start, 0)
</p>


</li>
<li>


<p>
6:       <span style="width:30pt; display:inline-block;"></span>max_so_far \(\gets \) max(max_so_far, max_ending_here)
</p>


</li>
<li>


<p>
7:       <span style="width:30pt; display:inline-block;"></span>start \(\gets \) start + 1
</p>


</li>
<li>


<p>
8:     <span style="width:15pt; display:inline-block;"></span><b>end</b> <b>while</b>
</p>


</li>
<li>


<p>
9:     <span style="width:15pt; display:inline-block;"></span><b>return</b> max_so_far
</p>


</li>
<li>


<p>
10: <span style="width:0pt; display:inline-block;"></span><b>end</b> <b>function</b>
</p>
</li>
</ul>

</figure>
<!--................................-->
<h6 id="autosec-376">C++11 Implementation</h6>
<a id="index-autopage-376"></a>
<a id="autoid-67" ></a >



<div class="figurecaption">

<p>
Listing&nbsp;32.1:&nbsp;Implementing Kadane’s Algorithm
</p>
</div>
<pre class="programlisting">
1 #include &lt;algorithm&gt;
2
3 template &lt;typename ForwardIterator&gt;
4 typename std::iterator_traits&lt;
5    ForwardIterator&gt;::value_type
6 kadane1d(ForwardIterator start,
7         ForwardIterator end)
8{
9    typedef typename std::iterator_traits&lt;
10            ForwardIterator
11        &gt;::value_type value_type;
12
13    value_type max_so_far = 0,
14               max_ending_here = 0;
15
16    while(start != end)
17    {
18        max_ending_here =
19          std::max(max_ending_here + ∗start++,
20                  0);
21        max_so_far =
22        std::max(max_so_far, max_ending_here);
23    }
24    return max_so_far;
25 }
</pre>
<!--................................-->
<h6 id="autosec-378">Usage</h6>
<a id="index-autopage-378"></a>
<a id="autoid-68" ></a >



<div class="figurecaption">

<p>
Listing&nbsp;32.2:&nbsp;Using Kadane’s Algorithm
</p>
</div>
<pre class="programlisting">
1 #include &lt;iostream&gt;
2 #include &lt;array&gt;
3 #include &lt;vector&gt;
4 #include &lt;forward_list&gt;
5 #include ”kadane1d.hpp”
6
7 int main()
8{
9     std::array&lt;int, 8&gt; a
10     {−2, −3, 4, −1, −2, 1, 5, −3};
11
12     std::cout &lt;&lt; kadane1d(a.cbegin(), a.cend())
13               &lt;&lt; std::endl;
14
15     std::vector&lt;int&gt; v
16     {−1, 4, −2, 5, −5, 2, −20, 6};
17
18     std::cout &lt;&lt; kadane1d(v.cbegin(), v.cend())
19               &lt;&lt; std::endl;
20
21     std::forward_list&lt;int&gt; l
22     {−2, 1, −3, 4, −1, 2, 1, −5, 4};
23
24     std::cout &lt;&lt; kadane1d(l.cbegin(), l.cend())
25               &lt;&lt; std::endl;
26 }
</pre>

<p>
It prints
</p>
<pre class="boxedverbatim">
7
7
6
</pre>
<!--................................-->
<h5 id="autosec-381">Find indices of max subarray</h5>
<a id="index-autopage-381"></a>



<p>
&#x2003;&#x2003;
</p>
<div class="center">

<p>
Design and implement an efficient program to find a contiguous subarray within a one-dimensional array of integers which has the largest sum. The result should include sum and
(start, end) of the subarray
</p>
</div>

<p>
.<br />
It is easy to see that
</p>
<ul style="list-style-type:none">


<li>
<p>
• the maximum subarray starts and ends in positive elements
</p>


</li>
<li>


<p>
• if we start from the first positive element, i.e., a[l], and sum over the subsequent elements until the sum drops negative at a[r], then the optimal subarray is either
</p>
<ul style="list-style-type:none">


<li>
<p>
– in a[l..r] and starts from a[l], or
</p>


</li>
<li>


<p>
– in a[r + 1..n].
</p>
</li>
</ul>
</li>
</ul>

<figure id="autoid-69" class="figure ">
<div class="center">

<p>
<span
      class="fbox"
      style="display:inline-block ; border:1pt solid #000000; padding:3pt ; color:#000000"
><b><span
      class="textcolor"
      style="color:#808000"
>Kadane’s 1D Algorithm : Find Indices</span></b></span>
</p>
</div>
<ul style="list-style-type:none">


<li>
<p>
1: <span style="width:0pt; display:inline-block;"></span><b>function</b> <span class="textsc">kadane1D</span>(start, end)
</p>


</li>
<li>


<p>
2:     <span style="width:15pt; display:inline-block;"></span>\(max\_so\_far \gets 0\)
</p>


</li>
<li>


<p>
3:     <span style="width:15pt; display:inline-block;"></span>\(max\_ending\_here \gets 0\)
</p>


</li>
<li>


<p>
4:     <span style="width:15pt; display:inline-block;"></span>\(l \gets 0\)
</p>


</li>
<li>


<p>
5:     <span style="width:15pt; display:inline-block;"></span>\(r \gets 0\)
</p>


</li>
<li>


<p>
6:     <span style="width:15pt; display:inline-block;"></span>\(li \gets 0\)
</p>


</li>
<li>


<p>
7:     <span style="width:15pt; display:inline-block;"></span><b>while</b> \(start \neq end\) <b>do</b>
</p>


</li>
<li>


<p>
8:       <span style="width:30pt; display:inline-block;"></span>max_ending_here \(\gets \) (max_ending_here + *start)
</p>


</li>
<li>


<p>
9:       <span style="width:30pt; display:inline-block;"></span><b>if</b> max_ending_here < 0 <b>then</b>
</p>


</li>
<li>


<p>
10:          <span style="width:45pt; display:inline-block;"></span>max_ending_here \(\gets \) 0
</p>


</li>
<li>


<p>
11:          <span style="width:45pt; display:inline-block;"></span>li \(\gets \)start + 1
</p>


</li>
<li>


<p>
12:       <span style="width:30pt; display:inline-block;"></span><b>end</b> <b>if</b>
</p>


</li>
<li>


<p>
13:       <span style="width:30pt; display:inline-block;"></span><b>if</b> max_so_far < max_ending_here <b>then</b>
</p>


</li>
<li>


<p>
14:          <span style="width:45pt; display:inline-block;"></span>max_so_far \(\gets \) max_ending_here
</p>


</li>
<li>


<p>
15:          <span style="width:45pt; display:inline-block;"></span>l \(\gets \) li
</p>


</li>
<li>


<p>
16:          <span style="width:45pt; display:inline-block;"></span>r \(\gets \) start
</p>


</li>
<li>


<p>
17:       <span style="width:30pt; display:inline-block;"></span><b>end</b> <b>if</b>
</p>


</li>
<li>


<p>
18:       <span style="width:30pt; display:inline-block;"></span>start \(\gets \) start + 1
</p>


</li>
<li>


<p>
19:     <span style="width:15pt; display:inline-block;"></span><b>end</b> <b>while</b>
</p>


</li>
<li>


<p>
20:     <span style="width:15pt; display:inline-block;"></span><b>return</b> \(&lt;\)max_so_far, l, r\(&gt;\)
</p>


</li>
<li>


<p>
21: <span style="width:0pt; display:inline-block;"></span><b>end</b> <b>function</b>
</p>
</li>
</ul>

</figure>
<!--................................-->
<h6 id="autosec-384">C++11 Implementation</h6>
<a id="index-autopage-384"></a>
<a id="autoid-70" ></a >



<div class="figurecaption">

<p>
Listing&nbsp;32.3:&nbsp;Implementing Kadane’s Algorithm : Finding Indices
</p>
</div>
<pre class="programlisting">
1 #include &lt;algorithm&gt;
2 #include &lt;tuple&gt;
3
4 template &lt;typename ForwardIterator&gt;
5 std::tuple&lt;typename std::iterator_traits&lt;
6                  ForwardIterator
7              &gt;::value_type,
8            ForwardIterator, ForwardIterator&gt;
9 kadane1d(ForwardIterator start,
10          ForwardIterator end)
11 {
12     typedef typename std::iterator_traits&lt;
13                      ForwardIterator
14                  &gt;::value_type value_type;
15
16     int max_so_far = 0, max_ending_here = 0;
17
18     ForwardIterator starti,
19                  sum_start, sum_end = start;
20
21     while(start != end)
22     {
23         max_ending_here += ∗start;
24
25         if (max_ending_here &lt;0)
26         {
27              max_ending_here = 0;
28              starti = start;
29              ++starti;
30         }
31
32         if (max_so_far &lt;max_ending_here)
33         {
34              max_so_far = max_ending_here;
35              sum_start = starti;
36              sum_end = start;
37         }
38         ++start;
39     }
40
41     return std::make_tuple(max_so_far,
42                              sum_start,
43                              sum_end);
44 }
</pre>
<!--................................-->
<h6 id="autosec-386">Usage</h6>
<a id="index-autopage-386"></a>



<p>
In practice, a bitmap image has all non-negative pixel values. When the average is subtracted from each pixel, we can apply the maximum subarray algorithm to find the brightest area within the
image.
</p>
<a id="autoid-71" ></a >



<div class="figurecaption">

<p>
Listing&nbsp;32.4:&nbsp;Using Kadane’s Algorithm : Finding Indices
</p>
</div>
<pre class="programlisting">
1 #include &lt;iostream&gt;
2 #include &lt;forward_list&gt;
3 #include ”kadane1d_indices.hpp”
4
5 template&lt;typename ForwardIterator&gt;
6 void printcontents(ForwardIterator start,
7                      ForwardIterator end)
8{
9     std::cout &lt;&lt; ”{”;
10     while(start != end)
11     {
12         std::cout &lt;&lt; ∗start++ &lt;&lt;” ”;
13     }
14     std::cout &lt;&lt; ∗start &lt;&lt; ”}” &lt;&lt; std::endl;
15 }
16
17 int main()
18 {
19     std::tuple&lt;int, int∗, int∗&gt; sum_start_end;
20
21     std::array&lt;int, 8&gt; a
22     {−2, −3, 4, −1, −2, 1, 5, −3};
23
24     sum_start_end =
25       kadane1d(a.begin(), a.end());
26
27     auto max_sum = std::get&lt;0&gt;(sum_start_end);
28
29     auto start_index =
30         std::distance(std::begin(a),
31               std::get&lt;1&gt;(sum_start_end));
32
33     auto end_index =
34         std::distance(std::begin(a),
35               std::get&lt;2&gt;(sum_start_end));
36
37     std::cout &lt;&lt; ”&lt;sum : ” &lt;&lt; max_sum &lt;&lt;”,”
38      &lt;&lt; ” start index : ” &lt;&lt; start_index &lt;&lt; ”,”
39      &lt;&lt; ” end index : ” &lt;&lt; end_index &lt;&lt; ”&gt;”
40      &lt;&lt; ” \nMax subarray is : ”;
41
42     printcontents(std::get&lt;1&gt;(sum_start_end),
43                     std::get&lt;2&gt;(sum_start_end));
44
45     std::vector&lt;int&gt; v
46     {−1, 4, −2, 5, −5, 2, −20, 6};
47
48     typedef std::vector&lt;int&gt;::iterator vitr;
49     std::tuple&lt;int, vitr , vitr &gt;
50       sum_start_end_v;
51
52     sum_start_end_v =
53         kadane1d(v.begin(), v.end());
54
55     max_sum = std::get&lt;0&gt;(sum_start_end_v);
56
57     start_index =
58       std::distance(v.begin(),
59            std::get&lt;1&gt;(sum_start_end_v));
60
61     end_index = std::distance(v.begin(),
62                   std::get&lt;2&gt;(sum_start_end_v));
63
64     std::cout &lt;&lt; ”&lt;sum : ” &lt;&lt; max_sum &lt;&lt;”,”
65      &lt;&lt; ” start index : ” &lt;&lt; start_index &lt;&lt; ”,”
66      &lt;&lt; ” end index : ” &lt;&lt; end_index &lt;&lt; ”&gt;”
67      &lt;&lt; ” \nMax subarray is : ”;
68
69     printcontents(std::get&lt;1&gt;(sum_start_end_v),
70                     std::get&lt;2&gt;(sum_start_end_v));
71
72
73     std::forward_list&lt;int&gt; l
74     {−2, 1, −3, 4, −1, 2, 1, −5, 4};
75
76     typedef std::forward_list&lt;int&gt;::iterator
77          litr ;
78     std::tuple&lt;int, litr , litr &gt; sum_start_end_l;
79
80     sum_start_end_l =
81         kadane1d(l.begin(), l.end());
82
83     max_sum = std::get&lt;0&gt;(sum_start_end_l);
84
85     start_index = std::distance(l.begin(),
86                     std::get&lt;1&gt;(sum_start_end_l));
87
88     end_index = std::distance(l.begin(),
89                   std::get&lt;2&gt;(sum_start_end_l));
90
91     std::cout &lt;&lt; ”&lt;sum : ” &lt;&lt; max_sum &lt;&lt;”,”
92      &lt;&lt; ” start index : ” &lt;&lt; start_index &lt;&lt; ”,”
93      &lt;&lt; ” end index : ” &lt;&lt; end_index &lt;&lt; ”&gt;”
94      &lt;&lt; ” \nMax subarray is : ”;
95     printcontents(std::get&lt;1&gt;(sum_start_end_l),
96                     std::get&lt;2&gt;(sum_start_end_l));
97 }
</pre>

<p>
It prints
</p>
<pre class="boxedverbatim">
<sum : 7, start   index :   2, end index : 6>
Max subarray is   : {4 -1   -2 1 5}
<sum : 7, start   index :   1, end index : 3>
Max subarray is   : {4 -2   5}
<sum : 6, start   index :   3, end index : 6>
Max subarray is   : {4 -1   2 1}
</pre>
<!--................................-->
<h6 id="autosec-389">Time Complexity</h6>
<a id="index-autopage-389"></a>



<p>
This algorithm consists of n additions and at most 2n comparisons, so the complexity is around 3n.<br />
Hence complexity is linear, i.e., \(O(n)\).
</p>
<!--................................-->
<h5 id="autosec-390">Find subarray with sum closest to zero</h5>
<a id="index-autopage-390"></a>



<p>
&#x2003;&#x2003;
</p>
<div class="center">

<p>
Find a sub-array whose sum is closest to zero rather than that with maximum sum. Please note that closest to zero doesn’t mean minimum sum
</p>
</div>

<p>
Assuming input array is <em>a</em>, let us have a notion of <em>prefix array</em> <i>prefixa</i> such that<br />
\(prefixa[i] = a[0] + a[1] + a[2] + \ldots + a[i - 1] + a[i]\)<br />
\(\implies \)<br />
\(prefixa[i] = prefixa[i - 1] + a[i]\)<br />
\(\implies \)<br />
\(a[i] = prefixa[i] - prefixa[i - 1]\)<br />
Suppose a[l..k] be such a sub-array with sum closest to zero. Then we have the sum of this sub-array as :<br />
\(a[l] + a[l + 1] + \ldots + a[k - 1] + a[k]\)<br />
=<br />
\(prefixa[l] - prefixa[l - 1] + \\ prefixa[l + 1] - prefixa[l] + \\ \vdots \\ prefixa[k - 1] - prefixa[k - 2] + \\ prefixa[k] - prefixa[k - 1]\)<br />
=<br />
\(prefixa[k] - prefixa[l - 1]\)<br />
Hence for the sum of a[l..k] to be equal to zero, we should have<br />
\(prefixa[k] = prefixa[l - 1]\)<br />
Hence the sum closest to zero can be found by locating the two closest elements in <em>prefixa</em>.<br />
Let us formalize the above algorithm as follows:
</p>
<ul style="list-style-type:none">


<li>
<p>
1. Compute prefix array with index of original array as well, so it is a collection of pair(value, index). \(O(n)\)
</p>


</li>
<li>


<p>
2. Sort the above prefix array by value. \(O(nlogn)\)
</p>


</li>
<li>


<p>
3. Compute pair-wise diff by value. Prepare absolute values to get a measure of how far/close these are to zero. \(O(n)\)
</p>


</li>
<li>


<p>
4. The closest pair is that with minimum value found above. \(O(n)\)
</p>


</li>
<li>


<p>
5. Report the indices found above in the original array. This is the subarray with sum being closest to zero. (2 comparisons needed).
</p>
</li>
</ul>

<p>
Please note that the first and last entries of the suffix array are sentinel points(hence special cases) because these cannot be represented effectively by any other two sub prefix sum. Suppose the
closest pair indices reported above is (l, k), then the subarray with sum closest to zero will be decided by the minimum of (closest pair-wise diff val, first entry of prefix, last entry of prefix), i.e. the
desired subarray would be
</p>
<ul style="list-style-type:none">


<li>
<p>
• a[l..k] if closest pair-wise diff val is minimum
</p>


</li>
<li>


<p>
• a[0] if first entry of prefix is minimum
</p>


</li>
<li>


<p>
• a[0..n - 1] is last entry of prefix is minimum
</p>
</li>
</ul>

<p>
Hence overall time complexity is \(O(n + nlogn)\)
</p>

<p>
Let us start walking through an implementation approach in C++ to understand it better.
</p>
<a id="autoid-72" ></a >



<div class="figurecaption">

<p>
Listing&nbsp;32.5:&nbsp;Finding sum closest to zero
</p>
</div>
<pre class="programlisting">
1 #include &lt;utility&gt;
2 #include &lt;algorithm&gt;
3 #include &lt;tuple&gt;
4 #include &lt;iostream&gt;
5
6 typedef std::pair&lt;int, size_t&gt; ValueIndexPair;
7
8 std::vector&lt;int&gt; i
9 findSubArraySumZero(std::vector&lt;int&gt; &amp; a)
10 {
11     typedef std::tuple&lt;int, size_t, size_t&gt;
12           ValStartEndIndices;
13
14     size_t len = a.size() ;
15     std::vector&lt;ValueIndexPair&gt; prefixa(len);
16
17     prefixa[0] = ValueIndexPair(a[0], 0);
18
19     for(size_t i = 1; i &lt; len; ++i)
20     prefixa[ i ] =
21     ValueIndexPair(
22      prefixa[ i − 1]. first + a[i ], i ) ;
23
24     std::cout &lt;&lt;
25     ”Printing Prefix Array with Value and”
26     ” Original Index”
27     &lt;&lt; std::endl;
28
29     for(ValueIndexPair vip : prefixa)
30     std::cout &lt;&lt; vip. first &lt;&lt; ”:”
31                 &lt;&lt; vip.second &lt;&lt; ” ”;
32     std::cout &lt;&lt; std::endl;
33
34     int start_prefix = prefixa[0]. first ;
35     int end_prefix = prefixa[len − 1]. first ;
36
37     std::sort(prefixa.begin(), prefixa.end(),
38        []( ValueIndexPair f, ValueIndexPair s)
39        {
40             return f. first &lt; s. first ;
41        }
42     );
43
44     std::cout
45     &lt;&lt; ”Printing Value Sorted Prefix Array”
46     &lt;&lt; std::endl;
47
48     for(ValueIndexPair vip : prefixa)
49     std::cout &lt;&lt; vip. first &lt;&lt; ”:”
50                 &lt;&lt; vip.second &lt;&lt; ” ”;
51     std::cout &lt;&lt; std::endl;
52
53     std::vector&lt;ValStartEndIndices&gt;
54           pairwisediff_vec(len − 1);
55     for(size_t i = 0; i &lt; len − 1; ++i)
56     {
57           pairwisediff_vec[i] =
58           std::make_tuple(
59           prefixa[ i + 1]. first − prefixa[i ]. first ,
60           prefixa[ i ]. second,
61           prefixa[ i + 1].second);
62     }
63
64     std::cout &lt;&lt;
65     ”Printing Pairwise Value Differences with”
66     ” original indices”
67     &lt;&lt; std::endl;
68
69     for(ValStartEndIndices vsei :
70           pairwisediff_vec)
71     std::cout &lt;&lt; ”(”
72                 &lt;&lt; std::get&lt;0&gt;(vsei) &lt;&lt; ”:”
73                 &lt;&lt; std::get&lt;1&gt;(vsei) &lt;&lt; ”:”
74                 &lt;&lt; std::get&lt;2&gt;(vsei) &lt;&lt; ”) ”;
75     std::cout &lt;&lt; std::endl;
76
77     std::vector&lt;ValStartEndIndices&gt;::iterator
78     itr =
79     std::min_element(
80           pairwisediff_vec.begin(),
81           pairwisediff_vec.end(),
82        []( ValStartEndIndices f,
83            ValStartEndIndices s)
84        {
85             return std::abs(std::get&lt;0&gt;(f))
86                     &lt; std::abs(std::get&lt;0&gt;(s));
87        }
88     );
89
90     ValStartEndIndices closest_indices = ∗itr;
91
92     std::vector&lt;int&gt; vcandidates(3);
93
94     vcandidates[0] =
95      std::abs(std::get&lt;0&gt;(closest_indices));
96     vcandidates[1] =
97      std::abs(start_prefix) ; // a[0]
98     vcandidates[2] =
99      std::abs(end_prefix); // a [0.. n − 1]
100
101      int close_zero = ∗std::min_element(
102       vcandidates.begin(), vcandidates.end());
103
104      std::vector&lt;int&gt; vsumzero;
105
106      size_t start_index, end_index = 0;
107
108      if (close_zero == vcandidates[1])
109     {
110           vsumzero.push_back(a[0]);
111     }
112      else if (close_zero == vcandidates[2])
113     {
114           vsumzero = a;
115     }
116      else // close_zero == vcandidates[0])
117     {
118           std::pair&lt;size_t, size_t&gt; se =
119           std::minmax(std::get&lt;1&gt;(
120                 closest_indices) ,
121                 std::get&lt;2&gt;(closest_indices));
122
123           vsumzero.assign(a.begin() +
124                             se. first + 1,
125                 a.begin() + se.second + 1);
126     }
127
128      return vsumzero;
129 }
130
131 int main()
132 {
133      std::vector&lt;int&gt; v
134     { 8, −3, 2, 1, −4, 10, −5 };
135
136      std::vector&lt;int&gt; vclosest_sum_zero =
137          findSubArraySumZero(v);
138
139      std::cout &lt;&lt; ”Subarray with sum closest”
140       ”to zero is” &lt;&lt; std::endl;
141      for(int e : vclosest_sum_zero)
142      std::cout &lt;&lt; e &lt;&lt; ” ”;
143      std::cout &lt;&lt; std::endl;
144      std::cout &lt;&lt; std::endl;
145
146     v = {−3,2,4,−6,−8,10,11};
147     vclosest_sum_zero = findSubArraySumZero(v);
148
149      std::cout &lt;&lt; ”Subarray with sum closest to”
150       ” zero is” &lt;&lt; std::endl;
151      for(int e : vclosest_sum_zero)
152      std::cout &lt;&lt; e &lt;&lt; ” ”;
153      std::cout &lt;&lt; std::endl;
154      std::cout &lt;&lt; std::endl;
155
156     v = {10, −2, −7};
157     vclosest_sum_zero = findSubArraySumZero(v);
158
159      std::cout &lt;&lt; ”Subarray with sum closest to”
160       ” zero is” &lt;&lt; std::endl;
161      for(int e : vclosest_sum_zero)
162      std::cout &lt;&lt; e &lt;&lt; ” ”;
163      std::cout &lt;&lt; std::endl;
164      std::cout &lt;&lt; std::endl;
165 }
</pre>

<p>
It prints
</p>
<pre class="boxedverbatim">
Printing Prefix Array with Value and Original Index
8:0 5:1 7:2 8:3 4:4 14:5 9:6
Printing Value Sorted Prefix Array
4:4 5:1 7:2 8:0 8:3 9:6 14:5
Printing Pairwise Value Differences with
original indices
(1:4:1) (2:1:2) (1:2:0) (0:0:3) (1:3:6) (5:6:5)
Subarray with sum closest to zero is
-3 2 1

Printing Prefix Array with Value and Original Index
-3:0 -1:1 3:2 -3:3 -11:4 -1:5 10:6
Printing Value Sorted Prefix Array
-11:4 -3:0 -3:3 -1:1 -1:5 3:2 10:6
Printing Pairwise Value Differences with
original indices
(8:4:0) (0:0:3) (2:3:1) (0:1:5) (4:5:2) (7:2:6)
Subarray with sum closest to zero is
2 4 -6

Printing Prefix Array with Value and Original Index
10:0 8:1 1:2
Printing Value Sorted Prefix Array
1:2 8:1 10:0
Printing Pairwise Value Differences with
original indices
(7:2:1) (2:1:0)
Subarray with sum closest to zero is
10 -2 -7
</pre>
<!--................................-->
<h5 id="autosec-394">Find subarray with sum closest to k</h5>
<a id="index-autopage-394"></a>



<p>
&#x2003;&#x2003;
</p>
<div class="center">

<p>
Find a sub-array whose sum is closest to a integer <em>s</em>
</p>
</div>

<p>
.<br />
As can be seen from the previous problem that the sum of a[l..k] =<br />
\(prefixa[k] - prefixa[l - 1] = s\)<br />
Hence in order to find the sub-array with sum closest to zero, all we need to find is to locate 2 elements in the prefix array which are closest with respect to k-distance.<br />
Rest of the exercise is left for the reader to work out.
</p>
<!--................................-->
<h5 id="autosec-396">Maximum 2D subarray problem</h5>
<a id="index-autopage-396"></a>



<p>
&#x2003;&#x2003;
</p>
<div class="center">

<p>
Design and implement an efficient program to find a contiguous 2D subarray within a two-dimensional array of integers which has the largest sum
</p>
</div>

<p>
.<br />
<em>Bentley</em> has given a nice algorithm based on Kadane’s one dimensional algorithm to solve this problem in two-dimensional array thus making it look like Kadane’s 2D algorithm.<br />
It applies Kadane’s algorithm to every possible row interval, summing over the rows in each interval to produce one dimensional array for Kadane’s algorithm to find the optimal column interval. One
of the central idea of Bentley’s algorithm is the <em>prefix sum</em> , which aims to avoid repeating summations when processing subsequent row intervals. The 1D Kadane’e algorithm is run on the
elements of each row of the array \((row_{1}, row_{2} \dots row_{m})\) considered as a 1D stream, then, on the sum of each pair of rows \((row_{1} + row_{2}, row_{1} + row_{3}\dots
row_{1} + row_{m})\). The solution is given by the maximal sum produced by the 1D Kadane’s algorithm on these cases. If \(x_{1}\) and \(x_{2}\) are the pointers to the beginning and the end of
the maximal sub-stream, and \(Row_{i}\) and \(Row_{j}\) are the two added rows for which the sum is maximal, then the solution is delimited by the rectangle given by the <b>upper-left
(\(Row_{i}, x_{1}\))</b> and the <b>lower-right</b> corners <b>(\(Row_{j}, x_{2}\))</b>. This algorithm can be summarized as below:
</p>
<ul style="list-style-type:none">


<li>
<p>
1. Compute the <em>prefix array</em> in the dimension of length m. This requires \(O(mn)\) computations.
</p>


</li>
<li>


<p>
2. If the maximum sum sub-array is between \(Row_{i}\) and \(Row_{j}\), inclusive, then there are \(\frac {m(m + 1)}{2}\) such pairs.
</p>


</li>
<li>


<p>
3. The sum of elements in the array between \(Row_{i}\) and \(Row_{j}\) for a given column is already computed as a part of our prefix sum. So each column sum looks like a single element of a one
dimensional array across all columns, i.e., it looks like a one dimensional array with one row and n columns.
</p>


</li>
<li>


<p>
4. Apply Kadane’s 1D algorithm on such pairs to get the maximum sub-array as described above. Thus total time complexity is \(O(m^{2}n)\).
</p>
</li>
</ul>

<p>
Let us formalize the algorithm as follows:<br />


</p>
<ul style="list-style-type:none">


<li>
<p>
1. Let us denote the input array as \(a[0..m, 0..n]\), i.e., it has m rows and n columns. Let \(a_{i}\) denote the \(i^{th}\) row of this array.
</p>


</li>
<li>


<p>
2. Let us denote \(i^{th}\) rowa of the prefix array as \(prefixa_{i}\) which stands for \(a_{1} + a_{2} \ldots a_{i}\).
</p>


</li>
<li>


<p>
3. Please note that \(prefixa_{i} = prefixa_{i - 1} + a_{i}\), where \(i \in {1..m}\). As described earlier, the computation of prefix array requires \(mn\) additions. Hence<br />
\(a_{i} = prefixa_{i} - prefixa_{i - 1}\)
</p>


</li>
<li>


<p>
4. It is easy to see that the sum over the rows l and k, i.e. \(a[l..k]\) can be computed as \(a_{l} + a_{l + 1} \ldots a_{k - 1} + a_{k}\) =<br />
\(prefixa_{l} - prefixa_{l - 1}\) +<br />
\(prefixa_{l + 1} - prefixa_{l}\) +<br />
&#x22EE;<br />
\(prefixa_{k - 1} - prefixa_{k - 2}\) +<br />
\(prefixa_{k} - prefixa_{k - 1}\) =<br />
\(prefixa_{k} - prefixa_{l - 1}\)<br />
These consists of \(\frac {m(m + 1)}{2}\) pairs.
</p>


</li>
<li>


<p>
5. Kadane’s 1D algorithm is applied on \(prefixa_{k} - prefixa_{l - 1}\) for each interval [l,k] to find the maximum sum. Thus overall time complexity is \(O(m^{2}n)\).
</p>
</li>
</ul>

<p>
We leave the coding exercise in C++ to the reader.
</p>
<!--................................-->
<h5 id="autosec-398">K-Maximum Sub-array problem</h5>
<a id="index-autopage-398"></a>



<p>
&#x2003;&#x2003;
</p>
<div class="center">

<p>
Design and implement an efficient program to find the <em>K</em> subarrays with largest sums. Please note that the maximum subarray problem for a one- or two-dimensional
array is to find the array portion that maiximizes the sum of array elements in it
</p>
</div>

<p>
.<br />
Let us revisit our prefix array concept as \(a[l..k] = prefixa[k] - prefix[l - 1]\). To find the maximum sub-array a[l..k], we have to find the indices l and k which maximizes sum of the
entries a[l..k]. Let us denote minprefixa[i] as a minimum prefix array for the sub-array \(a[0..i - 1]\).<br />
max(a[l..k]) = max(prefixa[k] - prefix[l - 1]) = max(prefixa[k] - min(prefix[l - 1])) = max(prefixa[k] - minprefixa[k]). So to compute the maximum sub-array all we need to do is to accumulate the prefix
sums along with maintaining minimum of the preceding prefix sums which could be subtracted from the accumulated prefix sums to get the maximum sum so far.
</p>

<figure id="autoid-73" class="figure ">
<div class="center">

<p>
<span
      class="fbox"
      style="display:inline-block ; border:1pt solid #000000; padding:3pt ; color:#000000"
><b><span
      class="textcolor"
      style="color:#808000"
>Maximum sub-array sum using prefix array</span></b></span>
</p>
</div>
<ul style="list-style-type:none">


<li>
<p>
1: <span style="width:0pt; display:inline-block;"></span><b>function</b> <span class="textsc">maxsubarray</span>(a[0..n - 1])
</p>


</li>
<li>


<p>
2:     <span style="width:15pt; display:inline-block;"></span>\(minprefixsum \gets 0\)
</p>


</li>
<li>


<p>
3:     <span style="width:15pt; display:inline-block;"></span>\(curmaxsum \gets 0\)
</p>


</li>
<li>


<p>
4:     <span style="width:15pt; display:inline-block;"></span>\(prefixa[0] \gets 0\)
</p>


</li>
<li>


<p>
5:     <span style="width:15pt; display:inline-block;"></span><b>for</b> \(i \gets 0, n - 1\) <b>do</b>
</p>


</li>
<li>


<p>
6:       <span style="width:30pt; display:inline-block;"></span>\(prefixa[i] \gets prefixa[i - 1] + a[i]\)
</p>


</li>
<li>


<p>
7:       <span style="width:30pt; display:inline-block;"></span>\(cand \gets prefixa[i] - minprefixsum\)
</p>


</li>
<li>


<p>
8:       <span style="width:30pt; display:inline-block;"></span>\(curmaxsum \gets max(curmaxsum, cand)\)
</p>


</li>
<li>


<p>
9:       <span style="width:30pt; display:inline-block;"></span>\(minprefixsum \gets min(minprefixsum, prefixa[i])\)
</p>


</li>
<li>


<p>
10:     <span style="width:15pt; display:inline-block;"></span><b>end</b> <b>for</b>
</p>


</li>
<li>


<p>
11:     <span style="width:15pt; display:inline-block;"></span><b>return</b> max_so_far
</p>


</li>
<li>


<p>
12: <span style="width:0pt; display:inline-block;"></span><b>end</b> <b>function</b>
</p>
</li>
</ul>

</figure>

<p>
Based on the above algorithm, we can easily extend it to find K-maximum subarray in one dimensional case. Instead of having a single variable that safeguards the minimum prefix sum, we maintain a
list of K minimum prefix sums, sorted in non-decreasing order. The merged list of two sorted sequences x and y are denoted by merge(x, y).
</p>

<figure id="autoid-74" class="figure ">
<div class="center">

<p>
<span
      class="fbox"
      style="display:inline-block ; border:1pt solid #000000; padding:3pt ; color:#000000"
><b><span
      class="textcolor"
      style="color:#808000"
>K-Maximum sub-array sum using prefix array</span></b></span>
</p>
</div>
<ul style="list-style-type:none">


<li>
<p>
1: <span style="width:0pt; display:inline-block;"></span><b>function</b> <span class="textsc">kmaxsumarray</span>(a[0..n - 1])
</p>


</li>
<li>


<p>
2:     <span style="width:15pt; display:inline-block;"></span><b>for</b> k \(\gets 1, K\) <b>do</b>
</p>


</li>
<li>


<p>
3:       <span style="width:30pt; display:inline-block;"></span>\(min[k] \gets \infty \)
</p>


</li>
<li>


<p>
4:       <span style="width:30pt; display:inline-block;"></span>\(M[k] \gets \infty \)
</p>


</li>
<li>


<p>
5:     <span style="width:15pt; display:inline-block;"></span><b>end</b> <b>for</b>
</p>


</li>
<li>


<p>
6:     <span style="width:15pt; display:inline-block;"></span>\(sum[0] \gets 0\)
</p>


</li>
<li>


<p>
7:     <span style="width:15pt; display:inline-block;"></span>\(min[1] \gets 0\)
</p>


</li>
<li>


<p>
8:     <span style="width:15pt; display:inline-block;"></span>\(M[1] \gets 0\)
</p>
</li>
<li>


<p>
9:     <span style="width:15pt; display:inline-block;"></span><b>for</b> i \(\gets 1, n\) <b>do</b>
</p>


</li>
<li>


<p>
10:        <span style="width:30pt; display:inline-block;"></span>\(sum[i] \gets sum[i - 1] + a[i]\)
</p>


</li>
<li>


<p>
11:        <span style="width:30pt; display:inline-block;"></span><b>for</b> k \(\gets 1, K\) <b>do</b>
</p>


</li>
<li>


<p>
12:          <span style="width:45pt; display:inline-block;"></span>\(cand[k] \gets sum[i] - min[k]\)
</p>


</li>
<li>


<p>
13:        <span style="width:30pt; display:inline-block;"></span><b>end</b> <b>for</b>
</p>


</li>
<li>


<p>
14:        <span style="width:30pt; display:inline-block;"></span>\(M \gets K largest elements of merge(M, cand)\)
</p>


</li>
<li>


<p>
15:        <span style="width:30pt; display:inline-block;"></span>insert sum[i] into min
</p>


</li>
<li>


<p>
16:     <span style="width:15pt; display:inline-block;"></span><b>end</b> <b>for</b>
</p>


</li>
<li>


<p>
17: <span style="width:0pt; display:inline-block;"></span><b>end</b> <b>function</b>
</p>
</li>
</ul>

</figure>

<p>
As we need to perform n iterations, the total time complexity is \(O(Kn)\). When K = 1, this result is comparable to O(n) time of Kadane’s algorithm and prefix array.
</p>

</section>

</main>

</div>

<footer>

<p>
<a href="Physics.html" class="linkhome" >
Next</a>
</p>

</footer>



<nav class="botnavigation"><a href="index.html" class="linkhome" >
Home</a></nav>

</body>
</html>
