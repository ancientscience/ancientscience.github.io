
<!DOCTYPE html>
<html lang="en-US">
<head>
<meta charset="UTF-8" />
<meta name="generator" content="LaTeX Lwarp package" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<!--[if lt IE 9]>
<script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
<![endif]-->
<title>Ancient Science Publishers â€” Cracking Programming Interviews : 500 Questions with Solutions</title>
<link rel="stylesheet" type="text/css" href="lwarp_sagebrush.css" />

<script>
// Lwarp MathJax emulation code
//
// Based on code by Davide P. Cervone.
// Equation numbering: https://github.com/mathjax/MathJax/issues/2427
// Starred and ifnextchar macros: https://github.com/mathjax/MathJax/issues/2428
// \left, \right delimiters: https://github.com/mathjax/MathJax/issues/2535
//
// Modified by Brian Dunn to adjust equation numbering and add subequations.
//
// LaTeX can use \seteqnumber{subequations?}{section}{number} before each equation.
// subequations? is 0 usually, 1 if inside subequations.
// section is a string printed as-is, or empty.
// number is auto-incremented by MathJax between equations.
//
MathJax = {
   subequations: "0",
   section: "",
   loader: {
      load: ['[tex]/tagformat', '[tex]/textmacros'],
   },
   startup: {
      ready() {
        // These would be replaced by import commands if you wanted to make
        // a proper extension.
        const Configuration = MathJax._.input.tex.Configuration.Configuration;
        const CommandMap = MathJax._.input.tex.SymbolMap.CommandMap;
        const Macro = MathJax._.input.tex.Symbol.Macro;
        const TexError = MathJax._.input.tex.TexError.default;
        const ParseUtil = MathJax._.input.tex.ParseUtil.default;
        const expandable = MathJax._.util.Options.expandable;

           // Insert the replacement string into the TeX string, and check
           // that there haven't been too many maxro substitutions (prevents
           // infinite loops).
           const useArgument = (parser, text) => {
             parser.string = ParseUtil.addArgs(parser, text, parser.string.slice(parser.i));
             parser.i = 0;
             if (++parser.macroCount > parser.configuration.options.maxMacros) {
               throw new TexError('MaxMacroSub1',
               'MathJax maximum macro substitution count exceeded; ' +
               'is there a recursive macro call?');
             }
           }

           // Create the command map for:
           //      \ifstar, \ifnextchar, \ifblank, \ifstrequal, \seteqnumber
           new CommandMap('Lwarp-macros', {
              ifstar: 'IfstarFunction',
              ifnextchar: 'IfnextcharFunction',
              ifblank: 'IfblankFunction',
              ifstrequal: 'IfstrequalFunction',
              seteqnumber: 'SeteqnumberFunction'
           }, {
              // This function implements an ifstar macro.
              IfstarFunction(parser, name) {
                 const resultstar = parser.GetArgument(name);
                 const resultnostar = parser.GetArgument(name);
                 const star = parser.GetStar();                 // true if there is a *
                 useArgument(parser, star ? resultstar : resultnostar);
              },

             // This function implements an ifnextchar macro.
             IfnextcharFunction(parser, name) {
                let whichchar = parser.GetArgument(name);
                if (whichchar.match(/^(?:0x[0-9A-F]+|[0-9]+)$/i)) {
                  // $ syntax highlighting
                  whichchar = String.fromCodePoint(parseInt(whichchar));
                }
                const resultnextchar = parser.GetArgument(name);
                const resultnotnextchar = parser.GetArgument(name);
                const gotchar = (parser.GetNext() === whichchar);
                useArgument(parser, gotchar ? resultnextchar : resultnotnextchar);
             },

             // This function implements an ifblank macro.
             IfblankFunction(parser, name) {
                const blankarg = parser.GetArgument(name);
                const resultblank = parser.GetArgument(name);
                const resultnotblank = parser.GetArgument(name);
                const isblank = (blankarg.trim() == "");
                useArgument(parser, isblank ? resultblank : resultnotblank);
             },

             // This function implements an ifstrequal macro.
             IfstrequalFunction(parser, name) {
                const strequalfirst = parser.GetArgument(name);
                const strequalsecond = parser.GetArgument(name);
                const resultequal = parser.GetArgument(name);
                const resultnotequal = parser.GetArgument(name);
                const isequal = (strequalfirst == strequalsecond);
                useArgument(parser, isequal ? resultequal : resultnotequal);
             },

             // This function modifies the equation numbers.
             SeteqnumberFunction(parser, name) {
                 // Get the macro parameters
                 const star = parser.GetStar();                  // true if there is a *
                 const optBrackets = parser.GetBrackets(name);   // contents of optional brackets
                 const newsubequations = parser.GetArgument(name); // the subequations argument
                 const neweqsection = parser.GetArgument(name); // the eq section argument
                 const neweqnumber = parser.GetArgument(name);   // the eq number argument
                 MathJax.config.subequations=newsubequations ;   // a string with boolean meaning
                 MathJax.config.section=neweqsection ;           // a string with numeric meaning
                 parser.tags.counter = parser.tags.allCounter = neweqnumber ;
             }

           });

           // Create the Lwarp-macros package
           Configuration.create('Lwarp-macros', {
             handler: {macro: ['Lwarp-macros']}
           });

           MathJax.startup.defaultReady();

           // For forward references:
           MathJax.startup.input[0].preFilters.add(({math}) => {
             if (math.inputData.recompile){
                 MathJax.config.subequations = math.inputData.recompile.subequations;
                 MathJax.config.section = math.inputData.recompile.section;
             }
           });
           MathJax.startup.input[0].postFilters.add(({math}) => {
             if (math.inputData.recompile){
                 math.inputData.recompile.subequations = MathJax.config.subequations;
                 math.inputData.recompile.section = MathJax.config.section;
             }
           });

             // For \left, \right with unicode-math:
             const {DelimiterMap} = MathJax._.input.tex.SymbolMap;
             const {Symbol} = MathJax._.input.tex.Symbol;
             const {MapHandler} = MathJax._.input.tex.MapHandler;
             const delimiter = MapHandler.getMap('delimiter');
             delimiter.add('\\lBrack', new Symbol('\\lBrack', '\u27E6'));
             delimiter.add('\\rBrack', new Symbol('\\rBrack', '\u27E7'));
             delimiter.add('\\lAngle', new Symbol('\\lAngle', '\u27EA'));
             delimiter.add('\\rAngle', new Symbol('\\rAngle', '\u27EB'));
             delimiter.add('\\lbrbrak', new Symbol('\\lbrbrak', '\u2772'));
             delimiter.add('\\rbrbrak', new Symbol('\\rbrbrak', '\u2773'));
             delimiter.add('\\lbag', new Symbol('\\lbag', '\u27C5'));
             delimiter.add('\\rbag', new Symbol('\\rbag', '\u27C6'));
             delimiter.add('\\llparenthesis', new Symbol('\\llparenthesis', '\u2987'));
             delimiter.add('\\rrparenthesis', new Symbol('\\rrparenthesis', '\u2988'));
             delimiter.add('\\llangle', new Symbol('\\llangle', '\u2989'));
             delimiter.add('\\rrangle', new Symbol('\\rrangle', '\u298A'));
             delimiter.add('\\Lbrbrak', new Symbol('\\Lbrbrak', '\u27EC'));
             delimiter.add('\\Rbrbrak', new Symbol('\\Rbrbrak', '\u27ED'));
             delimiter.add('\\lBrace', new Symbol('\\lBrace', '\u2983'));
             delimiter.add('\\rBrace', new Symbol('\\rBrace', '\u2984'));
             delimiter.add('\\lParen', new Symbol('\\lParen', '\u2985'));
             delimiter.add('\\rParen', new Symbol('\\rParen', '\u2986'));
             delimiter.add('\\lbrackubar', new Symbol('\\lbrackubar', '\u298B'));
             delimiter.add('\\rbrackubar', new Symbol('\\rbrackubar', '\u298C'));
             delimiter.add('\\lbrackultick', new Symbol('\\lbrackultick', '\u298D'));
             delimiter.add('\\rbracklrtick', new Symbol('\\rbracklrtick', '\u298E'));
             delimiter.add('\\lbracklltick', new Symbol('\\lbracklltick', '\u298F'));
             delimiter.add('\\rbrackurtick', new Symbol('\\rbrackurtick', '\u2990'));
             delimiter.add('\\langledot', new Symbol('\\langledot', '\u2991'));
             delimiter.add('\\rangledot', new Symbol('\\rangledot', '\u2992'));
             delimiter.add('\\lparenless', new Symbol('\\lparenless', '\u2993'));
             delimiter.add('\\rparengtr', new Symbol('\\rparengtr', '\u2994'));
             delimiter.add('\\Lparengtr', new Symbol('\\Lparengtr', '\u2995'));
             delimiter.add('\\Rparenless', new Symbol('\\Rparenless', '\u2996'));
             delimiter.add('\\lblkbrbrak', new Symbol('\\lblkbrbrak', '\u2997'));
             delimiter.add('\\rblkbrbrak', new Symbol('\\rblkbrbrak', '\u2998'));
             delimiter.add('\\lvzigzag', new Symbol('\\lvzigzag', '\u29D8'));
             delimiter.add('\\rvzigzag', new Symbol('\\rvzigzag', '\u29D9'));
             delimiter.add('\\Lvzigzag', new Symbol('\\Lvzigzag', '\u29DA'));
             delimiter.add('\\Rvzigzag', new Symbol('\\Rvzigzag', '\u29DB'));
             delimiter.add('\\lcurvyangle', new Symbol('\\lcurvyangle', '\u29FC'));
             delimiter.add('\\rcurvyangle', new Symbol('\\rcurvyangle', '\u29FD'));
             delimiter.add('\\Vvert', new Symbol('\\Vvert', '\u2980'));
       }     // ready
  },         // startup

  tex: {
    packages: {'[+]': ['tagformat', 'Lwarp-macros', 'textmacros']},
    tags: "ams",
         tagformat: {
             number: function (n) {
                 if(MathJax.config.subequations==0)
                      return(MathJax.config.section + n);
                 else
                      return(MathJax.config.section + String.fromCharCode(96+n));
             },
         },
  }
}
</script>

<script
    id="MathJax-script"
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"
></script>


</head>
<body>



<a id="index-autopage-270"></a>
<nav class="topnavigation"><a href="index.html" class="linkhome" >
Home</a></nav>

<header>

<p>
<a href="C-11-Algorithms-Using-Extending-C-11-Boost-Beyond.html" class="linkhome" >
Previous</a>
</p>

</header>



<div class="bodyandsidetoc">
<div class="sidetoccontainer">



<nav class="sidetoc">



<div class="sidetoctitle">

<p>
<span class="sidetocthetitle">Ancient Science Publishers</span>
</p>

<p>
Contents
</p>
</div>



<div class="sidetoccontents">

<p>
<a href="index.html" class="linkhome" >
Home</a>
</p>

<p>
<a href="textcolor-redComputer-Science.html#autosec-9" class="tocpart" >
<span class="sectionnumber">I</span>&#x2003;<span
      class="textcolor"
      style="color:#FF0000"
>Computer Science</span></a>
</p>



<p>
<a href="textcolor-redComputer-Science.html#autosec-10" class="tocchapter" >
<span class="sectionnumber">1</span>&#x2003;Discipline of Competitive Programming : A Hackerâ€™s Perspective</a>
</p>



<p>
<a href="Elements-Coding-Science-Deriving-Correct-Programs.html#autosec-13" class="tocchapter" >
<span class="sectionnumber">2</span>&#x2003;Elements of Coding : Science of Deriving Correct Programs</a>
</p>



<p>
<a href="Elements-Coding-Linear-Algebra-The-Nucleus-Artificial-Intelligence.html#autosec-16" class="tocchapter" >
<span class="sectionnumber">3</span>&#x2003;Elements of Coding Linear Algebra : The Nucleus of Artificial Intelligence</a>
</p>



<p>
<a href="Elements-Software-Design-Patterns.html#autosec-24" class="tocchapter" >
<span class="sectionnumber">4</span>&#x2003;Elements of Software Design Patterns</a>
</p>



<p>
<a href="Elements-Coding-AI.html#autosec-90" class="tocchapter" >
<span class="sectionnumber">5</span>&#x2003;Elements of Coding AI</a>
</p>



<p>
<a href="Elements-Coding-DL-Deep-Learning.html#autosec-92" class="tocchapter" >
<span class="sectionnumber">6</span>&#x2003;Elements of Coding DL (Deep Learning)</a>
</p>



<p>
<a href="Elements-Coding-ML-Internals-Machine-Learning-Library-MLPack.html#autosec-94" class="tocchapter" >
<span class="sectionnumber">7</span>&#x2003;Elements of Coding ML : Internals of Machine Learning Library MLPack</a>
</p>



<p>
<a href="Conceptual-BitCoin-Blockchain-Coding.html#autosec-96" class="tocchapter" >
<span class="sectionnumber">8</span>&#x2003;Conceptual BitCoin : Blockchain Coding</a>
</p>



<p>
<a href="Conceptual-Data-Science-Interviews.html#autosec-98" class="tocchapter" >
<span class="sectionnumber">9</span>&#x2003;Conceptual Data Science Interviews</a>
</p>



<p>
<a href="Conceptual-Dependency-Injection-Unwiring-Simplified-in-C.html#autosec-100" class="tocchapter" >
<span class="sectionnumber">10</span>&#x2003;Conceptual Dependency Injection : Unwiring Simplified in C++</a>
</p>



<p>
<a href="Conceptual-Dynamic-Programming-Optimal-Coding-Simplified.html#autosec-102" class="tocchapter" >
<span class="sectionnumber">11</span>&#x2003;Conceptual Dynamic Programming : Optimal Coding Simplified</a>
</p>



<p>
<a href="Conceptual-Programming-Interviews.html#autosec-104" class="tocchapter" >
<span class="sectionnumber">12</span>&#x2003;Conceptual Programming Interviews</a>
</p>



<p>
<a href="Conceptual-Machine-Learning.html#autosec-106" class="tocchapter" >
<span class="sectionnumber">13</span>&#x2003;Conceptual Machine Learning</a>
</p>



<p>
<a href="Conceptual-Programming-STL-Algorithms.html#autosec-108" class="tocchapter" >
<span class="sectionnumber">14</span>&#x2003;Conceptual Programming of STL Algorithms</a>
</p>



<p>
<a href="Conceptual-Solutions-CLRS-Introduction-Algorithms.html#autosec-110" class="tocchapter" >
<span class="sectionnumber">15</span>&#x2003;Conceptual Solutions to (CLRS) Introduction to Algorithms</a>
</p>



<p>
<a href="Conceptual-Programming-Algorithms-Using-Dijkstraâ€™s-Approach.html#autosec-112" class="tocchapter" >
<span class="sectionnumber">16</span>&#x2003;Conceptual Programming of Algorithms Using Dijkstraâ€™s Approach</a>
</p>



<p>
<a href="Conceptual-Solutions-Pattern-Recognition-Machine-Learning.html#autosec-114" class="tocchapter" >
<span class="sectionnumber">17</span>&#x2003;Conceptual Solutions to Pattern Recognition and Machine Learning</a>
</p>



<p>
<a href="Science-Deriving-Beautiful-Programs.html#autosec-116" class="tocchapter" >
<span class="sectionnumber">18</span>&#x2003;Science of Deriving Beautiful Programs</a>
</p>



<p>
<a href="Modern-C-Ranges-Revolution-in-STL.html#autosec-118" class="tocchapter" >
<span class="sectionnumber">19</span>&#x2003;Modern C++ Ranges : A Revolution in STL</a>
</p>



<p>
<a href="Elements-C-20.html#autosec-120" class="tocchapter" >
<span class="sectionnumber">20</span>&#x2003;Elements of C++20</a>
</p>



<p>
<a href="Solving-Problems-using-Dynamic-Programming-Hackerâ€™s-Perspective.html#autosec-126" class="tocchapter" >
<span class="sectionnumber">21</span>&#x2003;Solving Problems using Dynamic Programming : A Hackerâ€™s Perspective</a>
</p>



<p>
<a href="Hacking-TensorFlow-Internals-An-Insiderâ€™s-Commentary-on-Learning-System.html#autosec-157" class="tocchapter" >
<span class="sectionnumber">22</span>&#x2003;Hacking TensorFlow Internals : An Insiderâ€™s Commentary on A Learning System</a>
</p>



<p>
<a href="Advanced-C-FAQs-Vol-1-2.html#autosec-159" class="tocchapter" >
<span class="sectionnumber">23</span>&#x2003;Advanced C++ FAQs Vol 1 &amp; 2</a>
</p>



<p>
<a href="C-14-FAQs.html#autosec-161" class="tocchapter" >
<span class="sectionnumber">24</span>&#x2003;C++14 FAQs</a>
</p>



<p>
<a href="The-Boost-C-Libraries-Generic-Programming.html#autosec-261" class="tocchapter" >
<span class="sectionnumber">25</span>&#x2003;The Boost C++ Libraries: Generic Programming</a>
</p>



<p>
<a href="Generic-Algorithms-Data-Structures-using-C-11.html#autosec-263" class="tocchapter" >
<span class="sectionnumber">26</span>&#x2003;Generic Algorithms and Data Structures using C++11</a>
</p>



<p>
<a href="C-11-Standard-Library-Usage-Implementation.html#autosec-265" class="tocchapter" >
<span class="sectionnumber">27</span>&#x2003;C++11 Standard Library: Usage and Implementation</a>
</p>



<p>
<a href="Foundation-Algorithms-in-C-11.html#autosec-267" class="tocchapter" >
<span class="sectionnumber">28</span>&#x2003;Foundation of Algorithms in C++11</a>
</p>



<p>
<a href="C-11-Algorithms-Using-Extending-C-11-Boost-Beyond.html#autosec-269" class="tocchapter" >
<span class="sectionnumber">29</span>&#x2003;C++11 Algorithms : Using and Extending C++11, Boost and Beyond</a>
</p>



<p>
<a href="Cracking-Programming-Interviews-500-Questions-with-Solutions.html#autosec-271" class="tocchapter" >
<span class="sectionnumber">30</span>&#x2003;Cracking Programming Interviews : 500 Questions with Solutions</a>
</p>



<p>
<a href="Top-20-Coding-Interview-Problems-Asked-in-Google-with-Solutions.html#autosec-305" class="tocchapter" >
<span class="sectionnumber">31</span>&#x2003;Top 20 Coding Interview Problems Asked in Google with Solutions</a>
</p>



<p>
<a href="Top-10-Coding-Interview-Problems-Asked-in-Google-with-Solutions.html#autosec-367" class="tocchapter" >
<span class="sectionnumber">32</span>&#x2003;Top 10 Coding Interview Problems Asked in Google with Solutions</a>
</p>



<p>
<a href="Physics.html#autosec-403" class="tocpart" >
<span class="sectionnumber">II</span>&#x2003;Physics</a>
</p>



<p>
<a href="Physics.html#autosec-404" class="tocchapter" >
<span class="sectionnumber">33</span>&#x2003;Questions and Problems in School Physics</a>
</p>



<p>
<a href="Mathematics.html#autosec-469" class="tocpart" >
<span class="sectionnumber">III</span>&#x2003;Mathematics</a>
</p>



<p>
<a href="Mathematics.html#autosec-470" class="tocchapter" >
<span class="sectionnumber">34</span>&#x2003;Concepts, Problems &amp; Solutions in School Calculus : A Dialogue Approach</a>
</p>



</div>

</nav>

</div>



<main class="bodycontainer">



<section class="textbody">

<h1>Ancient Science Publishers</h1>

<!--MathJax customizations:-->



<div class="hidden">

\(\newcommand{\footnotename}{footnote}\)

\(\def \LWRfootnote {1}\)

\(\newcommand {\footnote }[2][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\newcommand {\footnotemark }[1][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\let \LWRorighspace \hspace \)

\(\renewcommand {\hspace }{\ifstar \LWRorighspace \LWRorighspace }\)

\(\newcommand {\mathnormal }[1]{{#1}}\)

\(\newcommand \ensuremath [1]{#1}\)

\(\newcommand {\LWRframebox }[2][]{\fbox {#2}} \newcommand {\framebox }[1][]{\LWRframebox } \)

\(\newcommand {\setlength }[2]{}\)

\(\newcommand {\addtolength }[2]{}\)

\(\newcommand {\setcounter }[2]{}\)

\(\newcommand {\addtocounter }[2]{}\)

\(\newcommand {\arabic }[1]{}\)

\(\newcommand {\number }[1]{}\)

\(\newcommand {\noalign }[1]{\text {#1}\notag \\}\)

\(\newcommand {\cline }[1]{}\)

\(\newcommand {\directlua }[1]{\text {(directlua)}}\)

\(\newcommand {\luatexdirectlua }[1]{\text {(directlua)}}\)

\(\newcommand {\protect }{}\)

\(\def \LWRabsorbnumber #1 {}\)

\(\def \LWRabsorbquotenumber &quot;#1 {}\)

\(\newcommand {\LWRabsorboption }[1][]{}\)

\(\newcommand {\LWRabsorbtwooptions }[1][]{\LWRabsorboption }\)

\(\def \mathchar {\ifnextchar &quot;\LWRabsorbquotenumber \LWRabsorbnumber }\)

\(\def \mathcode #1={\mathchar }\)

\(\let \delcode \mathcode \)

\(\let \delimiter \mathchar \)

\(\def \oe {\unicode {x0153}}\)

\(\def \OE {\unicode {x0152}}\)

\(\def \ae {\unicode {x00E6}}\)

\(\def \AE {\unicode {x00C6}}\)

\(\def \aa {\unicode {x00E5}}\)

\(\def \AA {\unicode {x00C5}}\)

\(\def \o {\unicode {x00F8}}\)

\(\def \O {\unicode {x00D8}}\)

\(\def \l {\unicode {x0142}}\)

\(\def \L {\unicode {x0141}}\)

\(\def \ss {\unicode {x00DF}}\)

\(\def \SS {\unicode {x1E9E}}\)

\(\def \dag {\unicode {x2020}}\)

\(\def \ddag {\unicode {x2021}}\)

\(\def \P {\unicode {x00B6}}\)

\(\def \copyright {\unicode {x00A9}}\)

\(\def \pounds {\unicode {x00A3}}\)

\(\let \LWRref \ref \)

\(\renewcommand {\ref }{\ifstar \LWRref \LWRref }\)

\( \newcommand {\multicolumn }[3]{#3}\)

\(\require {textcomp}\)

\(\newcommand {\toprule }[1][]{\hline }\)

\(\let \midrule \toprule \)

\(\let \bottomrule \toprule \)

\(\def \LWRbooktabscmidruleparen (#1)#2{}\)

\(\newcommand {\LWRbooktabscmidrulenoparen }[1]{}\)

\(\newcommand {\cmidrule }[1][]{\ifnextchar (\LWRbooktabscmidruleparen \LWRbooktabscmidrulenoparen }\)

\(\newcommand {\morecmidrules }{}\)

\(\newcommand {\specialrule }[3]{\hline }\)

\(\newcommand {\addlinespace }[1][]{}\)

\(\def \LWRpagenote {1}\)

\(\newcommand {\pagenote }[2][\LWRpagenote ]{{}^{\mathrm {#1}}}\)

\(\newcommand {\intertext }[1]{\text {#1}\notag \\}\)

\(\let \Hat \hat \)

\(\let \Check \check \)

\(\let \Tilde \tilde \)

\(\let \Acute \acute \)

\(\let \Grave \grave \)

\(\let \Dot \dot \)

\(\let \Ddot \ddot \)

\(\let \Breve \breve \)

\(\let \Bar \bar \)

\(\let \Vec \vec \)

\(\newcommand {\conceptequiv }{\triangleq }\)

\(\newcommand {\CC }{\mathcal {C}}\)

\(\newcommand {\refines }{\looparrowright }\)

\(\newcommand {\weakens }{\looparrowleft }\)

\(\DeclareMathOperator *{\Max }{Max}\)

\(\DeclareMathOperator *{\Min }{Min}\)

\(\newcommand {\mleft }{\left }\)

\(\newcommand {\mright }{\right }\)

\(\newcommand {\mleftright }{}\)

\(\newcommand {\mleftrightrestore }{}\)

\(\require {physics}\)

\(\newcommand {\bigO }{\mathcal {O}}\)

\(\newcommand {\LWResvectvv }[1]{\overrightarrow {#1}}\)

\(\newcommand {\LWResvectvvstar }[2]{\overrightarrow {#1}\!_{#2}}\)

\(\newcommand {\vv }{\ifstar \LWResvectvvstar \LWResvectvv }\)

\(\newcommand {\lmts }[2]{\lim \limits _{#1 \to #2}}\)

</div>

<p>
<!--................................-->
<h3 id="autosec-271">Monograph&nbsp;<span class="sectionnumber">30&#x2003;</span>Cracking Programming Interviews : 500 Questions with Solutions</h3>
<a id="index-autopage-271"></a>
<a id="index-autofile-30"></a>
<div class="marginblock" role="note" style="width:217pt; float:right; ">
<div class="center">

<p>


<a href="cracking/cover.svg" target="_blank" ><img
      src="cracking/cover.svg"
      style="
      width:217pt;
      "
      class="inlineimage"
      alt="(image)"
></a>
</p>
</div>

</div>

<p>
This book contains <b>500</b> programming questions most frequently asked in technical interviews in top technical companies including Facebook, Microsoft, Google, Apple, Yahoo and others.
Detailed solutions are provided for all of these including tips and techniques for solving similar problems.
</p>
<!--................................-->
<h4 id="autosec-274">Table of Contents</h4>
<a id="index-autopage-274"></a>



<ul style="list-style-type:none">


<li>
<p>
I Algorithms and Data Structures
</p>
<ul style="list-style-type:none">


<li>
<p>
1. Fundamentals
</p>
<ul style="list-style-type:none">


<li>
<p>
1.1. Approximating the square root of a number
</p>


</li>
<li>


<p>
1.2. Generating Permutation Efficiently
</p>


</li>
<li>


<p>
1.3. Unique 5-bit Sequences
</p>


</li>
<li>


<p>
1.4. Select Kth Smallest Element
</p>


</li>
<li>


<p>
1.5. The Non-Crooks Problem
</p>


</li>
<li>


<p>
1.6. Is this (almost) sorted?
</p>


</li>
<li>


<p>
1.7. Sorting an almost sorted list
</p>


</li>
<li>


<p>
1.8. The Longest Upsequence Problem
</p>


</li>
<li>


<p>
1.9. Fixed size generic array in C++
</p>


</li>
<li>


<p>
1.10. Seating Problem
</p>


</li>
<li>


<p>
1.11. Segment Problems
</p>


</li>
<li>


<p>
1.12. Exponentiation
</p>


</li>
<li>


<p>
1.13. Searching two-dimensional sorted array
</p>


</li>
<li>


<p>
1.14. Initial bounded searcheable region
</p>


</li>
<li>


<p>
1.15. Hamming Problem
</p>


</li>
<li>


<p>
1.16. Constant Time Range Query
</p>


</li>
<li>


<p>
1.17. Linear Time Sorting
</p>


</li>
<li>


<p>
1.18. Writing a Value as the Sum of Squares
</p>


</li>
<li>


<p>
1.19. The Celebrity Problem
</p>


</li>
<li>


<p>
1.20. Transport Problem
</p>


</li>
<li>


<p>
1.21. Find Length of the rope
</p>


</li>
<li>


<p>
1.22. Switch Bulb Problem
</p>


</li>
<li>


<p>
1.23. In, On or Out
</p>


</li>
<li>


<p>
1.24. The problem of the balanced segments
</p>


</li>
<li>


<p>
1.25. The problem of the most isolated villages
</p>
</li>
</ul>
</li>
<li>


<p>
2. Arrays
</p>
<ul style="list-style-type:none">


<li>
<p>
2.1. The Plateau Problem
</p>


</li>
<li>


<p>
2.2. Searching in Two Dimensional Sequence
</p>


</li>
<li>


<p>
2.3. The Welfare Crook Problem
</p>


</li>
<li>


<p>
2.4. 2D Array Rotation
</p>


</li>
<li>


<p>
2.5. A Queuing Problem in A Post Office
</p>


</li>
<li>


<p>
2.6. Interpolation Search
</p>


</li>
<li>


<p>
2.7. Robot Walk
</p>


</li>
<li>


<p>
2.8. Linear Time Sorting
</p>


</li>
<li>


<p>
2.9. Write as sum of consecutive positive numbers
</p>


</li>
<li>


<p>
2.10. Print 2D Array in Spiral Order
</p>


</li>
<li>


<p>
2.11. The Problem of the Circular Racecourse
</p>


</li>
<li>


<p>
2.12. Sparse Array Trick
</p>


</li>
<li>


<p>
2.13. Bultermanâ€™s Reshuffling Problem
</p>


</li>
<li>


<p>
2.14. Finding the majority
</p>


</li>
<li>


<p>
2.15. Mode of a Multiset
</p>


</li>
<li>


<p>
2.16. Circular Array
</p>


</li>
<li>


<p>
2.17. Find Median of two sorted arrays
</p>


</li>
<li>


<p>
2.18. Finding the missing integer
</p>


</li>
<li>


<p>
2.19. Finding the missing number with sorted columns
</p>


</li>
<li>


<p>
2.20. Re-arranging an array
</p>


</li>
<li>


<p>
2.21. Switch and Bulb Problem
</p>


</li>
<li>


<p>
2.22. Compute sum of sub-array
</p>


</li>
<li>


<p>
2.23. Find a number not sum of subsets of array
</p>


</li>
<li>


<p>
2.24. \(K^{th}\) Smallest Element in Two Sorted Arrays
</p>


</li>
<li>


<p>
2.25. Sort a sequence of sub-sequences
</p>


</li>
<li>


<p>
2.26. Find missing integer
</p>


</li>
<li>


<p>
2.27. Inplace Reversing
</p>


</li>
<li>


<p>
2.28. Find the number not occurring twice in an array
</p>
</li>
</ul>
</li>
<li>


<p>
3. Trees
</p>
<ul style="list-style-type:none">


<li>
<p>
3.1. Lowest Common Ancestor(LCA) Problem
</p>


</li>
<li>


<p>
3.2. Path Number
</p>


</li>
<li>


<p>
3.3. Spying Campaign
</p>
</li>
</ul>
</li>
<li>


<p>
4. Dynamic Programming
</p>
<ul style="list-style-type:none">


<li>
<p>
4.1. Stage Coach Problem
</p>


</li>
<li>


<p>
4.2. Matrix Multiplication
</p>


</li>
<li>


<p>
4.3. TSP Problem
</p>


</li>
<li>


<p>
4.4. A Simple Path Problem
</p>


</li>
<li>


<p>
4.5. String Edit Distance
</p>


</li>
<li>


<p>
4.6. Music recognition
</p>


</li>
<li>


<p>
4.7. Max Sub-Array Problem
</p>
</li>
</ul>
</li>
<li>


<p>
5. Graphs
</p>
<ul style="list-style-type:none">


<li>
<p>
5.1. Reliable distribution
</p>


</li>
<li>


<p>
5.2. Independent Set
</p>


</li>
<li>


<p>
5.3. Party Problem
</p>
</li>
</ul>
</li>
<li>


<p>
6. Miscellaneous
</p>
<ul style="list-style-type:none">


<li>
<p>
6.1. Compute Next Higher Number
</p>


</li>
<li>


<p>
6.2. Searching in Possibly Empty Two Dimensional Sequence
</p>


</li>
<li>


<p>
6.3. Matching Nuts and Bolts Optimally
</p>


</li>
<li>


<p>
6.4. Random-number generation
</p>


</li>
<li>


<p>
6.5. Weighted Median
</p>


</li>
<li>


<p>
6.6. Compute \(a^{n}\)
</p>


</li>
<li>


<p>
6.7. Compute \(a^{n}\) revisited
</p>


</li>
<li>


<p>
6.8. Compute the product \(a \times b\)
</p>


</li>
<li>


<p>
6.9. Compute the quotient and remainder
</p>


</li>
<li>


<p>
6.10. Compute GCD
</p>


</li>
<li>


<p>
6.11. Computed Constrained GCD
</p>


</li>
<li>


<p>
6.12. Alternative Euclidâ€™ Algorithm
</p>


</li>
<li>


<p>
6.13. Revisit Constrained GCD
</p>


</li>
<li>


<p>
6.14. Compute Square using only addition and subtraction
</p>


</li>
<li>


<p>
6.15. Factorization
</p>


</li>
<li>


<p>
6.16. Factorization Revisited
</p>


</li>
<li>


<p>
6.17. Decimal Representation
</p>


</li>
<li>


<p>
6.18. Reverse Decimal Representation
</p>


</li>
<li>


<p>
6.19. Solve Inequality
</p>


</li>
<li>


<p>
6.20. Solve Inequality Revisited
</p>


</li>
<li>


<p>
6.21. Print Decimal Representation
</p>


</li>
<li>


<p>
6.22. Decimal Period Length
</p>


</li>
<li>


<p>
6.23. Sequence Periodicity Problem
</p>


</li>
<li>


<p>
6.24. Compute Function
</p>


</li>
<li>


<p>
6.25. Emulate Division and Modulus Operations
</p>


</li>
<li>


<p>
6.26. Sorting Array of Strings : Linear Time
</p>


</li>
<li>


<p>
6.27. LRU data structure
</p>


</li>
<li>


<p>
6.28. Exchange Prefix and Suffix
</p>
</li>
</ul>
</li>
<li>


<p>
7. Parallel Algorithms
</p>
<ul style="list-style-type:none">


<li>
<p>
7.1. Parallel Addition
</p>


</li>
<li>


<p>
7.2. Find Maximum
</p>


</li>
<li>


<p>
7.3. The Parallel Prefix Problem
</p>


</li>
<li>


<p>
7.4. Finding Ranks in Linked Lists
</p>


</li>
<li>


<p>
7.5. Finding the \(k^{th}\) Smallest Element on a Tree
</p>
</li>
</ul>
</li>
<li>


<p>
8. Low Level Algorithms
</p>
<ul style="list-style-type:none">


<li>
<p>
8.1. Introduction
</p>


</li>
<li>


<p>
8.2. Bit Counting Algorithms
</p>


</li>
<li>


<p>
8.3. Rearranging Algorithms
</p>


</li>
<li>


<p>
8.4. Computing Functions
</p>


</li>
<li>


<p>
8.5. Miscellaneous
</p>
</li>
</ul>
</li>
</ul>
</li>
<li>


<p>
II C++
</p>
<ul style="list-style-type:none">


<li>
<p>
1 General
</p>


</li>
<li>


<p>
2 Constant Expression
</p>


</li>
<li>


<p>
3 Type Specifier
</p>


</li>
<li>


<p>
4 Namespaces
</p>


</li>
<li>


<p>
5 Misc
</p>


</li>
<li>


<p>
6 Classes
</p>


</li>
<li>


<p>
7 Templates
</p>


</li>
<li>


<p>
8 Standard Library
</p>
</li>
</ul>
</li>
</ul>



<div class="hrule">

</div>

<p>
<span class="underline"><b><span
      class="textcolor"
      style="color:#FF7D00"
>Excerpt from the Chapter</span> <span
      class="textcolor"
      style="color:#4D0000"
>1:</span></b></span>
</p>
<!--................................-->
<h4 id="autosec-276">Select Kth Smallest Element</h4>
<a id="index-autopage-276"></a>
<!--................................-->
<h5 id="autosec-277">Problem</h5>
<a id="index-autopage-277"></a>



<p>
Design and implement an efficient algorithm to select the \(K^{th}\) Smallest Element of an array.
</p>
<!--................................-->
<h5 id="autosec-278">Basic Analysis</h5>
<a id="index-autopage-278"></a>
<!--................................-->
<h6 id="autosec-279">Simultaneous Min-Max Algorithm</h6>
<a id="index-autopage-279"></a>



<p>
Before embarking on this selection problem, let us work out a general scheme of finding maximum and minimum of the input sequence. Min-max algorithms are ubiquitous in various applications
specially geometric ones. In this section we will revisit several versions with primary focus being finding the most efficient one.
</p>

<p>
<em>Design an efficient algorithm to find the minimum and maximum of an integer sequence simultaneously.</em>
</p>

<p>
Let us revisit a typical set-up for finding the maximum of an integer sequence where we end up examine each element of the sequence in turn along with keeping track of the largest element seen so
far.
</p>

<figure id="autoid-27" class="figure ">
<div class="center">

<p>
<span
      class="fbox"
      style="display:inline-block ; border:1pt solid #000000; padding:3pt ; color:#000000"
><b><span
      class="textcolor"
      style="color:#808000"
>Maximum of a sequence</span></b></span>
</p>
</div>
<ul style="list-style-type:none">


<li>
<p>
1: <span style="width:0pt; display:inline-block;"></span><b>function</b> <span class="textsc">maxval</span>(a, l, r)
</p>


</li>
<li>


<p>
2:     <span style="width:15pt; display:inline-block;"></span>\(0\le n\)
</p>


</li>
<li>


<p>
3:     <span style="width:15pt; display:inline-block;"></span>\(a[k] \ge a[0..n - 1]\)
</p>


</li>
<li>


<p>
4:     <span style="width:15pt; display:inline-block;"></span>\(i\gets 1\)
</p>


</li>
<li>


<p>
5:     <span style="width:15pt; display:inline-block;"></span>\(k\gets 0\)
</p>
</li>
<li>


<p>
6:     <span style="width:15pt; display:inline-block;"></span><b>while</b> \(0\le n\) <b>do</b>
</p>


</li>
<li>


<p>
7:       <span style="width:30pt; display:inline-block;"></span><b>if</b> \(a[i] \le a[k]\) <b>then</b>
</p>


</li>
<li>


<p>
8:          <span style="width:45pt; display:inline-block;"></span><em>do nothing</em>
</p>


</li>
<li>


<p>
9:       <span style="width:30pt; display:inline-block;"></span><b>else</b> <b>if</b> \(a[i] \ge a[k]\) <b>then</b>
</p>


</li>
<li>


<p>
10:          <span style="width:45pt; display:inline-block;"></span>\(k\gets i\)
</p>


</li>
<li>


<p>
11:       <span style="width:30pt; display:inline-block;"></span><b>end</b> <b>if</b>
</p>


</li>
<li>


<p>
12:       <span style="width:30pt; display:inline-block;"></span>\(i\gets i + 1\)
</p>


</li>
<li>


<p>
13:     <span style="width:15pt; display:inline-block;"></span><b>end</b> <b>while</b>
</p>


</li>
<li>


<p>
14:     <span style="width:15pt; display:inline-block;"></span><b>return</b> \(k\)
</p>


</li>
<li>


<p>
15: <span style="width:0pt; display:inline-block;"></span><b>end</b> <b>function</b>
</p>
</li>
</ul>

</figure>
<a id="autoid-28" ></a >



<div class="figurecaption">

<p>
Listing&nbsp;30.1:&nbsp;Finding Maximum in an integer array
</p>
</div>
<pre class="programlisting">
1 #include &lt;vector&gt;
2 #include &lt;algorithm&gt;
3 #include &lt;cassert&gt;
4
5 template &lt;typename T&gt;
6 size_t maxValArray(std::vector&lt;T&gt; &amp; v)
7{
8     size_t i = 1, k = 0;
9     size_t n = v.size () ;
10
11     while(i &lt;= n)
12     {
13         if (v[ i ] &gt;= v[k]) k = i;
14         ++i;
15     }
16
17     assert(v[k] == âˆ—std::max_element(v.begin(),
18                                       v.end()));
19     return k;
20 }
21
22 int main()
23 {
24     std::vector&lt;int&gt; v {10, 12, 2, 8, 5, 20, 7};
25     maxValArray(v);
26 }
</pre>

<p>
As can be seen that this doesnâ€™t address the scenario in presence of multiple occurrences. Let us put forth obvious solutions.
</p>
<a id="autoid-29" ></a >



<div class="figurecaption">

<p>
Listing&nbsp;30.2:&nbsp;Finding First Maximum in an integer array
</p>
</div>
<pre class="programlisting">
1 template &lt;typename ForwardIterator&gt;
2 ForwardIterator first_max_element(
3    ForwardIter first, ForwardIter last)
4{
5    if ( first == last) return last;
6    ForwardIter max_result = first;
7    while (++first != last)
8    {
9         if (âˆ—max_result &lt; âˆ— first )
10             max_result = first;
11    }
12     return max_result;
13 }
</pre>
<a id="autoid-30" ></a >



<div class="figurecaption">

<p>
Listing&nbsp;30.3:&nbsp;Finding First Maximum Satisfying Predicate
</p>
</div>
<pre class="programlisting">
1 #include &lt;boost/iterator_adaptors.hpp&gt;
2
3 template &lt;typename ForwardIterator,
4            typename Predicate&gt;
5 ForwardIterator
6 first_max_element_if(ForwardIter first,
7                      ForwardIter last,
8                      Predicate pred)
9{
10      return first_max_element(
11          boost::make_filter_iterator( first , last ,
12                                      pred),
13          boost::make_filter_iterator(last , last ,
14                                      pred)
15      );
16 }
</pre>
<a id="autoid-31" ></a >



<div class="figurecaption">

<p>
Listing&nbsp;30.4:&nbsp;Finding First Minimum in an integer array
</p>
</div>
<pre class="programlisting">
1 template &lt;typename ForwardIterator&gt;
2 ForwardIterator first_min_element(
3    ForwardIter first, ForwardIter last)
4{
5    if ( first == last) return last;
6    ForwardIter min_result = first;
7    while (++first != last)
8    {
9         if (âˆ— first &lt; âˆ—min_result)
10             min_result = first ;
11    }
12     return min_result;
13 }
</pre>

<p>
Please note that :<br />


</p>
<a id="autoid-32" ></a >



<div class="figurecaption">

<p>
Listing&nbsp;30.5:&nbsp;Ordering Equivalence
</p>
</div>
<pre class="programlisting">
1 std::min_element(v.begin(), v.end(),
2                std::less&lt;int&gt;())
3 ==
4 std::max_element(v.begin(), v.end(),
5                std::greater&lt;int&gt;())
</pre>
<a id="autoid-33" ></a >



<div class="figurecaption">

<p>
Listing&nbsp;30.6:&nbsp;Finding Last Maximum in an integer array
</p>
</div>
<pre class="programlisting">
1 template &lt;typename ForwardIterator&gt;
2 ForwardIterator last_max_element(
3    ForwardIter first, ForwardIter last)
4{
5    if ( first == last) return last;
6    ForwardIter max_result = first;
7    while (++first != last)
8    {
9         if (âˆ— first &lt; âˆ—max_result)
10         max_result = first;
11    }
12     return max_result;
13 }
</pre>
<a id="autoid-34" ></a >



<div class="figurecaption">

<p>
Listing&nbsp;30.7:&nbsp;Finding Last Minimum in an integer array
</p>
</div>
<pre class="programlisting">
1 template &lt;typename ForwardIterator&gt;
2 ForwardIterator last_min_element(
3    ForwardIter first, ForwardIter last)
4{
5    if ( first == last) return last;
6    ForwardIter min_result = first;
7    while (++first != last)
8    {
9         if (âˆ—min_result &lt; âˆ— first )
10             min_result = first ;
11    }
12     return min_result;
13 }
</pre>

<p>
Please note that:<br />


</p>
<a id="autoid-35" ></a >



<div class="figurecaption">

<p>
Listing&nbsp;30.8:&nbsp;Another Ordering Equivalence
</p>
</div>
<pre class="programlisting">
1 std::reverse_iterator(
2     first_min_element(v.begin(), v.end(),
3                       std::less&lt;int&gt;()))
4 ==
5 last_max_element(v.rbegin(), v.rend(),
6                  std::greater&lt;int&gt;())
</pre>

<p>
All of these algorithms work in similar way requiring <em>n - 1</em> comparisons in worst case.
</p>

<p>
How about simultaneously finding maximum and minimum of the sequence?
</p>

<p>
Naively, we can get this done in two passes : once for finding maximum and another for finding minimum : total of <em>2n - 2</em> comparisons. But we can definitely do better if we confine
ourselves to a single pass and reply on maintaining maximum and minimum elements seen so far. Instead of picking one element and probing it against the current maximum or minimum, we can
rather examine two elements at a time treating them as pairs. The process goes like this:
</p>
<ul style="list-style-type:none">


<li>
<p>
1. Maintain the minimum and maximum of elements seen so far.
</p>


</li>
<li>


<p>
2. Donâ€™t compare each element to the minimum and maximum separately, which requires two comparisons per element.
</p>


</li>
<li>


<p>
3. Pick up the elements in pairs.
</p>


</li>
<li>


<p>
4. Compare the elements of a pair to each other.
</p>


</li>
<li>


<p>
5. Then compare the larger element to the maximum so far, and compare the smaller element to the minimum so far.
</p>
</li>
</ul>

<p>
The above requires only three comparisons per two elements. Setting up the initial values for the min and max depends on whether n is odd or even.
</p>
<ul style="list-style-type:none">


<li>
<p>
â€¢ If n is even, compare the first two elements and assign the larger to max and the smaller to min.<br />
This needs one initial comparison and then \(\frac {3(n - 2)}{2}\) more comparisons. Thus total number of comparisons =<br />
1 + \(\frac {3(n - 2)}{2}\)<br />
= 1 + \(\frac {3n - 6}{2}\)<br />
= 1 + \(\frac {3n}{2}\) - 3<br />
= \(\frac {3n}{2}\) - 2.<br />
Then process the rest of the elements in pairs.
</p>


</li>
<li>


<p>
â€¢ If n is odd, set both min and max to the first element. Then process the rest of the elements in pairs. This needs a total of \(\frac {3(n - 1)}{2}\) comparisons.
</p>
</li>
</ul>
<a id="autoid-36" ></a >



<div class="figurecaption">

<p>
Listing&nbsp;30.9:&nbsp;C++ Implementation of first min and first max
</p>
</div>
<pre class="programlisting">
1 template &lt;typename ForwardIterator&gt;
2 std::pair&lt;ForwardIterator, ForwardIterator&gt;
3 first_min_first_max_element(
4      ForwardIterator first,
5      ForwardIterator last)
6{
7      if ( first == last)
8            return std::make_pair(last,last);
9
10      ForwardIterator min_result,
11                           max_result = first;
12
13       // if only one element
14      ForwardIterator second = first; ++second;
15
16       if (second == last)
17      return std::make_pair(min_result,
18                                 max_result);
19
20       // treat first pair separately
21       // (only one comparison for
22       // first two elements)
23      ForwardIterator
24          potential_min_result = last;
25
26       if (âˆ— first &lt; âˆ—second) max_result = second;
27      else
28      {
29            min_result = second;
30            potential_min_result = first ;
31      }
32
33       // then each element by pairs,
34       // with at most 3 comparisons per pair
35       first = ++second;
36
37       if ( first != last ) ++second;
38
39      while (second != last)
40      {
41            if (âˆ— first &lt; âˆ—second)
42            {
43                  if (âˆ— first &lt; âˆ—min_result)
44                 {
45                      min_result = first ;
46                      potential_min_result = last;
47                 }
48
49                  if (âˆ—max_result &lt; âˆ—second)
50                      max_result = second;
51            }
52            else
53            {
54                  if (âˆ—second &lt; âˆ—min_result)
55                 {
56                      min_result = second;
57                      potential_min_result = first ;
58                 }
59
60                  if (âˆ—max_result &lt; âˆ— first )
61                      max_result = first;
62            }
63
64             first = ++second;
65
66            if ( first != last ) ++second;
67      }
68
69       // if odd number of elements,
70       // treat last element
71       if ( first != last )
72      { // odd number of elements
73            if (âˆ— first &lt; âˆ—min_result)
74            {
75                 min_result = first ;
76                 potential_min_result = last;
77            }
78            else if (âˆ—max_result &lt; âˆ— first )
79                 max_result = first;
80      }
81
82       // resolve min_result being incorrect
83       // with one extra comparison
84       // (in which case potential_min_result
85       // is necessarily the
86       // correct result)
87       if (potential_min_result != last &amp;&amp;
88            !(âˆ—min_result &lt; âˆ—potential_min_result))
89      min_result = potential_min_result;
90
91      return
92          std::make_pair(min_result,max_result);
93 }
</pre>

<p>
Please note that only one comparison is required for first two elements(aka first pair). The above requires at most three comparisons per pair.
</p>

<p>
In similar spirit, there are multiple combinations possible like:
</p>
<ul style="list-style-type:none">


<li>
<p>
â€¢ first_min_first_max_element
</p>


</li>
<li>


<p>
â€¢ first_min_last_max_element
</p>


</li>
<li>


<p>
â€¢ last_min_first_max_element
</p>


</li>
<li>


<p>
â€¢ last_min_last_max_element
</p>
</li>
</ul>

<p>
Let us look at the implementation of<br />
first_min_last_max_element as inspiration.
</p>
<a id="autoid-37" ></a >



<div class="figurecaption">

<p>
Listing&nbsp;30.10:&nbsp;first_min_last_max_element
</p>
</div>
<pre class="programlisting">
1 template &lt;typename ForwardIterator&gt;
2 std::pair&lt;ForwardIterator,ForwardIterator&gt;
3 first_min_last_max_element(
4      ForwardIterator first,
5      ForwardIterator last)
6{
7      if ( first == last)
8           return std::make_pair(last,last);
9
10      ForwardIterator min_result,
11                          max_result = first;
12
13      ForwardIterator second = ++first;
14
15       if (second == last)
16      return std::make_pair(min_result,
17                                max_result);
18
19       if (âˆ—second &lt; âˆ—min_result)
20           min_result = second;
21      else max_result = second;
22
23       first = ++second;
24
25       if ( first != last ) ++second;
26
27      while (second != last)
28      {
29            if (!(âˆ—second &lt; âˆ— first ) )
30           {
31                 if (âˆ— first &lt; âˆ—min_result)
32                     min_result = first ;
33                 if (!(âˆ—second &lt; âˆ—max_result))
34                     max_result = second;
35           }
36           else
37           {
38                 if (âˆ—second &lt; âˆ—min_result)
39                     min_result = second;
40                 if (!(âˆ— first &lt; âˆ—max_result))
41                     max_result = first;
42           }
43
44            first = ++second;
45
46            if ( first != last ) ++second;
47      }
48
49       if ( first != last )
50      {
51            if (âˆ— first &lt; âˆ—min_result)
52                min_result = first ;
53           else if (!(âˆ— first &lt; âˆ—max_result))
54                max_result = first;
55      }
56      return std::make_pair(min_result, max_result);
57 }
</pre>
<!--................................-->
<h6 id="autosec-291">Generic Select</h6>
<a id="index-autopage-291"></a>



<p>
Selection can be reduced to sorting by sorting the sequence and then extracting the sought after element. This method is more efficient when many selections need to be made from a sequence, in
which case only one initial, so-called expensive sort is needed, followed by many relatively less expensive extraction operations, usually in amortized constant time. In general, this method requires
\(O(n \log n)\) time, where <em>n</em> is the length of the sequence.
</p>

<p>
Let us try using similar ideas as in finding minimum and maximum of a given sequence for finding the \(k^{th}\) smallest or \(k^{th}\) largest element in a sequence.
</p>

<figure id="autoid-38" class="figure ">
<div class="center">

<p>
<span
      class="fbox"
      style="display:inline-block ; border:1pt solid #000000; padding:3pt ; color:#000000"
><b><span
      class="textcolor"
      style="color:#808000"
>Generic Kth Select Minimum</span></b></span>
</p>
</div>
<ul style="list-style-type:none">


<li>
<p>
1: <span style="width:0pt; display:inline-block;"></span><b>function</b> <span class="textsc">generic-kth-min-select</span>(a, l, r, k)
</p>


</li>
<li>


<p>
2:     <span style="width:15pt; display:inline-block;"></span>\(numElements \gets r - l + 1\)
</p>


</li>
<li>


<p>
3:     <span style="width:15pt; display:inline-block;"></span><b>for</b> \(i \gets 1\), \(k\) <b>do</b>
</p>


</li>
<li>


<p>
4:       <span style="width:30pt; display:inline-block;"></span>\(minIndex \gets i\)
</p>


</li>
<li>


<p>
5:       <span style="width:30pt; display:inline-block;"></span>\(minVal \gets a[i]\)
</p>


</li>
<li>


<p>
6:       <span style="width:30pt; display:inline-block;"></span><b>for</b> \(j \gets i + 1, numElements\) <b>do</b>
</p>


</li>
<li>


<p>
7:          <span style="width:45pt; display:inline-block;"></span><b>if</b> \(a[j] &lt; minVal\) <b>then</b>
</p>


</li>
<li>


<p>
8:            <span style="width:60pt; display:inline-block;"></span>\(minIndex \gets j\)
</p>


</li>
<li>


<p>
9:            <span style="width:60pt; display:inline-block;"></span>\(minVal \gets a[j]\)
</p>


</li>
<li>


<p>
10:          <span style="width:45pt; display:inline-block;"></span><b>end</b> <b>if</b>
</p>


</li>
<li>


<p>
11:       <span style="width:30pt; display:inline-block;"></span><b>end</b> <b>for</b>
</p>


</li>
<li>


<p>
12:       <span style="width:30pt; display:inline-block;"></span>\(swap(a[i], a[minIndex])\)
</p>


</li>
<li>


<p>
13:     <span style="width:15pt; display:inline-block;"></span><b>end</b> <b>for</b>
</p>


</li>
<li>


<p>
14:     <span style="width:15pt; display:inline-block;"></span><b>return</b> \(a[k]\)
</p>


</li>
<li>


<p>
15: <span style="width:0pt; display:inline-block;"></span><b>end</b> <b>function</b>
</p>
</li>
</ul>

</figure>
<a id="autoid-39" ></a >



<div class="figurecaption">

<p>
Listing&nbsp;30.11:&nbsp;Generic Kth Select Minimum
</p>
</div>
<pre class="programlisting">
1 #include &lt;algorithm&gt;
2 #include &lt;utility&gt;
3 #include &lt;vector&gt;
4 #include &lt;cassert&gt;
5
6 int generic_kth_minselect(std::vector&lt;int&gt; &amp; a,
7                           size_t k)
8{
9     size_t minIndex = 0;
10     size_t minVal = a[0];
11
12     size_t numElements = a.size();
13
14     for(size_t i = 0; i &lt; k; ++i)
15     {
16         minIndex = i;
17         minVal = a[i];
18
19         for(size_t j = i + 1;
20             j &lt; numElements; ++j)
21         {
22             minIndex = j;
23             minVal = a[j];
24         }
25         std::swap(a[i], a[minIndex]);
26     }
27     return a[k âˆ’ 1];
28 }
29
30
31 int main()
32 {
33     std::vector&lt;int&gt; v {1, 23, 12, 9, 30, 2, 50};
34
35     int fourth_min = generic_kth_minselect(v, 4);
36
37     assert(fourth_min == 12);
38 }
</pre>

<p>
As can be seen that time complexity of this inefficient selection algorithm is \(O(kn)\), where n is the length of the sequence, which is acceptable when <em>k</em> is small enough. It works by
simply finding the most minimum element and moving it to the beginning until we reach our desired index, i.e., <em>k</em>. It resembles a <em>partial selection sort</em>.
</p>
<!--................................-->
<h5 id="autosec-294">Randomized Quick Select Algorithm</h5>
<a id="index-autopage-294"></a>



<p>
Let us recall <em><span class="textsc">randomized-partition</span></em> and <em><span class="textsc">randomized-quicksort</span></em> algorithms to help us build an efficient
selection algorithm.
</p>
<figure id="autoid-40" class="figure ">
<div class="center">

<p>
<span
      class="fbox"
      style="display:inline-block ; border:1pt solid #000000; padding:3pt ; color:#000000"
><b><span
      class="textcolor"
      style="color:#808000"
>Partitioning a sequence</span></b></span>
</p>
</div>
<ul style="list-style-type:none">


<li>
<p>
1: <span style="width:0pt; display:inline-block;"></span><b>function</b> <span class="textsc">partition</span>(a, l, r)
</p>


</li>
<li>


<p>
2:     <span style="width:15pt; display:inline-block;"></span>\(p\gets a[r]\)
</p>


</li>
<li>


<p>
3:     <span style="width:15pt; display:inline-block;"></span>\(i \gets l - 1\)
</p>


</li>
<li>


<p>
4:     <span style="width:15pt; display:inline-block;"></span><b>for</b> \(j \gets l\), \(r - 1\) <b>do</b>
</p>


</li>
<li>


<p>
5:       <span style="width:30pt; display:inline-block;"></span><b>if</b> \(a[j] \le p\) <b>then</b>
</p>


</li>
<li>


<p>
6:          <span style="width:45pt; display:inline-block;"></span>\(i \gets i + 1\)
</p>


</li>
<li>


<p>
7:          <span style="width:45pt; display:inline-block;"></span>\(swap(a[i], a[j])\)
</p>


</li>
<li>


<p>
8:       <span style="width:30pt; display:inline-block;"></span><b>end</b> <b>if</b>
</p>


</li>
<li>


<p>
9:     <span style="width:15pt; display:inline-block;"></span><b>end</b> <b>for</b>
</p>


</li>
<li>


<p>
10:     <span style="width:15pt; display:inline-block;"></span><b>return</b> \(i + 1\)
</p>


</li>
<li>


<p>
11: <span style="width:0pt; display:inline-block;"></span><b>end</b> <b>function</b>
</p>
</li>
</ul>

</figure>

<figure id="autoid-41" class="figure ">
<div class="center">

<p>
<span
      class="fbox"
      style="display:inline-block ; border:1pt solid #000000; padding:3pt ; color:#000000"
><b><span
      class="textcolor"
      style="color:#808000"
>Randomized Partition Algorithm</span></b></span>
</p>
</div>
<ul style="list-style-type:none">


<li>
<p>
1: <span style="width:0pt; display:inline-block;"></span><b>function</b> <span class="textsc">randomized-partition</span>(a, l, r)
</p>


</li>
<li>


<p>
2:     <span style="width:15pt; display:inline-block;"></span>\(i \gets random(l, r)\)
</p>


</li>
<li>


<p>
3:     <span style="width:15pt; display:inline-block;"></span>\(swap(a[r], a[i])\)
</p>


</li>
<li>


<p>
4:     <span style="width:15pt; display:inline-block;"></span><b>return</b> <span class="textsc">partition</span>\((a, l, r)\)
</p>


</li>
<li>


<p>
5: <span style="width:0pt; display:inline-block;"></span><b>end</b> <b>function</b>
</p>
</li>
</ul>

</figure>

<figure id="autoid-42" class="figure ">
<div class="center">

<p>
<span
      class="fbox"
      style="display:inline-block ; border:1pt solid #000000; padding:3pt ; color:#000000"
><b><span
      class="textcolor"
      style="color:#808000"
>Randomized Quicksort Algorithm</span></b></span>
</p>
</div>
<ul style="list-style-type:none">


<li>
<p>
1: <span style="width:0pt; display:inline-block;"></span><b>function</b> <span class="textsc">randomized-quicksort</span>(a, l, r)
</p>


</li>
<li>


<p>
2:     <span style="width:15pt; display:inline-block;"></span>\(p \gets \) <span class="textsc">randomized-partition</span>\((a, l, r)\)
</p>


</li>
<li>


<p>
3:     <span style="width:15pt; display:inline-block;"></span><span class="textsc">randomized-quicksort</span>\((a, l, p - 1)\)
</p>


</li>
<li>


<p>
4:     <span style="width:15pt; display:inline-block;"></span><span class="textsc">randomized-quicksort</span>\((a, p + 1, r)\)
</p>


</li>
<li>


<p>
5: <span style="width:0pt; display:inline-block;"></span><b>end</b> <b>function</b>
</p>
</li>
</ul>

</figure>

<p>
Let us model the algorithm <em>randomized-select</em> based on <em>randomized-quicksort</em>, but unlike quicksort, which involves partitioning the input array followed by processing both
sides of the partition recursively, <em>randomized-select</em> works on only one side of the partition, thus throwing away the other partition.
</p>
<!--................................-->
<h5 id="autosec-298">Algorithm</h5>
<a id="index-autopage-298"></a>



<figure id="autoid-43" class="figure ">
<div class="center">

<p>
<span
      class="fbox"
      style="display:inline-block ; border:1pt solid #000000; padding:3pt ; color:#000000"
><b><span
      class="textcolor"
      style="color:#808000"
>Randomized Kth Min Select Algorithm</span></b></span>
</p>
</div>
<ul style="list-style-type:none">


<li>
<p>
1: <span style="width:0pt; display:inline-block;"></span><b>function</b> <span class="textsc">randomized-kth-min-select</span>(a, l, r, k)
</p>


</li>
<li>


<p>
2:     <span style="width:15pt; display:inline-block;"></span>\(p \gets \) <span class="textsc">randomized-partition</span>\((a, l, r)\)
</p>


</li>
<li>


<p>
3:     <span style="width:15pt; display:inline-block;"></span>\(pdist \gets p - l + 1\)
</p>


</li>
<li>


<p>
4:     <span style="width:15pt; display:inline-block;"></span><b>if</b> k == mid <b>then</b>
</p>


</li>
<li>


<p>
5:       <span style="width:30pt; display:inline-block;"></span><b>return</b> \(a[p]\)
</p>


</li>
<li>


<p>
6:     <span style="width:15pt; display:inline-block;"></span><b>else</b> <b>if</b> k < pdist <b>then</b>
</p>


</li>
<li>


<p>
7:       <span style="width:30pt; display:inline-block;"></span><b>return</b> <span class="textsc">randomized-kth-min-select</span>\((a, l, p - 1, k)\)
</p>


</li>
<li>


<p>
8:     <span style="width:15pt; display:inline-block;"></span><b>else</b> <b>if</b> k > pdist <b>then</b>
</p>


</li>
<li>


<p>
9:       <span style="width:30pt; display:inline-block;"></span><b>return</b> <span class="textsc">randomized-kth-min-select</span>\((a, p + 1, r, k - pdist)\)
</p>


</li>
<li>


<p>
10:     <span style="width:15pt; display:inline-block;"></span><b>end</b> <b>if</b>
</p>


</li>
<li>


<p>
11: <span style="width:0pt; display:inline-block;"></span><b>end</b> <b>function</b>
</p>
</li>
</ul>

</figure>

<p>
And it is not that difficult to see that average case time complexity of the algorithm <em><span class="textsc">randomized-kth-min-select</span></em> is \(\Theta (n)\) and worst case time
complexity is \(\Theta (n^{2})\), assuming that the elements are distinct.
</p>
<!--................................-->
<h5 id="autosec-300">C++11 Implementation</h5>
<a id="index-autopage-300"></a>
<a id="autoid-44" ></a >



<div class="figurecaption">

<p>
Listing&nbsp;30.12:&nbsp;Randomized version of Kth Select Minimum
</p>
</div>
<pre class="programlisting">
1 #include &lt;utility&gt;
2 #include &lt;cassert&gt;
3 #include &lt;cstdlib&gt;
4
5 int partition(int a[], int l , int r)
6{
7     int p = a[r];
8     int i = l âˆ’ 1;
9
10     for(int j = l; j &lt;= r âˆ’ 1; j++)
11     {
12           if (a[ j ] &lt;= p)
13           {
14                i = i + 1;
15                std::swap(a[i], a[ j ]) ;
16           }
17     }
18
19     std::swap(a[i + 1], a[r]) ;
20
21     return i + 1;
22 }
23
24
25 int randomized_partition(int a[], int l , int r)
26 {
27     int i = l + std::rand() % (r âˆ’ l + 1);
28     std::swap(a[r], a[i ]) ;
29     return partition(a, l, r) ;
30 }
31
32
33 int randomized_select(int a[], int l , int r ,
34                            size_t k)
35 {
36     int p, pdist;
37     if ( l &lt; r)
38     {
39           p = randomized_partition(a, l, r);
40
41           pdist = p âˆ’ l + 1;
42
43           if (k == pdist) // pivot is the element
44                return a[p];
45           else if (k &lt; pdist)
46                return randomized_select(
47                             a, l , p âˆ’ 1, k);
48           else // k &gt; pdist
49                return randomized_select(
50                             a, p + 1, r , k âˆ’ pdist);
51     }
52 }
53
54
55 int main()
56 {
57     int a[] = {8, 1, 6, 4, 0, 3, 9, 5};
58
59     int sixth_min =
60           randomized_select(a, 0, 7, 6);
61
62     assert(sixth_min = 8);
63 }
</pre>

<p>
<em><span class="textsc">randomized-kth-min-select</span></em> differs from<br />
<em><span class="textsc">randomized-quicksort</span></em> because it recurses on one side of the partition only. After the call to <em><span
class="textsc">randomized-partition</span></em>, the sequence \(a[l..r]\) is partitioned into two sub-sequences \(a[l..p - 1]\) and \(a[p + 1..r]\), along with a pivot element \(a[p]\).
</p>
<ul style="list-style-type:none">


<li>
<p>
â€¢ The elements of sub-sequence \(a[l..p - 1]\) are all \(\le a[p]\).
</p>


</li>
<li>


<p>
â€¢ The elements of sub-sequence \(a[p + 1.. r]\) are all \(&gt; a[p]\).
</p>


</li>
<li>


<p>
â€¢ The pivot element is the \(pdist^{th}\) element of the sub-sequence \(a[l..r]\), where \(pdist = p âˆ’ l + 1\).
</p>


</li>
<li>


<p>
â€¢ If the pivot element is the \(k^{th}\) smallest element (i.e., k = pdist), return A[p].
</p>


</li>
<li>


<p>
â€¢ Otherwise, recurse on the sub-sequence containing the \(k^{th}\) smallest element.
</p>
<ul style="list-style-type:none">


<li>
<p>
â€“ If \(k &lt; pdist\), this sub-sequence is \(a[l..p - 1]\) and we want the \(k^{th}\) smallest element.
</p>


</li>
<li>


<p>
â€“ If \(k &gt; pdist\), this sub-sequence is \(a[p + 1.. r]\) and, since there are <em>pdist</em> elements in \(a[l..r]\) that precede \(a[p + 1.. r]\), we want the \((k -
pdist)^{th}\) smallest element of this sub-sequence.
</p>
</li>
</ul>
</li>
</ul>

<p>
It resembles a <em>partial quicksort</em>, generating and partitioning only \(O(\log n)\) of its \(O(n)\) partitions. This simple algorithm has expected linear performance, and, like quicksort, has
quite good performance in practice. It is also an <em>in-place</em> algorithm, requiring only constant memory overhead, since the tail recursion can be eliminated with an equivalent iterative
version as shown in the next section. In a <em>tail recursion</em>, the call is always the last action in an algorithm. A tail-recursive algorithm can always be transformed into an equivalent iterative
algorithm with a <em>while</em> loop as shown ahead.
</p>
<!--................................-->
<h5 id="autosec-302">Iterative Version of Quick Select Algorithm</h5>
<a id="index-autopage-302"></a>



<figure id="autoid-45" class="figure ">
<div class="center">

<p>
<span
      class="fbox"
      style="display:inline-block ; border:1pt solid #000000; padding:3pt ; color:#000000"
><b><span
      class="textcolor"
      style="color:#808000"
>Iterative Version of Quick Select Algorithm</span></b></span>
</p>
</div>
<ul style="list-style-type:none">


<li>
<p>
1: <span style="width:0pt; display:inline-block;"></span><b>function</b> <span class="textsc">randomized-kth-min-select</span>(a, l, r, k)
</p>


</li>
<li>


<p>
2:     <span style="width:15pt; display:inline-block;"></span><b>while</b> l < r <b>do</b>
</p>


</li>
<li>


<p>
3:       <span style="width:30pt; display:inline-block;"></span>\(p \gets \) <span class="textsc">randomized-partition</span>\((a, l, r)\)
</p>


</li>
<li>


<p>
4:       <span style="width:30pt; display:inline-block;"></span>\(pdist \gets p - l + 1\)
</p>


</li>
<li>


<p>
5:       <span style="width:30pt; display:inline-block;"></span><b>if</b> k == mid <b>then</b>
</p>


</li>
<li>


<p>
6:          <span style="width:45pt; display:inline-block;"></span><b>return</b> \(a[p]\)
</p>


</li>
<li>


<p>
7:       <span style="width:30pt; display:inline-block;"></span><b>else</b> <b>if</b> k < pdist <b>then</b>
</p>


</li>
<li>


<p>
8:          <span style="width:45pt; display:inline-block;"></span>\(r \gets p - 1\)
</p>


</li>
<li>


<p>
9:       <span style="width:30pt; display:inline-block;"></span><b>else</b> <b>if</b> k > pdist <b>then</b>
</p>


</li>
<li>


<p>
10:          <span style="width:45pt; display:inline-block;"></span>\(l \gets p + 1\)
</p>


</li>
<li>


<p>
11:          <span style="width:45pt; display:inline-block;"></span>\(k \gets k - pdist\)
</p>


</li>
<li>


<p>
12:        <span style="width:30pt; display:inline-block;"></span><b>end</b> <b>if</b>
</p>


</li>
<li>


<p>
13:     <span style="width:15pt; display:inline-block;"></span><b>end</b> <b>while</b>
</p>


</li>
<li>


<p>
14: <span style="width:0pt; display:inline-block;"></span><b>end</b> <b>function</b>
</p>
</li>
</ul>

</figure>

</section>

</main>

</div>

<footer>

<p>
<a href="Top-20-Coding-Interview-Problems-Asked-in-Google-with-Solutions.html" class="linkhome" >
Next</a>
</p>

</footer>



<nav class="botnavigation"><a href="index.html" class="linkhome" >
Home</a></nav>

</body>
</html>
